"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceService = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const os_1 = __importDefault(require("os"));
const config_1 = require("../config");
const metadata_1 = require("../metadata");
const migrations_1 = require("../migrations");
const seed_1 = require("../seed");
const git_1 = require("../topics/git");
const utils_1 = require("../utils");
const utils_2 = require("./utils");
const vscode_1 = require("./vscode");
const workspaceServiceInterface_1 = require("./workspaceServiceInterface");
const DENDRON_WS_NAME = common_all_1.CONSTANTS.DENDRON_WS_NAME;
/** You **must** dispose workspace services you create, otherwise you risk leaking file descriptors which may lead to crashes. */
class WorkspaceService {
    /** Reminder: you **must** dispose workspace services you create, otherwise you risk leaking file descriptors which may lead to crashes. */
    constructor({ wsRoot, seedService }) {
        this.wsRoot = wsRoot;
        const { logger, dispose } = (0, common_server_1.createDisposableLogger)();
        this.logger = logger;
        this.loggerDispose = dispose;
        this._seedService = seedService || new seed_1.SeedService({ wsRoot });
    }
    static isNewVersionGreater({ oldVersion, newVersion, }) {
        return common_all_1.DUtils.semver.lt(oldVersion, newVersion);
    }
    static async isWorkspaceVault(fpath) {
        return fs_extra_1.default.pathExists(path_1.default.join(fpath, common_all_1.CONSTANTS.DENDRON_CONFIG_FILE));
    }
    dispose() {
        this.loggerDispose();
    }
    get user() {
        const fpath = path_1.default.join(this.wsRoot, common_all_1.CONSTANTS.DENDRON_USER_FILE);
        if (fs_extra_1.default.existsSync(fpath)) {
            return new common_all_1.DUser(lodash_1.default.trim(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" })));
        }
        else {
            return common_all_1.DUser.createAnonymous();
        }
    }
    static getOrCreateConfig(wsRoot) {
        return config_1.DConfig.getOrCreate(wsRoot);
    }
    get config() {
        // `createConfig` function relies on this creating a config. If revising the code, make sure to update that function as well.
        return WorkspaceService.getOrCreateConfig(this.wsRoot);
    }
    get dendronRoot() {
        return path_1.default.join(this.wsRoot, "dendron");
    }
    get seedService() {
        return this._seedService;
    }
    async setConfig(config) {
        const wsRoot = this.wsRoot;
        return config_1.DConfig.writeConfig({ wsRoot, config });
    }
    setWorkspaceConfig(config) {
        (0, common_server_1.writeJSONWithComments)(path_1.default.join(this.wsRoot, "dendron.code-workspace"), config);
    }
    getWorkspaceConfig() {
        try {
            const wsConfig = (0, common_server_1.readJSONWithCommentsSync)(path_1.default.join(this.wsRoot, common_all_1.CONSTANTS.DENDRON_WS_NAME));
            return wsConfig;
        }
        catch (err) {
            this.logger.error(err);
            return undefined;
        }
    }
    /**
     *
     * @param param0
     * @returns `{vaults}` that have been added
     */
    async addWorkspace({ workspace }) {
        const config = this.config;
        const allWorkspaces = common_all_1.ConfigUtils.getWorkspace(config).workspaces || {};
        allWorkspaces[workspace.name] = lodash_1.default.omit(workspace, ["name", "vaults"]);
        // update vault
        const newVaults = await lodash_1.default.reduce(workspace.vaults, async (acc, vault) => {
            const out = await acc;
            out.push(await this.addVault({
                config,
                vault: { ...vault, workspace: workspace.name },
                updateConfig: false,
            }));
            return out;
        }, Promise.resolve([]));
        common_all_1.ConfigUtils.setWorkspaceProp(config, "workspaces", allWorkspaces);
        this.setConfig(config);
        return { vaults: newVaults };
    }
    /**
     *
     *
     * @param opts.vault - {@link DVault} to add to workspace
     * @param opts.config - if passed it, make modifications on passed in config instead of {wsRoot}/dendron.yml
     * @param opts.writeConfig - default: true, add to dendron.yml
     * @param opts.addToWorkspace - default: false, add to dendron.code-workspace. Make sure to keep false for Native workspaces.
     * @returns
     */
    async addVault(opts) {
        const { vault, config, updateConfig, updateWorkspace } = lodash_1.default.defaults(opts, {
            config: this.config,
            updateConfig: true,
            updateWorkspace: false,
        });
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        vaults.unshift(vault);
        common_all_1.ConfigUtils.setVaults(config, vaults);
        // update dup note behavior
        if (!config.site.duplicateNoteBehavior) {
            const vaults = common_all_1.ConfigUtils.getVaults(config);
            config.site.duplicateNoteBehavior = {
                action: common_all_1.DuplicateNoteAction.USE_VAULT,
                payload: vaults.map((v) => common_all_1.VaultUtils.getName(v)),
            };
        }
        else if (lodash_1.default.isArray(config.site.duplicateNoteBehavior.payload)) {
            config.site.duplicateNoteBehavior.payload.push(common_all_1.VaultUtils.getName(vault));
        }
        if (updateConfig) {
            await this.setConfig(config);
        }
        if (updateWorkspace) {
            const wsPath = path_1.default.join(this.wsRoot, DENDRON_WS_NAME);
            let out = (await (0, common_server_1.readJSONWithComments)(wsPath));
            if (!lodash_1.default.find(out.folders, (ent) => ent.path === common_all_1.VaultUtils.getRelPath(vault))) {
                const vault2Folder = common_all_1.VaultUtils.toWorkspaceFolder(vault);
                const folders = [vault2Folder].concat(out.folders);
                out = (0, common_server_1.assignJSONWithComment)({ folders }, out);
                if (opts.onUpdatingWorkspace) {
                    await opts.onUpdatingWorkspace();
                }
                (0, common_server_1.writeJSONWithComments)(wsPath, out);
                if (opts.onUpdatedWorkspace) {
                    await opts.onUpdatedWorkspace();
                }
            }
        }
        else {
            // Run the hooks even if not updating the workspace file (native workspace), because other code depends on it.
            if (opts.onUpdatingWorkspace) {
                await opts.onUpdatingWorkspace();
            }
            if (opts.onUpdatedWorkspace) {
                await opts.onUpdatedWorkspace();
            }
        }
        return vault;
    }
    /**
     * Create vault files if it does not exist
     * @param opts.noAddToConfig: don't add to dendron.yml
     * @param opts.addToCodeWorkspace: add to dendron.code-workspace
     * @returns void
     *
     * Effects:
     *   - updates `dendron.yml` if `noAddToConfig` is not set
     *   - create directory
     *   - create root note and root schema
     */
    async createVault(opts) {
        const { vault, noAddToConfig } = opts;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        fs_extra_1.default.ensureDirSync(vpath);
        const note = common_all_1.NoteUtils.createRoot({
            vault,
            body: [
                "# Welcome to Dendron",
                "",
                `This is the root of your dendron vault. If you decide to publish your entire vault, this will be your landing page. You are free to customize any part of this page except the frontmatter on top.`,
                "",
                "## Lookup",
                "",
                "This section contains useful links to related resources.",
                "",
                "- [Getting Started Guide](https://link.dendron.so/6b25)",
                "- [Discord](https://link.dendron.so/6b23)",
                "- [Home Page](https://wiki.dendron.so/)",
                "- [Github](https://link.dendron.so/6b24)",
                "- [Developer Docs](https://docs.dendron.so/)",
            ].join("\n"),
        });
        const schema = common_all_1.SchemaUtils.createRootModule({ vault });
        if (!fs_extra_1.default.existsSync(common_all_1.NoteUtils.getFullPath({ note, wsRoot: this.wsRoot }))) {
            await (0, common_server_1.note2File)({ note, vault, wsRoot: this.wsRoot });
        }
        if (!fs_extra_1.default.existsSync(common_all_1.SchemaUtils.getPath({ root: vpath, fname: "root" }))) {
            await (0, common_server_1.schemaModuleOpts2File)(schema, vpath, "root");
        }
        if (!noAddToConfig) {
            await this.addVault({ ...opts, updateWorkspace: false });
        }
        if (opts.addToCodeWorkspace || opts.updateWorkspace) {
            await this.addVaultToCodeWorkspace(vault);
        }
        return vault;
    }
    /** Converts a local vault to a remote vault, with `remoteUrl` as the upstream URL. */
    async convertVaultRemote({ wsRoot, vault: targetVault, remoteUrl, }) {
        // Add the vault to the gitignore of root, so that it doesn't show up as part of root anymore
        await common_server_1.GitUtils.addToGitignore({
            addPath: targetVault.fsPath,
            root: wsRoot,
        });
        // Now, initialize a repository in it
        const git = new git_1.Git({
            localUrl: path_1.default.join(wsRoot, targetVault.fsPath),
            remoteUrl,
        });
        if (!(await fs_extra_1.default.pathExists(path_1.default.join(wsRoot, targetVault.fsPath, ".git")))) {
            // Avoid initializing if a git folder already exists
            await git.init();
        }
        let remote = await git.getRemote();
        if (!remote) {
            remote = await git.remoteAdd();
        }
        else {
            await git.remoteSet(remote);
        }
        const branch = await git.getCurrentBranch();
        // Add the contents of the vault and push to initialize the upstream
        await git.addAll();
        try {
            await git.commit({ msg: "Set up remote vault" });
        }
        catch (err) {
            // Ignore it if commit fails, it might happen if the vault if empty or if it was already a repo
            if (!lodash_1.default.isNumber(err === null || err === void 0 ? void 0 : err.exitCode))
                throw err;
        }
        await git.push({ remote, branch });
        // Update `dendron.yml`, adding the remote to the converted vault
        const config = this.config;
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        common_all_1.ConfigUtils.setVaults(config, vaults.map((vault) => {
            if (common_all_1.VaultUtils.isEqualV2(vault, targetVault)) {
                vault.remote = { type: "git", url: remoteUrl };
            }
            return vault;
        }));
        await this.setConfig(config);
        // Remove the vault folder from the tree of the root repository. Otherwise, the files will be there when
        // someone else pulls the root repo, which can break remote vault initialization. This doesn't delete the actual files.
        if (await fs_extra_1.default.pathExists(path_1.default.join(wsRoot, ".git"))) {
            // But only if the workspace is in a git repository, otherwise skip this step.
            const rootGit = new git_1.Git({ localUrl: wsRoot });
            await rootGit.rm({
                cached: true,
                recursive: true,
                path: targetVault.fsPath,
            });
        }
        return { remote, branch };
    }
    /** Converts a remote vault to a local vault. */
    async convertVaultLocal({ wsRoot, vault: targetVault, }) {
        // Remove vault from gitignore of root, if it's there, so it's part of root workspace again
        await common_server_1.GitUtils.removeFromGitignore({
            removePath: targetVault.fsPath,
            root: wsRoot,
        });
        // Remove the .git folder from the vault
        const gitFolder = path_1.default.join(wsRoot, targetVault.fsPath, ".git");
        await fs_extra_1.default.rm(gitFolder, {
            recursive: true,
            force: true /* It's OK if dir doesn't exist */,
        });
        // Update `dendron.yml`, removing the remote from the converted vault
        const config = this.config;
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        common_all_1.ConfigUtils.setVaults(config, vaults.map((vault) => {
            if (common_all_1.VaultUtils.isEqualV2(vault, targetVault)) {
                delete vault.remote;
            }
            return vault;
        }));
        await this.setConfig(config);
    }
    /** For vaults in the same repository, ensure that their sync configurations do not conflict. Returns the coordinated sync config. */
    verifyVaultSyncConfigs(vaults) {
        let prevVault;
        for (const vault of vaults) {
            if (lodash_1.default.isUndefined(vault.sync))
                continue;
            if (lodash_1.default.isUndefined(prevVault)) {
                prevVault = vault;
                continue;
            }
            if (prevVault.sync === vault.sync)
                continue;
            const prevVaultName = prevVault.name || prevVault.fsPath;
            const vaultName = vault.name || vault.fsPath;
            throw new common_all_1.DendronError({
                message: `Vaults ${prevVaultName} and ${vaultName} are in the same repository, but have conflicting configurations ${prevVault.sync} and ${vault.sync} set. Please remove conflicting configuration, or move vault to a different repository.`,
            });
        }
        return prevVault === null || prevVault === void 0 ? void 0 : prevVault.sync;
    }
    /** Checks if a given git command should be used on the vault based on user configuration.
     *
     * @param command The git command that we want to perform.
     * @param repo The location of the repository containing the vaults.
     * @param vaults The vaults on which the operation is being performed on.
     * @returns true if the command can be performed, false otherwise.
     */
    async shouldVaultsSync(command, [root, vaults]) {
        let workspaceVaultSyncConfig = this.verifyVaultSyncConfigs(vaults);
        if (lodash_1.default.isUndefined(workspaceVaultSyncConfig)) {
            if (await WorkspaceService.isWorkspaceVault(root)) {
                workspaceVaultSyncConfig = common_all_1.ConfigUtils.getWorkspace(this.config)
                    .workspaceVaultSyncMode;
                // default for workspace vaults
                if (lodash_1.default.isUndefined(workspaceVaultSyncConfig)) {
                    workspaceVaultSyncConfig = common_all_1.DVaultSync.NO_COMMIT;
                }
            }
            // default for regular vaults
            else
                workspaceVaultSyncConfig = common_all_1.DVaultSync.SYNC;
        }
        if (workspaceVaultSyncConfig === common_all_1.DVaultSync.SKIP)
            return false;
        if (workspaceVaultSyncConfig === common_all_1.DVaultSync.SYNC)
            return true;
        if (workspaceVaultSyncConfig === common_all_1.DVaultSync.NO_COMMIT &&
            command === "commit")
            return false;
        if (workspaceVaultSyncConfig === common_all_1.DVaultSync.NO_PUSH && command === "push")
            return false;
        return true;
    }
    static async generateCommitMessage({ vaults, engine, }) {
        const { version } = (await engine.info()).data || { version: "unknown" };
        return [
            "Dendron workspace sync",
            "",
            "## Synced vaults:",
            ...vaults.map((vault) => `- ${common_all_1.VaultUtils.getName(vault)}`),
            "",
            `Dendron version: ${version}`,
            `Hostname: ${os_1.default.hostname()}`,
        ].join("\n");
    }
    async commitAndAddAll({ engine, }) {
        const allReposVaults = await this.getAllReposVaults();
        const out = await Promise.all(lodash_1.default.map([...allReposVaults.entries()], async (rootVaults) => {
            const [repo, vaults] = rootVaults;
            const git = new git_1.Git({ localUrl: repo });
            if (!(await this.shouldVaultsSync("commit", rootVaults)))
                return { repo, vaults, status: workspaceServiceInterface_1.SyncActionStatus.SKIP_CONFIG };
            if (await git.hasMergeConflicts())
                return { repo, vaults, status: workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT };
            if (await git.hasRebaseInProgress()) {
                // try to resume the rebase first, since we know there are no merge conflicts
                return {
                    repo,
                    vaults,
                    status: workspaceServiceInterface_1.SyncActionStatus.REBASE_IN_PROGRESS,
                };
            }
            if (!(await git.hasChanges()))
                return { repo, vaults, status: workspaceServiceInterface_1.SyncActionStatus.NO_CHANGES };
            try {
                await git.addAll();
                await git.commit({
                    msg: await WorkspaceService.generateCommitMessage({
                        vaults,
                        engine,
                    }),
                });
                return { repo, vaults, status: workspaceServiceInterface_1.SyncActionStatus.DONE };
            }
            catch (err) {
                const stderr = err.stderr ? `: ${err.stderr}` : "";
                throw new common_all_1.DendronError({
                    message: `error adding and committing vault${stderr}`,
                    payload: { err, repoPath: repo },
                });
            }
        }));
        return out;
    }
    /**
     * Initialize all remote vaults
     * @param opts
     * @returns
     */
    async initialize(opts) {
        const { onSyncVaultsProgress, onSyncVaultsEnd } = lodash_1.default.defaults(opts, {
            onSyncVaultsProgress: () => { },
            onSyncVaultsEnd: () => { },
        });
        const initializeRemoteVaults = common_all_1.ConfigUtils.getWorkspace(this.config).enableRemoteVaultInit;
        if (initializeRemoteVaults) {
            const { didClone } = await this.syncVaults({
                config: this.config,
                progressIndicator: onSyncVaultsProgress,
            });
            if (didClone) {
                onSyncVaultsEnd();
            }
            return didClone;
        }
        return false;
    }
    /**
     * Remove vaults. Currently doesn't delete any files.
     * @param param0
     */
    async removeVault(opts) {
        const config = this.config;
        const { vault, updateConfig, updateWorkspace } = lodash_1.default.defaults(opts, {
            updateConfig: true,
            updateWorkspace: false,
        });
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        const vaultsAfterReject = lodash_1.default.reject(vaults, (ent) => {
            const checks = [
                common_all_1.VaultUtils.getRelPath(ent) === common_all_1.VaultUtils.getRelPath(vault),
            ];
            if (vault.workspace) {
                checks.push(ent.workspace === vault.workspace);
            }
            return lodash_1.default.every(checks);
        });
        common_all_1.ConfigUtils.setVaults(config, vaultsAfterReject);
        const workspaces = common_all_1.ConfigUtils.getWorkspace(config).workspaces;
        if (vault.workspace && workspaces) {
            const vaultWorkspace = lodash_1.default.find(common_all_1.ConfigUtils.getVaults(config), {
                workspace: vault.workspace,
            });
            if (lodash_1.default.isUndefined(vaultWorkspace)) {
                delete workspaces[vault.workspace];
                common_all_1.ConfigUtils.setWorkspaceProp(config, "workspaces", workspaces);
            }
        }
        if (config.site.duplicateNoteBehavior &&
            lodash_1.default.isArray(config.site.duplicateNoteBehavior.payload)) {
            const vaults = common_all_1.ConfigUtils.getVaults(config);
            if (vaults.length === 1) {
                // if there is only one vault left, remove duplicateNoteBehavior setting
                config.site = lodash_1.default.omit(config.site, ["duplicateNoteBehavior"]);
            }
            else {
                // otherwise pull the removed vault from payload
                config.site.duplicateNoteBehavior.payload = lodash_1.default.pull(config.site.duplicateNoteBehavior.payload, vault.fsPath);
            }
        }
        if (updateConfig) {
            await this.setConfig(config);
        }
        if (updateWorkspace) {
            const wsPath = path_1.default.join(this.wsRoot, DENDRON_WS_NAME);
            let settings = (await (0, common_server_1.readJSONWithComments)(wsPath));
            const folders = lodash_1.default.reject(settings.folders, (ent) => ent.path === common_all_1.VaultUtils.getRelPath(vault));
            settings = (0, common_server_1.assignJSONWithComment)({ folders }, settings);
            if (opts.onUpdatingWorkspace) {
                opts.onUpdatingWorkspace();
            }
            (0, common_server_1.writeJSONWithComments)(wsPath, settings);
            if (opts.onUpdatedWorkspace) {
                await opts.onUpdatedWorkspace();
            }
        }
        else {
            // Run the hooks even if not updating the workspace file (native workspace), because other code depends on it.
            if (opts.onUpdatingWorkspace) {
                opts.onUpdatingWorkspace();
            }
            if (opts.onUpdatedWorkspace) {
                await opts.onUpdatedWorkspace();
            }
        }
    }
    createConfig() {
        // This line actually does something: it will create a config if one doesn't exist.
        // eslint-disable-next-line no-unused-expressions
        this.config;
    }
    /**
     * Initialize workspace with specified vaults
     * Files and folders created:
     * wsRoot/
     * - .gitignore
     * - dendron.yml
     * - {vaults}/
     *   - root.md
     *   - root.schema.yml
     *
     * NOTE: dendron.yml only gets created if you are adding a workspace...
     * @param opts
     */
    static async createWorkspace(opts) {
        const { wsRoot, vaults } = opts;
        const ws = new WorkspaceService({ wsRoot });
        fs_extra_1.default.ensureDirSync(wsRoot);
        // this creates `dendron.yml`
        ws.createConfig();
        // add gitignore
        const gitIgnore = path_1.default.join(wsRoot, ".gitignore");
        fs_extra_1.default.writeFileSync(gitIgnore, ["node_modules", ".dendron.*", "build", "seeds", "\n"].join("\n"), { encoding: "utf8" });
        if (opts.createCodeWorkspace) {
            vscode_1.WorkspaceConfig.write(wsRoot, vaults);
        }
        await lodash_1.default.reduce(vaults, async (prev, vault) => {
            await prev;
            await ws.createVault({ vault });
            return;
        }, Promise.resolve());
        // check if this is the first workspace created
        if (lodash_1.default.isUndefined(metadata_1.MetadataService.instance().getMeta().firstWsInitialize)) {
            metadata_1.MetadataService.instance().setFirstWsInitialize();
        }
        return ws;
    }
    static async createFromConfig(opts) {
        const { wsRoot } = opts;
        const config = config_1.DConfig.getOrCreate(wsRoot);
        const ws = new WorkspaceService({ wsRoot });
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        await Promise.all(vaults.map(async (vault) => {
            return ws.cloneVaultWithAccessToken({ vault });
        }));
        ws.dispose();
        return;
    }
    async addVaultToCodeWorkspace(vault) {
        const wsRoot = this.wsRoot;
        // workspace file
        const wsPath = vscode_1.WorkspaceConfig.workspaceFile(wsRoot);
        let out = (await (0, common_server_1.readJSONWithComments)(wsPath));
        if (!lodash_1.default.find(out.folders, (ent) => ent.path === common_all_1.VaultUtils.getRelPath(vault))) {
            const vault2Folder = common_all_1.VaultUtils.toWorkspaceFolder(vault);
            const folders = [vault2Folder].concat(out.folders);
            out = (0, common_server_1.assignJSONWithComment)({ folders }, out);
            (0, common_server_1.writeJSONWithComments)(wsPath, out);
        }
        return;
    }
    /**
     * Used in createFromConfig
     */
    async cloneVaultWithAccessToken(opts) {
        const { vault } = opts;
        if (!vault.remote || vault.remote.type !== "git") {
            throw new common_all_1.DendronError({ message: "cloning non-git vault" });
        }
        let remotePath = vault.remote.url;
        const localPath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        const git = (0, common_server_1.simpleGit)();
        this.logger.info({ msg: "cloning", remotePath, localPath });
        const accessToken = process.env["GITHUB_ACCESS_TOKEN"];
        if (accessToken) {
            this.logger.info({ msg: "using access token" });
            remotePath = common_server_1.GitUtils.getGithubAccessTokenUrl({
                remotePath,
                accessToken,
            });
        }
        await git.clone(remotePath, localPath);
    }
    /**
     * Clone a vault from a remote source
     * @param opts.vault vaults field
     * @param opts.urlTransformer modify the git url
     */
    async cloneVault(opts) {
        const { vault, urlTransformer } = lodash_1.default.defaults(opts, {
            urlTransformer: lodash_1.default.identity,
        });
        const wsRoot = this.wsRoot;
        if (!vault.remote || vault.remote.type !== "git") {
            throw new common_all_1.DendronError({ message: "cloning non-git vault" });
        }
        const repoPath = (0, common_server_1.vault2Path)({ wsRoot, vault });
        this.logger.info({ msg: "cloning", repoPath });
        const git = (0, common_server_1.simpleGit)({ baseDir: wsRoot });
        await git.clone(urlTransformer(vault.remote.url), repoPath);
        return repoPath;
    }
    async cloneWorkspace(opts) {
        const { wsRoot, urlTransformer, workspace, wsName } = lodash_1.default.defaults(opts, {
            urlTransformer: lodash_1.default.identity,
        });
        const repoPath = path_1.default.join(wsRoot, wsName);
        const git = (0, common_server_1.simpleGit)({ baseDir: wsRoot });
        await git.clone(urlTransformer(workspace.remote.url), wsName);
        return repoPath;
    }
    async getVaultRepo(vault) {
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot: this.wsRoot });
        return common_server_1.GitUtils.getGitRoot(vpath);
    }
    async getAllReposVaults() {
        const reposVaults = new Map();
        const vaults = common_all_1.ConfigUtils.getVaults(this.config);
        await Promise.all(vaults.map(async (vault) => {
            const repo = await this.getVaultRepo(vault);
            if (lodash_1.default.isUndefined(repo))
                return;
            const vaultsForRepo = reposVaults.get(repo) || [];
            vaultsForRepo.push(vault);
            reposVaults.set(repo, vaultsForRepo);
        }));
        return reposVaults;
    }
    async getAllRepos() {
        return [...(await this.getAllReposVaults()).keys()];
    }
    /**
     * Check if a path belongs to a workspace
     @deprecated - use {@link WorkspaceUtils.isPathInWorkspace}
     */
    isPathInWorkspace(fpath) {
        const vaults = common_all_1.ConfigUtils.getVaults(this.config);
        const wsRoot = this.wsRoot;
        return utils_2.WorkspaceUtils.isPathInWorkspace({ fpath, vaults, wsRoot });
    }
    async pullVault(opts) {
        const { vault } = lodash_1.default.defaults(opts, {
            urlTransformer: lodash_1.default.identity,
        });
        const wsRoot = this.wsRoot;
        if (!vault.remote || vault.remote.type !== "git") {
            throw new common_all_1.DendronError({ message: "pulling non-git vault" });
        }
        const repoPath = (0, common_server_1.vault2Path)({ wsRoot, vault });
        this.logger.info({ msg: "pulling ", repoPath });
        const git = (0, common_server_1.simpleGit)({ baseDir: repoPath });
        await git.pull();
        return repoPath;
    }
    /** Returns the list of vaults that were attempted to be pulled, even if there was nothing to pull. */
    async pullVaults() {
        const ctx = "pullVaults";
        const allReposVaults = await this.getAllReposVaults();
        const out = await Promise.all(lodash_1.default.map([...allReposVaults.entries()], async (rootVaults) => {
            const [repo, vaults] = rootVaults;
            const makeResult = (status) => {
                return {
                    repo,
                    vaults,
                    status,
                };
            };
            const git = new git_1.Git({ localUrl: repo });
            // It's impossible to pull if there is no remote or upstream
            if (!(await git.hasRemote()))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.NO_REMOTE);
            // If there's a merge conflict, then we can't continue
            if (await git.hasMergeConflicts())
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT);
            // A rebase in progress means there's no upstream, so it needs to come first.
            if (await git.hasRebaseInProgress()) {
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.REBASE_IN_PROGRESS);
            }
            if (lodash_1.default.isUndefined(await git.getUpstream()))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.NO_UPSTREAM);
            if (!(await git.hasAccessToRemote()))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.BAD_REMOTE);
            // If the vault was configured not to pull, then skip it
            if (!(await this.shouldVaultsSync("pull", rootVaults)))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.SKIP_CONFIG);
            // If there are tracked changes, we need to stash them to pull
            let stashed;
            if (await git.hasChanges({ untrackedFiles: "no" })) {
                try {
                    stashed = await git.stashCreate();
                    this.logger.info({ ctx, vaults, repo, stashed });
                    // this shouldn't fail, but for safety's sake
                    if (lodash_1.default.isEmpty(stashed) || !git.isValidStashCommit(stashed)) {
                        throw new common_all_1.DendronError({
                            message: "unable to stash changes",
                            payload: { stashed },
                        });
                    }
                    // stash create doesn't change the working directory, so we need to get rid of the tracked changes
                    await git.reset("hard");
                }
                catch (err) {
                    this.logger.error({
                        ctx: "pullVaults",
                        vaults,
                        repo,
                        err,
                        stashed,
                    });
                    return makeResult(workspaceServiceInterface_1.SyncActionStatus.CANT_STASH);
                }
            }
            try {
                await git.pull();
                if (stashed) {
                    const restored = await git.stashApplyCommit(stashed);
                    stashed = undefined;
                    if (!restored)
                        return makeResult(workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT_AFTER_RESTORE);
                }
                // pull went well, everything is in order. The finally block will restore any stashed changes.
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.DONE);
            }
            catch (err) {
                // Failed to pull, let's see why:
                if ((await git.hasMergeConflicts()) ||
                    (await git.hasRebaseInProgress())) {
                    if (stashed) {
                        // There was a merge conflict during the pull, and we have stashed changes.
                        // We can't apply the stash in this state, so we'd lose the users changes.
                        // Abort the rebase.
                        await git.rebaseAbort();
                        return makeResult(workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT_LOSES_CHANGES);
                    }
                    else {
                        return makeResult(workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT_AFTER_PULL);
                    }
                }
                else {
                    const stderr = (err === null || err === void 0 ? void 0 : err.stderr) || "";
                    const vaultNames = vaults
                        .map((vault) => common_all_1.VaultUtils.getName(vault))
                        .join(",");
                    throw new common_all_1.DendronError({
                        message: `Failed to pull ${vaultNames}: ${stderr}`,
                        payload: {
                            err,
                            vaults,
                            repo,
                            stashed,
                        },
                    });
                }
            }
            finally {
                // Try to restore changes if we stashed them, even if there were errors. We don't want to lose the users changes.
                if (stashed) {
                    git.stashApplyCommit(stashed);
                }
            }
        }));
        return out;
    }
    /** Returns the list of vaults that were attempted to be pushed, even if there was nothing to push. */
    async pushVaults() {
        const allReposVaults = await this.getAllReposVaults();
        const out = await Promise.all(lodash_1.default.map([...allReposVaults.entries()], async (rootVaults) => {
            const [repo, vaults] = rootVaults;
            const git = new git_1.Git({ localUrl: repo });
            const makeResult = (status) => {
                return {
                    repo,
                    vaults,
                    status,
                };
            };
            if (!(await this.shouldVaultsSync("push", rootVaults)))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.SKIP_CONFIG);
            if (!(await git.hasRemote()))
                return { repo, vaults, status: workspaceServiceInterface_1.SyncActionStatus.NO_REMOTE };
            // if there's a rebase in progress then there's no upstream, so it needs to come first
            if (await git.hasMergeConflicts()) {
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.MERGE_CONFLICT);
            }
            if (await git.hasRebaseInProgress()) {
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.REBASE_IN_PROGRESS);
            }
            const upstream = await git.getUpstream();
            if (lodash_1.default.isUndefined(upstream))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.NO_UPSTREAM);
            if (!(await git.hasAccessToRemote()))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.BAD_REMOTE);
            if (!(await git.hasPushableChanges(upstream)))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.NO_CHANGES);
            if (!(await git.hasPushableRemote()))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.UNPULLED_CHANGES);
            if (!lodash_1.default.every(lodash_1.default.map(vaults, this.user.canPushVault)))
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.NOT_PERMITTED);
            try {
                await git.push();
                return makeResult(workspaceServiceInterface_1.SyncActionStatus.DONE);
            }
            catch (err) {
                const stderr = err.stderr ? `: ${err.stderr}` : "";
                throw new common_all_1.DendronError({
                    message: `error pushing vault${stderr}`,
                    payload: { err, repoPath: repo },
                });
            }
        }));
        return out;
    }
    /**
     * Remove all vault caches in workspace
     */
    async removeVaultCaches() {
        const vaults = common_all_1.ConfigUtils.getVaults(this.config);
        await Promise.all(vaults.map((vault) => {
            return (0, utils_1.removeCache)((0, common_server_1.vault2Path)({ wsRoot: this.wsRoot, vault }));
        }));
    }
    /**
     * See if there's anythign we need to change with the configuration
     */
    async runMigrationsIfNecessary({ forceUpgrade, workspaceInstallStatus, currentVersion, previousVersion, dendronConfig, wsConfig, }) {
        let changes = [];
        if (migrations_1.MigrationService.shouldRunMigration({
            force: forceUpgrade,
            workspaceInstallStatus,
        })) {
            changes = await migrations_1.MigrationService.applyMigrationRules({
                currentVersion,
                previousVersion,
                dendronConfig,
                wsConfig,
                wsService: this,
                logger: this.logger,
            });
            // if changes were made, use updated changes in subsequent configuration
            if (!lodash_1.default.isEmpty(changes)) {
                const { data } = lodash_1.default.last(changes);
                dendronConfig = data.dendronConfig;
            }
        }
        return changes;
    }
    /**
     * Check major version of configuration.
     * Because Dendron workspace relies on major version to be the same, we force a migration if that's not
     * the case
     */
    async runConfigMigrationIfNecessary({ currentVersion, dendronConfig, }) {
        let changes = [];
        if (dendronConfig.version !== common_all_1.CURRENT_CONFIG_VERSION) {
            // we are on a legacy config.
            // NOTE: this migration will create a `migration-config` backup file in the user's home directory
            changes = await migrations_1.MigrationService.applyMigrationRules({
                currentVersion,
                previousVersion: "0.70.0",
                dendronConfig,
                wsService: this,
                logger: this.logger,
                migrations: [migrations_1.CONFIG_MIGRATIONS],
            });
            // if changes were made, use updated changes in subsequent configuration
            if (!lodash_1.default.isEmpty(changes)) {
                const { data } = lodash_1.default.last(changes);
                dendronConfig = data.dendronConfig;
            }
        }
        return changes;
    }
    /**
     * Make sure all vaults are present on file system
     * @param fetchAndPull for repositories that exist, should we also do a fetch? default: false
     * @param skipPrivate skip cloning and pulling of private vaults. default: false
     */
    async syncVaults(opts) {
        const ctx = "syncVaults";
        const { config, progressIndicator, urlTransformer, fetchAndPull } = lodash_1.default.defaults(opts, { fetchAndPull: false, skipPrivate: false });
        const { wsRoot } = this;
        const workspaces = common_all_1.ConfigUtils.getWorkspace(config).workspaces;
        // check workspaces
        const workspacePaths = (await Promise.all(lodash_1.default.map(workspaces, async (wsEntry, wsName) => {
            const wsPath = path_1.default.join(wsRoot, wsName);
            if (!fs_extra_1.default.existsSync(wsPath)) {
                return {
                    wsPath: await this.cloneWorkspace({
                        wsName,
                        workspace: wsEntry,
                        wsRoot,
                    }),
                    wsUrl: wsEntry.remote.url,
                };
            }
            return;
        }))).filter((ent) => !lodash_1.default.isUndefined(ent));
        // const seedService = new SeedService({wsRoot});
        // check seeds
        const seeds = common_all_1.ConfigUtils.getWorkspace(config).seeds;
        const seedResults = [];
        await Promise.all(lodash_1.default.map(seeds, async (entry, id) => {
            if (!(await seed_1.SeedUtils.exists({ id, wsRoot }))) {
                const resp = await this._seedService.info({ id });
                if (lodash_1.default.isUndefined(resp)) {
                    seedResults.push({
                        id,
                        status: workspaceServiceInterface_1.SyncActionStatus.ERROR,
                        data: new common_all_1.DendronError({
                            status: workspaceServiceInterface_1.SyncActionStatus.ERROR,
                            message: `seed ${id} does not exist in registry`,
                        }),
                    });
                    return;
                }
                const spath = await this._seedService.cloneSeed({
                    seed: resp,
                    branch: entry.branch,
                });
                seedResults.push({
                    id,
                    status: workspaceServiceInterface_1.SyncActionStatus.NEW,
                    data: { spath },
                });
            }
            return undefined;
        }));
        // clone all missing vaults
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        const emptyRemoteVaults = vaults.filter((vault) => !lodash_1.default.isUndefined(vault.remote) &&
            !fs_extra_1.default.existsSync((0, common_server_1.vault2Path)({ vault, wsRoot })));
        const didClone = !lodash_1.default.isEmpty(emptyRemoteVaults) ||
            !lodash_1.default.isEmpty(workspacePaths) ||
            !lodash_1.default.isUndefined(seedResults.find((ent) => ent.status === workspaceServiceInterface_1.SyncActionStatus.NEW));
        // if we added a workspace, we also add new vaults
        if (!lodash_1.default.isEmpty(workspacePaths)) {
            this.setConfig(config);
        }
        if (progressIndicator && didClone) {
            progressIndicator();
        }
        await Promise.all(emptyRemoteVaults.map(async (vault) => {
            return this.cloneVault({ vault, urlTransformer });
        }));
        if (fetchAndPull) {
            const vaults = common_all_1.ConfigUtils.getVaults(config);
            const vaultsToFetch = lodash_1.default.difference(vaults.filter((vault) => !lodash_1.default.isUndefined(vault.remote)), emptyRemoteVaults);
            this.logger.info({ ctx, msg: "fetching vaults", vaultsToFetch });
            await Promise.all(vaultsToFetch.map(async (vault) => {
                return this.pullVault({ vault });
            }));
        }
        return { didClone };
    }
    writePort(port) {
        const wsRoot = this.wsRoot;
        // dendron-cli can overwrite port file. anything that needs the port should connect to `portFilePathExtension`
        const portFilePath = utils_1.EngineUtils.getPortFilePathForWorkspace({ wsRoot });
        fs_extra_1.default.writeFileSync(portFilePath, lodash_1.default.toString(port), { encoding: "utf8" });
    }
    writeMeta(opts) {
        const { version } = opts;
        const fpath = (0, utils_1.getWSMetaFilePath)({ wsRoot: this.wsRoot });
        return (0, utils_1.writeWSMetaFile)({
            fpath,
            data: {
                version,
                activationTime: common_all_1.Time.now().toMillis(),
            },
        });
    }
}
exports.WorkspaceService = WorkspaceService;
//# sourceMappingURL=service.js.map