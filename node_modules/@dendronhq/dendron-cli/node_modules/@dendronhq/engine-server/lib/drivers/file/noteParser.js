"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteParser = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../utils");
const parseBase_1 = require("./parseBase");
/**
 * Get hierarchy of each file
 * @param fpaths
 * @returns
 */
function getFileMeta(fpaths) {
    const metaDict = {};
    lodash_1.default.forEach(fpaths, (fpath) => {
        const { name } = path_1.default.parse(fpath);
        const lvl = name.split(".").length;
        if (!lodash_1.default.has(metaDict, lvl)) {
            metaDict[lvl] = [];
        }
        metaDict[lvl].push({ prefix: name, fpath });
    });
    return metaDict;
}
class NoteParser extends parseBase_1.ParserBase {
    constructor(opts) {
        super(opts);
        this.opts = opts;
        this.cache = opts.cache;
    }
    async parseFiles(allPaths, vault) {
        const ctx = "parseFile";
        const fileMetaDict = getFileMeta(allPaths);
        const maxLvl = lodash_1.default.max(lodash_1.default.keys(fileMetaDict).map((e) => lodash_1.default.toInteger(e))) || 2;
        const notesByFname = {};
        const notesById = {};
        this.logger.info({ ctx, msg: "enter", vault });
        const cacheUpdates = {};
        const errors = [];
        // get root note
        if (lodash_1.default.isUndefined(fileMetaDict[1])) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.NO_ROOT_NOTE_FOUND,
            });
        }
        const rootFile = fileMetaDict[1].find((n) => n.fpath === "root.md");
        if (!rootFile) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.NO_ROOT_NOTE_FOUND,
            });
        }
        const rootProps = this.parseNoteProps({
            fileMeta: rootFile,
            addParent: false,
            vault,
        });
        const rootNote = rootProps.propsList[0];
        this.logger.info({ ctx, msg: "post:parseRootNote" });
        if (!rootProps.matchHash) {
            cacheUpdates[rootNote.fname] = (0, utils_1.createCacheEntry)({
                noteProps: rootNote,
                hash: rootProps.noteHash,
            });
        }
        notesByFname[rootNote.fname] = rootNote;
        notesById[rootNote.id] = rootNote;
        // get root of hiearchies
        let lvl = 2;
        let prevNodes = fileMetaDict[1]
            // don't count root node
            .filter((n) => n.fpath !== "root.md")
            .flatMap((ent) => {
            try {
                const out = this.parseNoteProps({
                    fileMeta: ent,
                    addParent: false,
                    vault,
                });
                const notes = out.propsList;
                if (!out.matchHash) {
                    cacheUpdates[notes[0].fname] = (0, utils_1.createCacheEntry)({
                        noteProps: notes[0],
                        hash: out.noteHash,
                    });
                }
                return notes;
            }
            catch (err) {
                if (!(err instanceof common_all_1.DendronError)) {
                    err = new common_all_1.DendronError({
                        message: `Failed to read ${ent.fpath} in ${vault.fsPath}`,
                        payload: err,
                    });
                }
                // A fatal error would kill the initialization
                err.severity = common_all_1.ERROR_SEVERITY.MINOR;
                errors.push(err);
                return undefined;
            }
        })
            .filter(common_all_1.isNotUndefined);
        prevNodes.forEach((ent) => {
            common_all_1.DNodeUtils.addChild(rootNote, ent);
            notesByFname[ent.fname] = ent;
            notesById[ent.id] = ent;
        });
        this.logger.info({ ctx, msg: "post:parseDomainNotes" });
        // get everything else
        while (lvl <= maxLvl) {
            const currNodes = (fileMetaDict[lvl] || [])
                .filter((ent) => {
                return !(0, common_server_1.globMatch)(["root.*"], ent.fpath);
            })
                // eslint-disable-next-line no-loop-func
                .flatMap((ent) => {
                try {
                    const resp = this.parseNoteProps({
                        fileMeta: ent,
                        parents: prevNodes,
                        notesByFname,
                        addParent: true,
                        vault,
                    });
                    const notes = resp.propsList;
                    // this indicates that the contents of the note was different
                    // then what was in the cache. need to update later ^cache-update
                    if (!resp.matchHash) {
                        cacheUpdates[notes[0].fname] = (0, utils_1.createCacheEntry)({
                            noteProps: notes[0],
                            hash: resp.noteHash,
                        });
                    }
                    // need to be inside this loop
                    // deal with `src/__tests__/enginev2.spec.ts`, with stubs/ test case
                    notes.forEach((ent) => {
                        notesByFname[ent.fname] = ent;
                        notesById[ent.id] = ent;
                    });
                    return notes;
                }
                catch (err) {
                    if (!(err instanceof common_all_1.DendronError)) {
                        err = new common_all_1.DendronError({
                            message: `Failed to read ${ent.fpath} in ${vault.fsPath}`,
                            payload: err,
                        });
                    }
                    // A fatal error would kill the initialization
                    err.severity = common_all_1.ERROR_SEVERITY.MINOR;
                    errors.push(err);
                    return undefined;
                }
            })
                .filter(common_all_1.isNotUndefined);
            lvl += 1;
            prevNodes = currNodes;
        }
        this.logger.info({ ctx, msg: "post:parseAllNotes" });
        // add schemas
        const out = lodash_1.default.values(notesByFname);
        const domains = rootNote.children.map((ent) => notesById[ent]);
        const schemas = this.opts.store.schemas;
        await Promise.all(domains.map(async (d) => {
            return common_all_1.SchemaUtils.matchDomain(d, notesById, schemas);
        }));
        this.logger.info({ ctx, msg: "post:matchSchemas" });
        return { notes: out, cacheUpdates, errors };
    }
    /**
     *
     * @param opts
     * @returns List of all notes added. If a note has no direct parents, stub notes are added instead
     */
    parseNoteProps(opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            addParent: true,
            createStubs: true,
            notesByFname: {},
            parents: [],
        });
        const { fileMeta, parents, notesByFname, vault } = cleanOpts;
        const ctx = "parseNoteProps";
        this.logger.debug({ ctx, msg: "enter", fileMeta });
        const wsRoot = this.opts.store.wsRoot;
        const vpath = (0, common_server_1.vault2Path)({ vault, wsRoot });
        let out = [];
        let noteProps;
        let noteHash;
        let matchHash;
        // get note props
        try {
            // noteProps = file2Note(path.join(vpath, fileMeta.fpath), vault);
            ({
                note: noteProps,
                noteHash,
                matchHash,
            } = (0, common_server_1.file2NoteWithCache)({
                fpath: path_1.default.join(vpath, fileMeta.fpath),
                vault,
                cache: this.cache,
            }));
        }
        catch (_err) {
            const err = common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.BAD_PARSE_FOR_NOTE,
                severity: common_all_1.ERROR_SEVERITY.MINOR,
                payload: { fname: fileMeta.fpath, error: (0, common_all_1.stringifyError)(_err) },
                message: `${fileMeta.fpath} could not be parsed`,
            });
            this.logger.error({ ctx, err });
            throw err;
        }
        out.push(noteProps);
        // add parent
        if (cleanOpts.addParent) {
            const stubs = common_all_1.NoteUtils.addParent({
                note: noteProps,
                notesList: lodash_1.default.uniqBy(lodash_1.default.values(notesByFname).concat(parents), "id"),
                createStubs: cleanOpts.createStubs,
                wsRoot: this.opts.store.wsRoot,
            });
            out = out.concat(stubs);
        }
        return { propsList: out, noteHash, matchHash };
    }
}
exports.NoteParser = NoteParser;
//# sourceMappingURL=noteParser.js.map