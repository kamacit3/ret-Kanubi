"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.backlinks = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const site_1 = require("../../topics/site");
const unist_builder_1 = __importDefault(require("unist-builder"));
const types_1 = require("../types");
const utils_1 = require("../utils");
// Plugin that adds backlinks at the end of each page if they exist
const plugin = function () {
    const proc = this;
    function transformer(tree) {
        const root = tree;
        const { fname, vault, dest, insideNoteRef } = utils_1.MDUtilsV4.getDendronData(proc);
        if (!fname || insideNoteRef) {
            return;
        }
        if (dest !== types_1.DendronASTDest.HTML) {
            return;
        }
        const { engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
        const note = common_all_1.NoteUtils.getNoteByFnameV5({
            fname,
            notes: engine.notes,
            vault: vault,
            wsRoot: engine.wsRoot,
        });
        if (lodash_1.default.isUndefined(note)) {
            return;
        }
        const backlinks = lodash_1.default.uniqBy(((note === null || note === void 0 ? void 0 : note.links) || []).filter((ent) => ent.type === "backlink"), (ent) => ent.from.fname + (ent.from.vaultName || ""));
        const backlinksToPublish = lodash_1.default.filter(backlinks, (backlink) => {
            const vaultName = backlink.from.vaultName;
            const vault = common_all_1.VaultUtils.getVaultByName({
                vaults: engine.vaults,
                vname: vaultName,
            });
            const note = common_all_1.NoteUtils.getNoteByFnameV5({
                fname: backlink.from.fname,
                notes: engine.notes,
                vault,
                wsRoot: engine.wsRoot,
            });
            if (!note) {
                return false;
            }
            const out = site_1.SiteUtils.canPublish({
                note,
                engine,
                config: engine.config,
            });
            return out;
        });
        if (!lodash_1.default.isEmpty(backlinksToPublish)) {
            root.children.push({
                type: "thematicBreak",
            });
            root.children.push((0, unist_builder_1.default)("strong", [{ type: "text", value: "Backlinks" }]));
            root.children.push((0, mdast_builder_1.list)("unordered", backlinksToPublish.map((mdLink) => {
                return (0, mdast_builder_1.listItem)((0, mdast_builder_1.paragraph)({
                    type: types_1.DendronASTTypes.WIKI_LINK,
                    value: mdLink.from.fname,
                    data: {
                        alias: common_all_1.NoteUtils.getNoteOrThrow({
                            fname: mdLink.from.fname,
                            notes: engine.notes,
                            vault: common_all_1.VaultUtils.getVaultByName({
                                vaults: engine.vaults,
                                vname: mdLink.from.vaultName,
                            }),
                            wsRoot: engine.wsRoot,
                        }).title +
                            (engine.vaults.length > 1
                                ? ` (${mdLink.from.vaultName})`
                                : ""),
                        vaultName: mdLink.from.vaultName,
                    },
                    children: [],
                }));
            })));
        }
        // end transformer
    }
    return transformer;
};
exports.backlinks = plugin;
//# sourceMappingURL=backlinks.js.map