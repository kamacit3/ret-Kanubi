"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DoctorService = exports.DoctorActionsEnum = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const async_throttle_1 = __importDefault(require("@jcoreio/async-throttle"));
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../markdown/remark/utils");
const types_1 = require("../markdown/types");
const utils_2 = require("../markdown/utils");
var DoctorActionsEnum;
(function (DoctorActionsEnum) {
    DoctorActionsEnum["FIX_FRONTMATTER"] = "fixFrontmatter";
    DoctorActionsEnum["H1_TO_TITLE"] = "h1ToTitle";
    DoctorActionsEnum["HI_TO_H2"] = "h1ToH2";
    DoctorActionsEnum["REMOVE_STUBS"] = "removeStubs";
    DoctorActionsEnum["CREATE_MISSING_LINKED_NOTES"] = "createMissingLinkedNotes";
    DoctorActionsEnum["REGENERATE_NOTE_ID"] = "regenerateNoteId";
    DoctorActionsEnum["FIND_BROKEN_LINKS"] = "findBrokenLinks";
})(DoctorActionsEnum = exports.DoctorActionsEnum || (exports.DoctorActionsEnum = {}));
class DoctorService {
    constructor() {
        this.L = (0, common_server_1.createLogger)("DoctorService");
    }
    findBrokenLinks(note, notes, engine) {
        const { wsRoot, vaults } = engine;
        const links = note.links;
        if (lodash_1.default.isEmpty(links)) {
            return [];
        }
        const out = lodash_1.default.filter(links, (link) => {
            if (link.type !== "wiki") {
                return false;
            }
            const hasVaultPrefix = utils_1.LinkUtils.hasVaultPrefix(link);
            let vault;
            if (hasVaultPrefix) {
                vault = common_all_1.VaultUtils.getVaultByName({
                    vaults,
                    vname: link.to.vaultName,
                });
                if (!vault)
                    return false;
            }
            const isMultiVault = vaults.length > 1;
            const noteExists = common_all_1.NoteUtils.getNoteByFnameV5({
                fname: link.to.fname,
                vault: hasVaultPrefix ? vault : note.vault,
                notes,
                wsRoot,
            });
            if (hasVaultPrefix) {
                // true: link w/ vault prefix that points to nothing. (candidate for sure)
                // false: link w/ vault prefix that points to a note. (valid link)
                return !noteExists;
            }
            if (!noteExists) {
                // true: no vault prefix and single vault. (candidate for sure)
                // false: no vault prefix and multi vault. (ambiguous)
                return !isMultiVault;
            }
            // (valid link)
            return false;
        });
        return out;
    }
    getBrokenLinkDestinations(notes, engine) {
        const { vaults } = engine;
        let brokenWikiLinks = [];
        lodash_1.default.forEach(notes, (note) => {
            const links = note.links;
            if (lodash_1.default.isEmpty(links)) {
                return;
            }
            const brokenLinks = this.findBrokenLinks(note, notes, engine);
            brokenWikiLinks = brokenWikiLinks.concat(brokenLinks);
            return true;
        });
        const uniqueCandidates = lodash_1.default.map(lodash_1.default.uniqBy(brokenWikiLinks, "to.fname"), (link) => {
            var _a;
            const destVault = ((_a = link.to) === null || _a === void 0 ? void 0 : _a.vaultName)
                ? common_all_1.VaultUtils.getVaultByName({ vaults, vname: link.to.vaultName })
                : common_all_1.VaultUtils.getVaultByName({ vaults, vname: link.from.vaultName });
            return common_all_1.NoteUtils.create({
                fname: link.to.fname,
                vault: destVault,
            });
        });
        return uniqueCandidates;
    }
    async executeDoctorActions(opts) {
        const { action, engine, query, candidates, limit, dryRun, exit } = lodash_1.default.defaults(opts, {
            limit: 99999,
            exit: true,
        });
        let notes;
        if (lodash_1.default.isUndefined(candidates)) {
            notes = query
                ? engine.queryNotesSync({ qs: query, originalQS: query }).data
                : lodash_1.default.values(engine.notes);
        }
        else {
            notes = candidates;
        }
        notes = notes.filter((n) => !n.stub);
        // this.L.info({ msg: "prep doctor", numResults: notes.length });
        let numChanges = 0;
        let resp;
        const engineWrite = dryRun
            ? () => { }
            : (0, async_throttle_1.default)(lodash_1.default.bind(engine.writeNote, engine), 300, {
                // @ts-ignore
                leading: true,
            });
        const engineDelete = dryRun
            ? () => { }
            : (0, async_throttle_1.default)(lodash_1.default.bind(engine.deleteNote, engine), 300, {
                // @ts-ignore
                leading: true,
            });
        const engineGetNoteByPath = dryRun
            ? () => { }
            : (0, async_throttle_1.default)(lodash_1.default.bind(engine.getNoteByPath, engine), 300, {
                // @ts-ignore
                leading: true,
            });
        let doctorAction;
        switch (action) {
            case DoctorActionsEnum.FIX_FRONTMATTER: {
                console.log("the CLI currently doesn't support this action. please run this using the plugin");
                return { exit };
            }
            // eslint-disable-next-line no-fallthrough
            case DoctorActionsEnum.H1_TO_TITLE: {
                doctorAction = async (note) => {
                    const changes = [];
                    const proc = utils_2.MDUtilsV4.procFull({
                        dest: types_1.DendronASTDest.MD_DENDRON,
                        engine,
                        fname: note.fname,
                        vault: note.vault,
                    });
                    const newBody = await proc()
                        .use(utils_1.RemarkUtils.h1ToTitle(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActionsEnum.HI_TO_H2: {
                doctorAction = async (note) => {
                    const changes = [];
                    const proc = utils_2.MDUtilsV4.procFull({
                        dest: types_1.DendronASTDest.MD_DENDRON,
                        engine,
                        fname: note.fname,
                        vault: note.vault,
                    });
                    const newBody = await proc()
                        .use(utils_1.RemarkUtils.h1ToH2(note, changes))
                        .process(note.body);
                    note.body = newBody.toString();
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineWrite(note, { updateExisting: true });
                        this.L.info({ msg: `changes ${note.fname}`, changes });
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActionsEnum.REMOVE_STUBS: {
                doctorAction = async (note) => {
                    const changes = [];
                    if (lodash_1.default.trim(note.body) === "") {
                        changes.push({
                            status: "delete",
                            note,
                        });
                    }
                    if (!lodash_1.default.isEmpty(changes)) {
                        await engineDelete(note);
                        const vname = common_all_1.VaultUtils.getName(note.vault);
                        this.L.info(`doctor ${DoctorActionsEnum.REMOVE_STUBS} ${note.fname} ${vname}`);
                        numChanges += 1;
                        return;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            case DoctorActionsEnum.CREATE_MISSING_LINKED_NOTES: {
                notes = this.getBrokenLinkDestinations(notes, engine);
                doctorAction = async (note) => {
                    await engineGetNoteByPath({
                        npath: note.fname,
                        createIfNew: true,
                        vault: note.vault,
                    });
                    numChanges += 1;
                };
                break;
            }
            case DoctorActionsEnum.REGENERATE_NOTE_ID: {
                doctorAction = async (note) => {
                    if (note.id === "root")
                        return; // Root notes are special, preserve them
                    note.id = (0, common_all_1.genUUID)();
                    await engine.writeNote(note, {
                        runHooks: false,
                        updateExisting: true,
                    });
                    numChanges += 1;
                };
                break;
            }
            case DoctorActionsEnum.FIND_BROKEN_LINKS: {
                resp = [];
                doctorAction = async (note) => {
                    const brokenLinks = this.findBrokenLinks(note, notes, engine);
                    if (brokenLinks.length > 0) {
                        resp.push({
                            file: note.fname,
                            vault: common_all_1.VaultUtils.getName(note.vault),
                            links: brokenLinks.map((link) => {
                                var _a, _b;
                                return {
                                    value: link.value,
                                    line: (_a = link.position) === null || _a === void 0 ? void 0 : _a.start.line,
                                    column: (_b = link.position) === null || _b === void 0 ? void 0 : _b.start.column,
                                };
                            }),
                        });
                        return brokenLinks;
                    }
                    else {
                        return;
                    }
                };
                break;
            }
            default:
                throw new common_all_1.DendronError({
                    message: "Unexpected Doctor action. If this is something Dendron should support, please create an issue on our Github repository.",
                });
        }
        await lodash_1.default.reduce(notes, async (accInner, note) => {
            await accInner;
            if (numChanges >= limit) {
                return;
            }
            this.L.debug({ msg: `processing ${note.fname}` });
            return doctorAction(note);
        }, Promise.resolve());
        this.L.info({ msg: "doctor done", numChanges });
        if (action === DoctorActionsEnum.FIND_BROKEN_LINKS && !opts.quiet) {
            console.log(JSON.stringify({ brokenLinks: resp }, null, "  "));
        }
        return { exit, resp };
    }
}
exports.DoctorService = DoctorService;
//# sourceMappingURL=service.js.map