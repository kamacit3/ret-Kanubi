"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NoteCLICommand = exports.NoteCommands = exports.NoteCLIOutput = void 0;
const common_all_1 = require("@dendronhq/common-all");
const pods_core_1 = require("@dendronhq/pods-core");
const lodash_1 = __importDefault(require("lodash"));
const base_1 = require("./base");
const utils_1 = require("./utils");
var NoteCLIOutput;
(function (NoteCLIOutput) {
    NoteCLIOutput["JSON"] = "json";
    NoteCLIOutput["MARKDOWN_GFM"] = "md_gfm";
    NoteCLIOutput["MARKDOWN_DENDRON"] = "md_dendron";
})(NoteCLIOutput = exports.NoteCLIOutput || (exports.NoteCLIOutput = {}));
var NoteCommands;
(function (NoteCommands) {
    NoteCommands["LOOKUP"] = "lookup";
    NoteCommands["DELETE"] = "delete";
})(NoteCommands = exports.NoteCommands || (exports.NoteCommands = {}));
function checkQueryAndVault(opts) {
    const vaults = opts.engine.vaults;
    let vault;
    if (!opts.query) {
        throw Error("no query found");
    }
    if (lodash_1.default.size(opts.engine.vaults) > 1 && !opts.vault) {
        throw Error("need to specify vault");
    }
    else {
        vault = opts.vault
            ? common_all_1.VaultUtils.getVaultByNameOrThrow({ vaults, vname: opts.vault })
            : vaults[0];
    }
    return { query: opts.query, vault };
}
class NoteCLICommand extends base_1.CLICommand {
    constructor() {
        super({ name: "note <cmd>", desc: "note related commands" });
    }
    buildArgs(args) {
        super.buildArgs(args);
        (0, utils_1.setupEngineArgs)(args);
        args.positional("cmd", {
            describe: "a command to run",
            choices: Object.values(NoteCommands),
            type: "string",
        });
        args.option("query", {
            describe: "the query to run",
            type: "string",
        });
        args.option("output", {
            describe: "format to output in",
            type: "string",
            choices: Object.values(NoteCLIOutput),
            default: NoteCLIOutput.JSON,
        });
    }
    async enrichArgs(args) {
        this.addArgsToPayload({ cmd: args.cmd, output: args.output });
        const engineArgs = await (0, utils_1.setupEngine)(args);
        return { data: { ...args, ...engineArgs } };
    }
    async execute(opts) {
        var _a;
        const { cmd, engine, wsRoot, output } = opts;
        try {
            switch (cmd) {
                case NoteCommands.LOOKUP: {
                    const { query, vault } = checkQueryAndVault(opts);
                    const { data } = await engine.getNoteByPath({
                        npath: query,
                        createIfNew: true,
                        vault,
                    });
                    let payload;
                    switch (output) {
                        case NoteCLIOutput.JSON:
                            payload = JSON.stringify(data, null, 4);
                            break;
                        case NoteCLIOutput.MARKDOWN_DENDRON:
                            payload = common_all_1.NoteUtils.serialize(data === null || data === void 0 ? void 0 : data.note);
                            break;
                        case NoteCLIOutput.MARKDOWN_GFM:
                            payload = await new pods_core_1.MarkdownPublishPod().execute({
                                engine,
                                vaults: engine.vaults,
                                wsRoot,
                                config: {
                                    fname: (_a = data === null || data === void 0 ? void 0 : data.note) === null || _a === void 0 ? void 0 : _a.fname,
                                    vaultName: common_all_1.VaultUtils.getName(vault),
                                    dest: "stdout",
                                },
                            });
                            break;
                        case undefined:
                            throw new common_all_1.DendronError({
                                message: "Unknown output format requested",
                                payload: {
                                    ctx: "NoteCLICommand.execute",
                                    cmd,
                                    output,
                                },
                            });
                        default:
                            (0, common_all_1.assertUnreachable)(output);
                    }
                    this.print(payload);
                    return { data: { payload, rawData: data } };
                }
                case NoteCommands.DELETE: {
                    const { query, vault } = checkQueryAndVault(opts);
                    const note = common_all_1.NoteUtils.getNoteOrThrow({
                        fname: query,
                        notes: engine.notes,
                        vault,
                        wsRoot,
                    });
                    const resp = await engine.deleteNote(note.id);
                    this.print(`deleted ${note.fname}`);
                    return { data: { payload: note.fname, rawData: resp } };
                }
                default: {
                    throw Error("bad option");
                }
            }
        }
        finally {
            if (opts.server.close) {
                opts.server.close();
            }
        }
    }
}
exports.NoteCLICommand = NoteCLICommand;
//# sourceMappingURL=notes.js.map