import { StatusCodes } from "http-status-codes";
import { AxiosError } from "axios";
import { ERROR_SEVERITY, ERROR_STATUS } from "./constants";
declare type DendronErrorProps = {
    /**
     * Arbitrary payload
     */
    payload?: any;
    /**
     * See {@link ERROR_SEVERITY}
     */
    severity?: ERROR_SEVERITY;
    /**
     * @deprecated - should only used in DendronServerError
     * Optional HTTP status code for error
     */
    code?: StatusCodes;
    /**
     * @deprecated - should only used in DendronServerError
     * Custom status errors
     */
    status?: string;
    /**
     * Inner Error object
     */
    innerError?: Error;
} & Error;
declare type ServerErrorProps = {
    /**
     * Custom status errors
     */
    status?: string;
    /**
     * Optional HTTP status code for error
     */
    code?: StatusCodes;
};
export declare type IDendronError = DendronErrorProps;
export declare class DendronError extends Error implements IDendronError {
    status?: string;
    payload?: string;
    severity?: ERROR_SEVERITY;
    code?: number;
    innerError?: Error;
    static createPlainError(props: Omit<DendronErrorProps, "name">): DendronErrorProps;
    static createFromStatus({ status, ...rest }: {
        status: ERROR_STATUS;
    } & Partial<DendronErrorProps>): DendronError;
    constructor({ message, status, payload, severity, code, innerError, }: Omit<DendronErrorProps, "name">);
}
export declare class DendronCompositeError extends Error implements IDendronError {
    payload: DendronErrorProps[];
    message: string;
    severity?: ERROR_SEVERITY;
    constructor(errors: IDendronError[]);
}
export declare class DendronServerError extends DendronError implements IDendronError, ServerErrorProps {
    /**
    * Optional HTTP status code for error
    */
    code?: StatusCodes;
    /**
     * Custom status errors
     */
    status?: string;
}
export declare class IllegalOperationError extends DendronError {
}
export declare function stringifyError(err: Error): string;
export declare const error2PlainObject: (err: IDendronError) => DendronErrorProps;
export declare class ErrorMessages {
    static formatShouldNeverOccurMsg(description?: string): string;
}
/** Statically ensure that a code path is unreachable using a variable that has been exhaustively used.
 *
 * The use case for this function is that when using a switch or a chain of if/else if statements,
 * this function allows you to ensure that after all possibilities have been already checked, no further
 * possibilities remain. Importantly, this is done statically (i.e. during compilation), so if anyone
 * revises the code in a way that adds expands the possibilities, a compiler error will warn them that
 * they must revise this part of the code as well.
 *
 * An example of how this function may be used is below:
 *
 *     type Names = "bar" | "baz";
 *
 *     function foo(name: Names) {
 *       if (name === "bar") { ... }
 *       else if (name === "baz") { ... }
 *       else assertUnreachable(name);
 *     }
 *
 * Let's say someone changes the type Names to `type Names = "bar" | "baz" | "ham";`. Thanks to this
 * assertion, the compiler will warn them that this branch is now reachable, and something is wrong.
 *
 * @param x
 */
export declare function assertUnreachable(_never?: never): never;
/**
 * Helper function to raise invalid state
 */
export declare function assertInvalidState(msg: string): never;
/** Utility class for helping to correctly construct common errors. */
export declare class ErrorFactory {
    static createUnexpectedEventError({ event }: {
        event: any;
    }): DendronError;
    static createInvalidStateError({ message, }: {
        message: string;
    }): DendronError;
    /** Stringify that will not throw if it fails to stringify
     * (for example: due to circular references)  */
    private static safeStringify;
}
export declare class ErrorUtils {
    static isAxiosError(error: unknown): error is AxiosError;
    static isDendronError(error: unknown): error is DendronError;
}
export declare function isTSError(err: any): err is Error;
export {};
