/// <reference types="node" />
import GithubSlugger from "github-slugger";
import minimatch from "minimatch";
import querystring from "querystring";
import semver from "semver";
import { NoteProps, SEOProps, DVault, DHookDict } from "./types";
import { DendronCommandConfig, DendronWorkspaceConfig, IntermediateDendronConfig, JournalConfig, ScratchConfig, LookupConfig, StrictConfigV3, NoteLookupConfig } from "./types/intermediateConfigs";
/**
 * Dendron utilities
 */
export declare class DUtils {
    static minimatch: typeof minimatch;
    static semver: typeof semver;
    static querystring: typeof querystring;
    /**
     * Check if string is numeric
     * Credit to https://stackoverflow.com/questions/175739/built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
     * @param str
     * @returns
     */
    static isNumeric(str: string): boolean;
}
export declare const getSlugger: () => GithubSlugger;
/**
 * determine if given parameter is numeric
 * https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric/1830844#1830844
 * @param n
 * @returns boolean
 */
export declare const isNumeric: (n: any) => boolean;
export declare function isBlockAnchor(anchor?: string): boolean;
/** A type guard for things that are not undefined.
 *
 * This is equivalent to !_.isUndefined(), except that it provides a type guard
 * ensuring the parameter is not undefined. This is useful when filtering:
 *
 * function foo(list: (string | undefined)[]) {
 *   const stringsOnly = list.filter(isNotUndefined);
 * }
 *
 * This will give stringsOnly the type string[]. Without the type guard, it would have
 * received the type (string | undefined)[] despite the fact that we filtered out undefined.
 */
export declare function isNotUndefined<T>(t: T | undefined): t is T;
/** Given a string, return a random color as a HTML color code.
 *
 * The same string will always generate the same color, and different strings will get different random colors.
 */
export declare function randomColor(text: string): string;
/** Only some colors are recognized, other colors will be returned without being modified.
 *
 * Examples of recognized colors:
 * * #45AB35
 * * rgb(123, 23, 45)
 * * rgb(123 23 45)
 * * hsl(123, 23%, 45%)
 * * hsl(123 23% 45%)
 *
 * This function does not verify that the input colors are valid, but as long as a valid color is passed in
 * it will not generate an invalid color.
 *
 * @param color
 * @param translucency A number between 0 and 1, with 0 being fully transparent and 1 being fully opaque.
 * @returns
 */
export declare function makeColorTranslucent(color: string, translucency: number): string;
/** A map that automatically inserts a value provided by the factory when a missing key is looked up.
 *
 * Modeled after python's `defaultdict`.
 *
 * Mind that `get` may mutate the map, which may be unintuitive.
 *
 * Example usage:
 *
 * ```ts
 * const myMap = new DefaultMap<string, string[]>(() => []);
 * myMap.get("foo").push("bar");
 * ```
 */
export declare class DefaultMap<K, V> {
    private _internalMap;
    private _factory;
    constructor(factory: (key: K) => V);
    get(key: K): V;
    set(key: K, value: V): Map<K, V>;
    has(key: K): boolean;
    keys(): IterableIterator<K>;
    values(): IterableIterator<V>;
    entries(): IterableIterator<[K, V]>;
    delete(key: K): boolean;
    get size(): number;
}
export declare class TagUtils {
    /** Removes `oldTag` from the frontmatter tags of `note` and replaces it with `newTag`, if any. */
    static replaceTag({ note, oldTag, newTag, }: {
        note: NoteProps;
        oldTag: string;
        newTag?: string;
    }): void;
}
export declare class PublishUtils {
    static getSEOPropsFromConfig(config: IntermediateDendronConfig): Partial<SEOProps>;
    static getSEOPropsFromNote(note: NoteProps): SEOProps;
}
/** Makes a single property within a type optional.
 *
 * Example:
 * ```ts
 * function foo(note: Optional<NoteProps, "title">) {
 *   let title = note.title;
 *   if (title === undefined) title = "default title";
 *   // ...
 * }
 * ```
 */
export declare type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;
export declare class ConfigUtils {
    static usePrettyRef(config: IntermediateDendronConfig): boolean;
    static genDefaultConfig(): StrictConfigV3;
    static getProp<K extends keyof StrictConfigV3>(config: IntermediateDendronConfig, key: K): StrictConfigV3[K];
    static getCommands(config: IntermediateDendronConfig): DendronCommandConfig;
    static getWorkspace(config: IntermediateDendronConfig): DendronWorkspaceConfig;
    static getVaults(config: IntermediateDendronConfig): DVault[];
    static getHooks(config: IntermediateDendronConfig): DHookDict | undefined;
    static getJournal(config: IntermediateDendronConfig): JournalConfig;
    static getScratch(config: IntermediateDendronConfig): ScratchConfig;
    static getLookup(config: IntermediateDendronConfig): LookupConfig;
    static setProp<K extends keyof StrictConfigV3>(config: IntermediateDendronConfig, key: K, value: StrictConfigV3[K]): void;
    static setCommandsProp<K extends keyof DendronCommandConfig>(config: IntermediateDendronConfig, key: K, value: DendronCommandConfig[K]): void;
    static setWorkspaceProp<K extends keyof DendronWorkspaceConfig>(config: IntermediateDendronConfig, key: K, value: DendronWorkspaceConfig[K]): void;
    static setVaults(config: IntermediateDendronConfig, value: DVault[]): void;
    static setNoteLookupProps<K extends keyof NoteLookupConfig>(config: IntermediateDendronConfig, key: K, value: NoteLookupConfig[K]): void;
    static setJournalProps<K extends keyof JournalConfig>(config: IntermediateDendronConfig, key: K, value: JournalConfig[K]): void;
    static setScratchProps<K extends keyof ScratchConfig>(config: IntermediateDendronConfig, key: K, value: ScratchConfig[K]): void;
    static setHooks(config: IntermediateDendronConfig, value: DHookDict): void;
}
