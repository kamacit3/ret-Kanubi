"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaUtils = exports.NoteUtils = exports.DNodeUtils = void 0;
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importStar(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const path_1 = __importDefault(require("path"));
const title_1 = __importDefault(require("title"));
const vscode_uri_1 = require("vscode-uri");
const constants_1 = require("./constants");
const error_1 = require("./error");
const time_1 = require("./time");
const types_1 = require("./types");
const utils_1 = require("./utils");
const uuid_1 = require("./uuid");
const vault_1 = require("./vault");
/**
 * Utilities for dealing with nodes
 */
class DNodeUtils {
    static addChild(parent, child) {
        parent.children = Array.from(new Set(parent.children).add(child.id));
        child.parent = parent.id;
    }
    static create(opts) {
        const { id, type, desc, links, anchors, fname, updated, created, parent, children, body, data, contentHash, vault, } = lodash_1.default.defaults(opts, {
            updated: time_1.Time.now().toMillis(),
            created: time_1.Time.now().toMillis(),
            id: uuid_1.genUUID(),
            desc: "",
            links: [],
            anchors: {},
            children: [],
            parent: null,
            body: "",
            data: {},
            fname: null,
        });
        const title = opts.title || NoteUtils.genTitle(fname);
        const cleanProps = {
            id,
            title,
            vault,
            type,
            desc,
            links,
            anchors,
            fname,
            updated,
            created,
            parent,
            children,
            body,
            data,
            contentHash,
        };
        // don't include optional props
        const optionalProps = [
            "stub",
            "schema",
            "schemaStub",
            "custom",
            "color",
            "tags",
            "image",
        ];
        lodash_1.default.forEach(optionalProps, (op) => {
            if (opts[op]) {
                // @ts-ignore;
                cleanProps[op] = opts[op];
            }
        });
        return cleanProps;
    }
    static basename(nodePath, rmExtension) {
        if (rmExtension) {
            const idx = nodePath.lastIndexOf(".md");
            if (idx > 0) {
                nodePath = nodePath.slice(0, idx);
            }
        }
        const [first, ...rest] = nodePath.split(".");
        return lodash_1.default.isEmpty(rest) ? first : rest.slice(-1)[0];
    }
    static dirName(nodePath) {
        return nodePath.split(".").slice(0, -1).join(".");
    }
    static domainName(nodePath) {
        return nodePath.split(".")[0];
    }
    static fname(nodePath) {
        return path_1.default.basename(nodePath, ".md");
    }
    static enhancePropForQuickInput({ props, schemas, vaults, wsRoot, }) {
        const vault = vault_1.VaultUtils.matchVault({ vaults, wsRoot, vault: props.vault });
        if (!vault) {
            throw Error("enhancePropForQuickInput, no vault found");
        }
        const vname = vault_1.VaultUtils.getName(vault);
        const vaultSuffix = `(${vname})`;
        if (props.type === "note") {
            const isRoot = DNodeUtils.isRoot(props);
            const label = isRoot ? "root" : props.fname;
            const detail = props.desc;
            const sm = props.schema ? schemas[props.schema.moduleId] : undefined;
            const description = NoteUtils.genSchemaDesc(props, sm) + vaultSuffix;
            const out = { ...props, label, detail, description };
            return out;
        }
        else {
            const label = DNodeUtils.isRoot(props) ? "root" : props.id;
            const detail = props.desc;
            const out = { ...props, label, detail, description: vaultSuffix };
            return out;
        }
    }
    static enhancePropForQuickInputV3(opts) {
        const { alwaysShow } = lodash_1.default.defaults(opts, { alwaysShow: false });
        return { ...this.enhancePropForQuickInput(opts), alwaysShow };
    }
    static findClosestParent(fpath, nodes, opts) {
        const { vault } = opts;
        const dirname = DNodeUtils.dirName(fpath);
        if (dirname === "") {
            const _node = lodash_1.default.find(nodes, (ent) => ent.fname === "root" &&
                vault_1.VaultUtils.isEqual(ent.vault, vault, opts.wsRoot));
            if (lodash_1.default.isUndefined(_node)) {
                throw new error_1.DendronError({ message: `no root found for ${fpath}` });
            }
            return _node;
        }
        const maybeNode = NoteUtils.getNoteByFnameV5({
            fname: dirname,
            notes: nodes,
            vault,
            wsRoot: opts.wsRoot,
        });
        if ((maybeNode && !(opts === null || opts === void 0 ? void 0 : opts.noStubs)) ||
            (maybeNode && (opts === null || opts === void 0 ? void 0 : opts.noStubs) && !maybeNode.stub && !maybeNode.schemaStub)) {
            return maybeNode;
        }
        else {
            return DNodeUtils.findClosestParent(dirname, nodes, opts);
        }
    }
    static getCustomProps(props) {
        const blacklist = [
            "id",
            "title",
            "type",
            "desc",
            "fname",
            "updated",
            "custom",
            "created",
            "parent",
            "children",
            "color",
            "body",
            "data",
            "schemaStub",
            "type",
            "tags",
            "image",
        ];
        return lodash_1.default.omit(props, blacklist);
    }
    static getDepth(node) {
        return this.getFNameDepth(node.fname);
    }
    static getFNameDepth(fname) {
        if (fname === "root") {
            return 0;
        }
        return fname.split(".").length;
    }
    static getDomain(node, opts) {
        if (node.fname === "root") {
            throw Error("root has no domain");
        }
        const isRoot = DNodeUtils.isRoot(opts.nodeDict[node.parent]);
        if (isRoot) {
            return node;
        }
        else {
            return DNodeUtils.getDomain(DNodeUtils.getParent(node, opts), opts);
        }
    }
    static getFullPath(opts) {
        const root = path_1.default.isAbsolute(opts.vault.fsPath)
            ? vault_1.VaultUtils.getRelPath(opts.vault)
            : path_1.default.join(opts.wsRoot, vault_1.VaultUtils.getRelPath(opts.vault));
        return path_1.default.join(root, opts.basename);
    }
    static getParent(node, opts) {
        if (DNodeUtils.isRoot(node)) {
            throw Error("root has no parent");
        }
        const parent = opts.nodeDict[node.parent];
        if (lodash_1.default.isUndefined(parent)) {
            throw Error(`parent ${node.parent} not found`);
        }
        return parent;
    }
    static getChildren(node, opts) {
        const { nodeDict, recursive } = opts;
        const children = node.children.map((id) => {
            if (!lodash_1.default.has(nodeDict, id)) {
                throw Error("child nod found");
            }
            return nodeDict[id];
        });
        if (recursive) {
            return children.concat(children.map((c) => DNodeUtils.getChildren(c, opts)).flat());
        }
        return children;
    }
    static isRoot(note) {
        return note.fname === "root";
    }
    /**
     * Given a note, return the leaf name
     * @param note DNodeProps
     * @returns name of leaf node
     */
    static getLeafName(note) {
        return lodash_1.default.split(note.fname, ".").pop();
    }
}
exports.DNodeUtils = DNodeUtils;
class NoteUtils {
    /** Adds a backlink by mutating the 'to' argument in place.
     *
     *  @param from note that the link is pointing from.
     *  @param to note that the link is pointing to. (mutated)
     *  @param link backlink to add. */
    static addBacklink({ from, to, link, }) {
        to.links.push({
            from: { fname: from.fname, vaultName: vault_1.VaultUtils.getName(from.vault) },
            type: "backlink",
            position: link.position,
            value: link.value,
        });
    }
    /**
     * Add node to parent
     * Create stubs if no direct parent exists
     * @param opts
     * @returns All notes that were changed including the parent
     */
    static addParent(opts) {
        const { note, notesList, createStubs, wsRoot } = opts;
        const parentPath = DNodeUtils.dirName(note.fname).toLowerCase();
        let parent = lodash_1.default.find(notesList, (p) => p.fname.toLowerCase() === parentPath &&
            vault_1.VaultUtils.isEqual(p.vault.fsPath, note.vault.fsPath, wsRoot)) || null;
        const changed = [];
        if (parent) {
            changed.push(parent);
            DNodeUtils.addChild(parent, note);
        }
        if (!parent && !createStubs) {
            const err = {
                status: constants_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                msg: JSON.stringify({
                    fname: note.fname,
                }),
            };
            throw error_1.DendronError.createFromStatus(err);
        }
        if (!parent) {
            parent = DNodeUtils.findClosestParent(note.fname, notesList, {
                vault: note.vault,
                wsRoot,
            });
            changed.push(parent);
            const stubNodes = NoteUtils.createStubs(parent, note);
            stubNodes.forEach((ent2) => {
                changed.push(ent2);
            });
        }
        return changed;
    }
    static addSchema(opts) {
        const { note, schema, schemaModule } = opts;
        note.schema = { schemaId: schema.id, moduleId: schemaModule.root.id };
    }
    static create(opts) {
        const cleanOpts = lodash_1.default.defaults(opts, {
            schemaStub: false,
        });
        return DNodeUtils.create({ ...cleanOpts, type: "note" });
    }
    static createWithSchema({ noteOpts, engine, }) {
        const note = NoteUtils.create(noteOpts);
        const maybeMatch = SchemaUtils.matchPath({
            notePath: noteOpts.fname,
            schemaModDict: engine.schemas,
        });
        if (maybeMatch) {
            const { schema, schemaModule } = maybeMatch;
            NoteUtils.addSchema({ note, schemaModule, schema });
            const maybeTemplate = schema.data.template;
            if (maybeTemplate) {
                SchemaUtils.applyTemplate({ template: maybeTemplate, note, engine });
            }
        }
        return note;
    }
    static createRoot(opts) {
        return DNodeUtils.create({
            ...opts,
            type: "note",
            fname: "root",
            id: uuid_1.genUUID(),
        });
    }
    /**
     * Create stubs and add notes to parent
     * @param from
     * @param to
     */
    static createStubs(from, to) {
        const stubNodes = [];
        let fromPath = from.fname;
        if (DNodeUtils.isRoot(from)) {
            fromPath = "";
        }
        const toPath = to.fname;
        const index = toPath.indexOf(fromPath) + fromPath.length;
        const diffPath = lodash_1.default.trimStart(toPath.slice(index), ".").split(".");
        let stubPath = fromPath;
        let parent = from;
        // last element is node
        diffPath.slice(0, -1).forEach((part) => {
            // handle starting from root, path = ""
            if (lodash_1.default.isEmpty(stubPath)) {
                stubPath = part;
            }
            else {
                stubPath += `.${part}`;
            }
            const n = NoteUtils.create({
                fname: stubPath,
                stub: true,
                vault: to.vault,
            });
            stubNodes.push(n);
            DNodeUtils.addChild(parent, n);
            parent = n;
        });
        DNodeUtils.addChild(parent, to);
        return stubNodes;
    }
    /**
     * Create a wiki link to the given note
     *
     * @returns
     */
    static createWikiLink(opts) {
        const { note, anchor, useVaultPrefix, alias } = opts;
        const aliasMode = alias === null || alias === void 0 ? void 0 : alias.mode;
        const aliasValue = alias === null || alias === void 0 ? void 0 : alias.value;
        const tabStopIndex = alias === null || alias === void 0 ? void 0 : alias.tabStopIndex;
        let { title, fname, vault } = note;
        let suffix = "";
        if (anchor) {
            const { value: id, type } = anchor;
            let idStr;
            if (type === "header") {
                title = id;
                idStr = utils_1.getSlugger().slug(id);
            }
            else {
                idStr = id;
            }
            suffix = `#${idStr}`;
        }
        const vaultPrefix = useVaultPrefix
            ? `${constants_1.CONSTANTS.DENDRON_DELIMETER}${vault_1.VaultUtils.getName(vault)}/`
            : "";
        let aliasPrefix = "";
        switch (aliasMode) {
            case "snippet": {
                aliasPrefix = `\${${tabStopIndex}:alias}|`;
                break;
            }
            case "title": {
                aliasPrefix = `${title}|`;
                break;
            }
            case "value": {
                aliasPrefix = aliasValue !== "" ? `${aliasValue}|` : "";
                break;
            }
            default:
                break;
        }
        const link = `[[${aliasPrefix}${vaultPrefix}${fname}${suffix}]]`;
        return link;
    }
    static fromSchema({ fname, schemaModule, schemaId, vault, }) {
        const mschema = schemaModule.schemas[schemaId];
        return NoteUtils.create({
            fname,
            schemaStub: true,
            desc: mschema.desc,
            schema: {
                moduleId: schemaModule.root.id,
                schemaId,
            },
            vault,
        });
    }
    static genSchemaDesc(note, schemaMod) {
        const prefixParts = [];
        if (note.title !== note.fname) {
            prefixParts.push(note.title);
        }
        if (note.stub || note.schemaStub) {
            prefixParts.push("$(gist-new)");
        }
        if (note.schema) {
            if (!schemaMod) {
                throw Error("schema mod required");
            }
            const domain = schemaMod.root;
            const schema = schemaMod.schemas[note.schema.schemaId];
            // case: recognized schema
            prefixParts.push(`$(repo) ${domain.title || domain.id}`);
            // check if non-domain schema
            if (domain.id !== note.schema.schemaId) {
                prefixParts.push("$(breadcrumb-separator)");
                prefixParts.push(schema.title || schema.id);
            }
        }
        return prefixParts.join(" ");
    }
    static genJournalNoteTitle(opts) {
        const { fname, journalName } = opts;
        const journalIndex = fname.indexOf(journalName);
        const normTitle = NoteUtils.genTitle(fname);
        if (journalIndex < 0) {
            return normTitle;
        }
        const maybeDatePortion = fname.slice(journalIndex + journalName.length + 1);
        if (maybeDatePortion.match(/\d\d\d\d\.\d\d\.\d\d$/)) {
            return maybeDatePortion.replace(/\./g, "-");
        }
        return normTitle;
    }
    static genTitle(fname) {
        const titleFromBasename = DNodeUtils.basename(fname, true);
        // check if title is unchanged from default. if so, add default title
        if (lodash_1.default.toLower(fname) == fname) {
            fname = titleFromBasename.replace(/-/g, " ");
            // type definitions are wrong
            // @ts-ignore
            return title_1.default(fname);
        }
        // if user customized title, return the title as user specified
        return titleFromBasename;
    }
    static genUpdateTime() {
        const now = time_1.Time.now().toMillis();
        return now;
    }
    /** Returns true when the note has reference links (Eg. ![[ref-link]]); false otherwise. */
    static hasRefLinks(note) {
        return note.links.some((link) => link.type === "ref");
    }
    /**
     * Retrieve the latest update time of the preview note tree.
     *
     * Preview note tree includes links whose content is rendered in the rootNote preview,
     * particularly the reference links (![[ref-link-example]]). */
    static getLatestUpdateTimeOfPreviewNoteTree({ rootNote, notes, }) {
        // If the note does not have reference links than the last updated time of
        // the preview tree is the last updated time of the note itself. Hence, we
        // can avoid all heavier logic of getting ready to traverse notes.
        if (!this.hasRefLinks(rootNote)) {
            return rootNote.updated;
        }
        // Maps lowercase file names to list of note props with matching file name.
        // We will use a map to avoid having to loop over the the notes to find the notes
        // by file names for each fname in the tree. In the future if we start keeping these
        // values cached centrally we should replace these adhoc created maps with centrally cached values.
        const mapByFName = new utils_1.DefaultMap(() => []);
        lodash_1.default.values(notes).forEach((note) => {
            const lowercaseFName = note.fname.toLowerCase();
            // We are going to follow the current behavior of vault-less file name resolution:
            // The first matching file name that is met should win.
            mapByFName.get(lowercaseFName).push(note);
        });
        const visitedIds = new Set();
        return this._getLatestUpdateTimeOfPreviewNoteTree({
            note: rootNote,
            mapByFName,
            visitedIds,
            latestUpdated: rootNote.updated,
        });
    }
    static _getLatestUpdateTimeOfPreviewNoteTree({ note, latestUpdated, mapByFName, visitedIds, }) {
        if (note.updated > latestUpdated) {
            latestUpdated = note.updated;
        }
        // Mark the visited nodes so we don't end up recursively spinning if there
        // are cycles in our preview tree such as [[foo]] -> [[!bar]] -> [[!foo]]
        if (visitedIds.has(note.id)) {
            return latestUpdated;
        }
        else {
            visitedIds.add(note.id);
        }
        const linkedRefNotes = note.links
            .filter((link) => link.type === "ref")
            .filter((link) => link.to && link.to.fname)
            .map((link) => {
            const pointTo = link.to;
            const lowercaseFname = pointTo.fname.toLowerCase();
            const matchingList = mapByFName.get(lowercaseFname);
            // When there is a vault specified in the link we want to respect that
            // specification, otherwise we will map by just the file name.
            if (pointTo.vaultName) {
                const filteredByVault = matchingList.filter((n) => vault_1.VaultUtils.getName(n.vault) == pointTo.vaultName);
                return filteredByVault[0];
            }
            else {
                return matchingList[0];
            }
        })
            // Filter out broken links (pointing to non existent files)
            .filter((refNote) => refNote !== undefined);
        for (const linkedNote of linkedRefNotes) {
            // Recurse into each child reference linked note.
            latestUpdated = this._getLatestUpdateTimeOfPreviewNoteTree({
                note: linkedNote,
                mapByFName,
                visitedIds,
                latestUpdated,
            });
        }
        return latestUpdated;
    }
    static getNotesByFname({ fname, notes, vault, }) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        const lowercaseFName = fname.toLowerCase();
        const out = lodash_1.default.filter(notes, (ent) => {
            return (ent.fname.toLowerCase() === lowercaseFName &&
                (vault ? ent.vault.fsPath === vault.fsPath : true));
        });
        return out;
    }
    static getNoteByFnameV5({ fname, notes, vault, wsRoot, }) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        const out = lodash_1.default.find(notes, (ent) => {
            return (ent.fname.toLowerCase() === fname.toLowerCase() &&
                vault_1.VaultUtils.isEqual(vault, ent.vault, wsRoot));
        });
        return out;
    }
    /** If `to vault` is defined, returns note from that vault
     *  else searches all the vaults, to get the note with matching fname.
     * If more than one notes are with same fname, returns the note with same vault as `fromVault` */
    static getNoteFromMultiVault(opts) {
        const { fname, notes, fromVault, toVault, wsRoot } = opts;
        let existingNote;
        const maybeNotes = NoteUtils.getNotesByFname({
            fname,
            notes,
            vault: toVault,
        });
        if (maybeNotes.length > 1) {
            // If there are multiple notes with this fname, default to one that's in the same vault first.
            const sameVaultNote = lodash_1.default.filter(maybeNotes, (n) => vault_1.VaultUtils.isEqual(n.vault, fromVault, wsRoot))[0];
            if (!lodash_1.default.isUndefined(sameVaultNote)) {
                // There is a note that's within the same vault, let's go with that.
                existingNote = sameVaultNote;
            }
            else {
                // Otherwise, just pick one, doesn't matter which.
                existingNote = maybeNotes[0];
            }
        }
        else {
            // Just 1 note
            existingNote = maybeNotes[0];
        }
        return existingNote;
    }
    static getNoteOrThrow({ fname, notes, vault, wsRoot, }) {
        if (!lodash_1.default.isArray(notes)) {
            notes = lodash_1.default.values(notes);
        }
        const out = lodash_1.default.find(notes, (ent) => {
            return (ent.fname.toLowerCase() === fname.toLowerCase() &&
                vault_1.VaultUtils.isEqual(vault, ent.vault, wsRoot));
        });
        if (!out) {
            throw new error_1.DendronError({ message: `note ${fname} not found` });
        }
        return out;
    }
    /**
     @deprecated
     */
    static getNoteByFname(fname, notes, opts) {
        const _out = lodash_1.default.filter(lodash_1.default.values(notes), (ent) => {
            return ent.fname.toLowerCase() === fname.toLowerCase();
        });
        let out;
        if (_out.length > 1) {
            if (!(opts === null || opts === void 0 ? void 0 : opts.vault)) {
                throw new error_1.DendronError({
                    message: `multiple nodes found and no vault given for ${fname}`,
                });
            }
            out = lodash_1.default.find(_out, (ent) => { var _a; return ent.vault.fsPath === ((_a = opts === null || opts === void 0 ? void 0 : opts.vault) === null || _a === void 0 ? void 0 : _a.fsPath); });
            if (lodash_1.default.isUndefined(out)) {
                throw new error_1.DendronError({
                    message: `no note found for vault: ${opts.vault.fsPath}`,
                });
            }
        }
        else {
            out = _out[0];
        }
        if ((opts === null || opts === void 0 ? void 0 : opts.throwIfEmpty) && lodash_1.default.isUndefined(out)) {
            throw Error(`${fname} not found in getNoteByFname`);
        }
        return out;
    }
    static getNotesWithLinkTo({ note, notes, }) {
        const maybe = lodash_1.default.values(notes).map((ent) => {
            if (lodash_1.default.find(ent.links, (l) => {
                var _a;
                return ((_a = l.to) === null || _a === void 0 ? void 0 : _a.fname) === note.fname;
            })) {
                return ent;
            }
            else {
                return;
            }
        });
        return lodash_1.default.reject(maybe, lodash_1.default.isUndefined);
    }
    static getFullPath({ note, wsRoot, }) {
        try {
            const fpath = DNodeUtils.getFullPath({
                wsRoot,
                vault: note.vault,
                basename: note.fname + ".md",
            });
            return fpath;
        }
        catch (err) {
            throw new error_1.DendronError({
                message: "bad path",
                payload: { note, wsRoot },
            });
        }
    }
    static getURI({ note, wsRoot }) {
        return vscode_uri_1.URI.file(this.getFullPath({ note, wsRoot }));
    }
    /**
     * Get a list that has all the parents of the current note with the current note
     */
    static getNoteWithParents({ note, notes, sortDesc = true, }) {
        const out = [];
        if (!note || lodash_1.default.isUndefined(note)) {
            return [];
        }
        while (note.parent !== null) {
            out.push(note);
            try {
                let tmp = notes[note.parent];
                if (lodash_1.default.isUndefined(tmp)) {
                    throw "note is undefined";
                }
                note = tmp;
            }
            catch (err) {
                throw Error(`no parent found for note ${note.id}`);
            }
        }
        out.push(note);
        if (sortDesc) {
            lodash_1.default.reverse(out);
        }
        return out;
    }
    static getPathUpTo(hpath, numCompoenents) {
        return hpath.split(".").slice(0, numCompoenents).join(".");
    }
    static getRoots(notes) {
        return lodash_1.default.filter(lodash_1.default.values(notes), DNodeUtils.isRoot);
    }
    /**
     * Add {@link DNodeProps["parent"]} and {@link DNodeProps["children"]} from {@link noteHydrated} to {@link noteRaw}
     * @param noteRaw - note for other fields
     * @param noteHydrated - note to get {@link DNodeProps["parent"]} and {@link DNodeProps["children"]}  properties from
     * @returns Merged Note object
     */
    static hydrate({ noteRaw, noteHydrated, }) {
        const hydrateProps = lodash_1.default.pick(noteHydrated, ["parent", "children"]);
        return { ...noteRaw, ...hydrateProps };
    }
    static match({ notePath, pattern }) {
        return minimatch_1.default(notePath, pattern);
    }
    static isDefaultTitle(props) {
        return props.title === NoteUtils.genTitle(props.fname);
    }
    static normalizeFname(nodePath) {
        // remove md extension
        const idx = nodePath.lastIndexOf(".md");
        if (idx > 0) {
            nodePath = nodePath.slice(0, idx);
        }
        return lodash_1.default.trim(nodePath);
    }
    static isNoteProps(props) {
        return (lodash_1.default.isObject(props) &&
            types_1.REQUIRED_DNODEPROPS.every((key) => key in props && utils_1.isNotUndefined(props[key])));
    }
    static serializeMeta(props) {
        // Remove all undefined values, because they cause `matter` to fail serializing them
        const cleanProps = Object.fromEntries(Object.entries(props).filter(([_k, v]) => utils_1.isNotUndefined(v)));
        if (!this.isNoteProps(cleanProps))
            throw new error_1.DendronError({
                message: `Note is missing some properties that are required. Found properties: ${JSON.stringify(props)}`,
            });
        // Separate custom and builtin props
        const builtinProps = lodash_1.default.pick(cleanProps, [
            "id",
            "title",
            "desc",
            "updated",
            "created",
            "stub",
            "parent",
            "children",
            "color",
            "tags",
            "image",
        ]);
        const { custom: customProps } = cleanProps;
        const meta = { ...builtinProps, ...customProps };
        return meta;
    }
    static serialize(props, opts) {
        const body = props.body;
        let blacklist = ["parent", "children"];
        if (opts === null || opts === void 0 ? void 0 : opts.writeHierarchy) {
            blacklist = [];
        }
        const meta = lodash_1.default.omit(NoteUtils.serializeMeta(props), blacklist);
        return gray_matter_1.default.stringify(body || "", meta);
    }
    static toLogObj(note) {
        const { fname, id, children, vault, parent } = note;
        return {
            fname,
            id,
            children,
            vault,
            parent,
        };
    }
    static toNoteLoc(note) {
        const { fname, id, vault } = note;
        return {
            fname,
            id,
            vaultName: vault_1.VaultUtils.getName(vault),
        };
    }
    static uri2Fname(uri) {
        return path_1.default.basename(uri.fsPath, ".md");
    }
    static validate(noteProps) {
        if (lodash_1.default.isUndefined(noteProps)) {
            return error_1.DendronError.createFromStatus({
                status: constants_1.ERROR_STATUS.BAD_PARSE_FOR_NOTE,
                message: "NoteProps is undefined",
            });
        }
        if (lodash_1.default.isUndefined(noteProps.vault)) {
            return error_1.DendronError.createFromStatus({
                status: constants_1.ERROR_STATUS.BAD_PARSE_FOR_NOTE,
                message: "note vault is undefined",
            });
        }
        return true;
    }
    static createFnameNoteMap(notes, removeStubs) {
        const notesMap = new Map();
        const candidates = removeStubs ? notes.filter((n) => !n.stub) : notes;
        candidates.map((n) => {
            notesMap.set(n.fname, n);
        });
        return notesMap;
    }
    /** Generate a random color for `note`, but allow the user to override that color selection.
     *
     * @param note The fname of note that you want to get the color of.
     * @param notes: All notes in `engine.notes`, used to check the ancestors of `note`.
     * @returns The color, and whether this color was randomly generated or explicitly defined.
     */
    static color(opts) {
        const ancestors = NoteUtils.ancestors({ ...opts, includeSelf: true });
        for (const note of ancestors) {
            if (note.color)
                return { color: note.color, type: "configured" };
        }
        return { color: utils_1.randomColor(opts.fname), type: "generated" };
    }
    /** Get the ancestors of a note, in the order of the closest to farthest.
     *
     * This function will continue searching for ancestors even if a note with `fname`
     * doesn't exist, provided that it has ancestors.
     * For example, if fname is `foo.bar.baz` but only `foo` exists, this function
     * will find `foo`.
     *
     * ```ts
     * const ancestorNotes = NoteUtils.ancestors({ fname, notes: engine.notes });
     * for (const ancestor of ancestorNotes) { }
     * // or
     * const allAncestors = [...ancestorNotes];
     * ```
     *
     * @param opts.fname The fname of the note you are trying to get the ancestors of.
     * @param opts.vault The vault to look for. If provided, only notes from this vault will be included.
     * @param opts.notes All notes in `engine.notes`.
     * @param opts.includeSelf: If true, note with `fname` itself will be included in the ancestors.
     * @param opts.nonStubOnly: If true, only notes that are not stubs will be included.
     */
    static *ancestors(opts) {
        const { fname, notes, includeSelf, nonStubOnly } = opts;
        let { vault } = opts;
        let parts = fname.split(".");
        let note = NoteUtils.getNotesByFname({
            fname,
            vault,
            notes,
        })[0];
        // Check if we need this note itself
        if (note && includeSelf && !(nonStubOnly && note.stub))
            yield note;
        if (fname === "root")
            return;
        // All ancestors within the same hierarchy
        while (parts.length > 1) {
            parts = parts.slice(undefined, parts.length - 1);
            note = NoteUtils.getNotesByFname({
                fname: parts.join("."),
                vault,
                notes,
            })[0];
            if (note && !(nonStubOnly && note.stub))
                yield note;
        }
        // The ultimate ancestor of all notes is root
        if (note) {
            // Yielded at least one note
            if (!vault)
                vault = note.vault;
            note = NoteUtils.getNotesByFname({ fname: "root", notes, vault })[0];
            if (note)
                yield note;
        }
    }
}
exports.NoteUtils = NoteUtils;
NoteUtils.RE_FM = /^---(.*)^---/ms;
NoteUtils.RE_FM_UPDATED = /^updated:\s+(\d+)$/m;
NoteUtils.RE_FM_CREATED = /^created:.*$/m;
NoteUtils.RE_FM_UPDATED_OR_CREATED = /^(?<beforeTimestamp>(updated|created): *)(?<timestamp>[0-9]+)$/;
class SchemaUtils {
    static applyTemplate(opts) {
        const { template, note, engine } = opts;
        if (template.type === "note") {
            const tempNote = lodash_1.default.find(lodash_1.default.values(engine.notes), { fname: template.id });
            if (lodash_1.default.isUndefined(tempNote)) {
                throw Error(`no template found for ${template.id}`);
            }
            const tempNoteProps = lodash_1.default.pick(tempNote, this.TEMPLATE_COPY_PROPS);
            lodash_1.default.forEach(tempNoteProps, (v, k) => {
                // @ts-ignore
                note[k] = v;
            });
            return true;
        }
        return false;
    }
    static create(opts) {
        const schemaDataOpts = [
            "namespace",
            "pattern",
            "template",
        ];
        const optsWithoutData = lodash_1.default.omit(opts, schemaDataOpts);
        const optsData = lodash_1.default.pick(opts, schemaDataOpts);
        const vault = opts.vault;
        return DNodeUtils.create({
            vault,
            ...lodash_1.default.defaults(optsWithoutData, {
                title: optsWithoutData.id,
                data: optsData,
                fname: "__empty",
            }),
            type: "schema",
        });
    }
    static createModule(opts) {
        return opts;
    }
    static createModuleProps(opts) {
        const { fname, vault } = opts;
        const root = SchemaUtils.create({
            id: `${fname}`,
            fname,
            parent: "root",
            created: 1,
            updated: 1,
            children: [],
            vault,
        });
        return {
            version: 1,
            fname,
            root,
            schemas: { [root.id]: root },
            imports: [],
            vault,
        };
    }
    static createRootModule(opts) {
        const schema = SchemaUtils.create({
            id: "root",
            title: "root",
            fname: "root.schema",
            parent: "root",
            children: [],
            ...opts,
        });
        return {
            version: 1,
            imports: [],
            schemas: [schema],
        };
    }
    static createRootModuleProps(fname, vault, opts) {
        const schema = SchemaUtils.create({
            id: "root",
            title: "root",
            fname: "root",
            parent: "root",
            children: [],
            vault,
            ...opts,
        });
        return {
            version: 1,
            imports: [],
            schemas: { root: schema },
            fname,
            root: schema,
            vault,
        };
    }
    static enhanceForQuickInput({ props, vaults, }) {
        var _a;
        const vaultSuffix = vaults.length > 1
            ? ` (${path_1.default.basename((_a = props.vault) === null || _a === void 0 ? void 0 : _a.fsPath)})`
            : "";
        const label = DNodeUtils.isRoot(props.root) ? "root" : props.root.id;
        const detail = props.root.desc;
        const out = {
            ...props.root,
            fname: props.fname,
            label,
            detail,
            description: vaultSuffix,
            vault: props.vault,
        };
        return out;
    }
    static getModuleRoot(module) {
        const maybeRoot = lodash_1.default.find(module.schemas, { parent: "root" });
        if (!maybeRoot) {
            const rootSchemaRoot = lodash_1.default.find(module.schemas, {
                parent: null,
                id: "root",
            });
            if (!rootSchemaRoot) {
                throw error_1.DendronError.createFromStatus({
                    status: constants_1.ERROR_STATUS.NO_ROOT_SCHEMA_FOUND,
                });
            }
            else {
                return rootSchemaRoot;
            }
        }
        return maybeRoot;
    }
    /**
     * @param param0
     * @returns
     */
    static getPath({ root, fname }) {
        return path_1.default.join(root, fname + ".schema.yml");
    }
    /**
     @deprecated
     */
    static getSchemaModuleByFnameV4({ fname, schemas, wsRoot, vault, }) {
        if (!lodash_1.default.isArray(schemas)) {
            schemas = lodash_1.default.values(schemas);
        }
        const out = lodash_1.default.find(schemas, (ent) => {
            if (ent.fname.toLowerCase() !== fname.toLowerCase()) {
                return false;
            }
            if (vault) {
                return vault_1.VaultUtils.isEqual(vault, ent.vault, wsRoot);
            }
            return true;
        });
        return out;
    }
    static getSchemaFromNote({ note, engine, }) {
        if (note.schema) {
            return engine.schemas[note.schema.moduleId];
        }
        return;
    }
    /**
     * Matcn and assign schemas to all nodes within
     * a domain
     *
     * @param domain
     * @param notes
     * @param schemas
     */
    static matchDomain(domain, notes, schemas) {
        const match = schemas[domain.fname];
        if (!match) {
            return;
        }
        else {
            const domainSchema = match.schemas[match.root.id];
            return SchemaUtils.matchDomainWithSchema({
                noteCandidates: [domain],
                notes,
                schemaCandidates: [domainSchema],
                schemaModule: match,
            });
        }
    }
    static matchDomainWithSchema(opts) {
        const { noteCandidates, schemaCandidates, notes, schemaModule, matchNamespace, } = lodash_1.default.defaults(opts, { matchNamespace: true });
        const matches = lodash_1.default.map(noteCandidates, (note) => {
            return SchemaUtils.matchNotePathWithSchemaAtLevel({
                notePath: note.fname,
                schemas: schemaCandidates,
                schemaModule,
                matchNamespace,
            });
        }).filter((ent) => !lodash_1.default.isUndefined(ent));
        matches.map((m) => {
            const { schema, notePath } = m;
            const note = lodash_1.default.find(noteCandidates, { fname: notePath });
            NoteUtils.addSchema({ note, schema, schemaModule });
            const matchNextNamespace = schema.data.namespace && matchNamespace ? false : true;
            const nextSchemaCandidates = matchNextNamespace
                ? schema.children.map((id) => schemaModule.schemas[id])
                : [schema];
            const nextNoteCandidates = note.children.map((id) => notes[id]);
            return SchemaUtils.matchDomainWithSchema({
                noteCandidates: nextNoteCandidates,
                schemaCandidates: nextSchemaCandidates,
                notes,
                schemaModule,
                matchNamespace: matchNextNamespace,
            });
        });
    }
    static matchPath(opts) {
        const { notePath, schemaModDict } = opts;
        const domainName = DNodeUtils.domainName(notePath);
        const match = schemaModDict[domainName];
        if (!match) {
            return;
        }
        else {
            const domainSchema = match.schemas[match.root.id];
            if (domainName.length === notePath.length) {
                return {
                    schema: domainSchema,
                    notePath,
                    namespace: domainSchema.data.namespace || false,
                    schemaModule: match,
                };
            }
            return SchemaUtils.matchPathWithSchema({
                notePath,
                matched: "",
                schemaCandidates: [domainSchema],
                schemaModule: match,
            });
        }
    }
    /**
     *
     * @param param0
     * @return
     *  - schemaModule
     *  - schema
     *  - namespace
     *  - notePath
     */
    static matchPathWithSchema({ notePath, matched, schemaCandidates, schemaModule, matchNamespace = true, }) {
        const getChildOfPath = (notePath, matched) => {
            const nextLvlIndex = lodash_1.default.indexOf(notePath, ".", matched.length + 1);
            return nextLvlIndex > 0 ? notePath.slice(0, nextLvlIndex) : notePath;
        };
        const nextNotePath = getChildOfPath(notePath, matched);
        const match = SchemaUtils.matchNotePathWithSchemaAtLevel({
            notePath: nextNotePath,
            schemas: schemaCandidates,
            schemaModule,
            matchNamespace,
        });
        if (match) {
            const { schema, namespace } = match;
            // found a match
            if (notePath === nextNotePath) {
                return {
                    schemaModule,
                    schema,
                    namespace,
                    notePath,
                };
            }
            // if current note is a namespace and we are currently matching namespaces, don't match on the next turn
            const matchNextNamespace = schema.data.namespace && matchNamespace ? false : true;
            // if we are not matching the next namespace, then we go back to regular matching behavior
            const nextSchemaCandidates = matchNextNamespace
                ? schema.children.map((id) => schemaModule.schemas[id])
                : [schema];
            return SchemaUtils.matchPathWithSchema({
                notePath,
                matched: nextNotePath,
                schemaCandidates: nextSchemaCandidates,
                schemaModule,
                matchNamespace: matchNextNamespace,
            });
        }
        return;
    }
    static matchNotePathWithSchemaAtLevel({ notePath, schemas, schemaModule, matchNamespace = true, }) {
        const notePathClean = notePath.replace(/\./g, "/");
        let namespace = false;
        let match = lodash_1.default.find(schemas, (sc) => {
            var _a;
            const pattern = SchemaUtils.getPatternRecursive(sc, schemaModule.schemas);
            if (((_a = sc === null || sc === void 0 ? void 0 : sc.data) === null || _a === void 0 ? void 0 : _a.namespace) && matchNamespace) {
                namespace = true;
                return minimatch_1.default(notePathClean, lodash_1.default.trimEnd(pattern, "/*"));
            }
            else {
                return minimatch_1.default(notePathClean, pattern);
            }
        });
        if (match) {
            return {
                schema: match,
                namespace,
                notePath,
                schemaModule,
            };
        }
        return;
    }
    static serializeSchemaProps(props) {
        const builtinProps = lodash_1.default.pick(props, [
            "id",
            "children",
        ]);
        const optional = [
            "title",
            "desc",
        ];
        lodash_1.default.forEach(optional, (opt) => {
            if (props[opt]) {
                builtinProps[opt] = props[opt];
            }
        });
        const dataProps = props.data;
        // special for root
        if ((props === null || props === void 0 ? void 0 : props.parent) === "root") {
            builtinProps.parent = "root";
        }
        return { ...builtinProps, ...dataProps };
    }
    static serializeModuleProps(moduleProps) {
        const { version, imports, schemas } = moduleProps;
        // TODO: filter out imported schemas
        const out = {
            version,
            imports: [],
            schemas: lodash_1.default.values(schemas).map((ent) => this.serializeSchemaProps(ent)),
        };
        if (imports) {
            out.imports = imports;
        }
        return js_yaml_1.default.safeDump(out, { schema: js_yaml_1.JSON_SCHEMA });
    }
    static serializeModuleOpts(moduleOpts) {
        const { version, imports, schemas } = lodash_1.default.defaults(moduleOpts, {
            imports: [],
        });
        const out = {
            version,
            imports,
            schemas: lodash_1.default.values(schemas).map((ent) => this.serializeSchemaProps(ent)),
        };
        return js_yaml_1.default.safeDump(out, { schema: js_yaml_1.JSON_SCHEMA });
    }
}
exports.SchemaUtils = SchemaUtils;
/** The props of a template note that will get copied over when the template is applied. */
SchemaUtils.TEMPLATE_COPY_PROPS = [
    "body",
    "desc",
    "custom",
    "color",
    "tags",
    "image",
];
/**
 * If no pattern field, get the id.
 * If pattern field, check if namespace and translate into glob pattern
 * @param schema
 * @param opts
 * @returns
 */
SchemaUtils.getPattern = (schema, opts) => {
    var _a, _b;
    const pattern = ((_a = schema === null || schema === void 0 ? void 0 : schema.data) === null || _a === void 0 ? void 0 : _a.pattern) || schema.id;
    const part = ((_b = schema === null || schema === void 0 ? void 0 : schema.data) === null || _b === void 0 ? void 0 : _b.namespace) && !(opts === null || opts === void 0 ? void 0 : opts.isNotNamespace)
        ? `${pattern}/*`
        : pattern;
    return part;
};
/**
 * Get full pattern starting from the root
 * @param schema
 * @param schemas
 * @returns
 */
SchemaUtils.getPatternRecursive = (schema, schemas) => {
    const part = SchemaUtils.getPattern(schema);
    if (lodash_1.default.isNull(schema.parent)) {
        return part;
    }
    const parent = schemas[schema.parent];
    if (parent && parent.id !== "root") {
        const prefix = SchemaUtils.getPatternRecursive(parent, schemas);
        return [prefix, part].join("/");
    }
    else {
        return part;
    }
};
SchemaUtils.hasSimplePattern = (schema, opts) => {
    const pattern = SchemaUtils.getPattern(schema, opts);
    return !lodash_1.default.isNull(pattern.match(/^[a-zA-Z0-9_-]*$/));
};
//# sourceMappingURL=dnode.js.map