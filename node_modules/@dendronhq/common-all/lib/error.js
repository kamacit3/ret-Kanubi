"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTSError = exports.ErrorUtils = exports.ErrorFactory = exports.assertInvalidState = exports.assertUnreachable = exports.ErrorMessages = exports.error2PlainObject = exports.stringifyError = exports.IllegalOperationError = exports.DendronServerError = exports.DendronCompositeError = exports.DendronError = void 0;
const lodash_1 = __importDefault(require("lodash"));
const constants_1 = require("./constants");
class DendronError extends Error {
    constructor({ message, status, payload, severity, code, innerError, }) {
        super(message);
        this.name = "DendronError";
        this.status = status || "unknown";
        this.severity = severity;
        this.message = message || "";
        if ((payload === null || payload === void 0 ? void 0 : payload.message) && (payload === null || payload === void 0 ? void 0 : payload.stack)) {
            this.payload = JSON.stringify({
                msg: payload.message,
                stack: payload.stack,
            });
        }
        else {
            this.payload = JSON.stringify(payload || {});
        }
        this.code = code;
        this.innerError = innerError;
        if (innerError) {
            this.stack = innerError.stack;
        }
    }
    static createPlainError(props) {
        return exports.error2PlainObject({
            ...props,
            // isComposite: false,
            name: "DendronError",
        });
    }
    static createFromStatus({ status, ...rest }) {
        return new DendronError({
            name: "DendronError",
            message: status,
            status,
            ...rest,
        });
    }
}
exports.DendronError = DendronError;
class DendronCompositeError extends Error {
    constructor(errors) {
        super("multiple errors");
        this.payload = errors.map((err) => exports.error2PlainObject(err));
        this.message = "Multiple errors:\n";
        const hasFatalError = lodash_1.default.find(errors, (err) => err.severity === constants_1.ERROR_SEVERITY.FATAL) !==
            undefined;
        const allMinorErrors = lodash_1.default.filter(errors, (err) => err.severity !== constants_1.ERROR_SEVERITY.MINOR)
            .length === 0;
        if (hasFatalError) {
            // If there is even one fatal error, then the composite is also fatal
            this.severity = constants_1.ERROR_SEVERITY.FATAL;
        }
        else if (allMinorErrors) {
            // No fatal errors, and everything is a minor error.
            // The composite can be safely marked as a minor error too.
            this.message = "Multiple warnings:\n";
            this.severity = constants_1.ERROR_SEVERITY.MINOR;
        }
        // Otherwise, there are no fatal errors but at least one error has
        // undefined severity. Then the composite also has undefined severity.
        // Combine all error messages to display to the user.
        this.message += lodash_1.default.map(errors, (err) => err.message).join("\n");
    }
}
exports.DendronCompositeError = DendronCompositeError;
class DendronServerError extends DendronError {
}
exports.DendronServerError = DendronServerError;
class IllegalOperationError extends DendronError {
}
exports.IllegalOperationError = IllegalOperationError;
function stringifyError(err) {
    return JSON.stringify(err, Object.getOwnPropertyNames(err));
}
exports.stringifyError = stringifyError;
const error2PlainObject = (err) => {
    const out = {};
    Object.getOwnPropertyNames(err).forEach((k) => {
        // @ts-ignore
        out[k] = err[k];
    });
    return out;
};
exports.error2PlainObject = error2PlainObject;
class ErrorMessages {
    static formatShouldNeverOccurMsg(description) {
        return `${description === undefined ? "" : description + " "}This error should never occur! Please report a bug if you have encountered this.`;
    }
}
exports.ErrorMessages = ErrorMessages;
/** Statically ensure that a code path is unreachable using a variable that has been exhaustively used.
 *
 * The use case for this function is that when using a switch or a chain of if/else if statements,
 * this function allows you to ensure that after all possibilities have been already checked, no further
 * possibilities remain. Importantly, this is done statically (i.e. during compilation), so if anyone
 * revises the code in a way that adds expands the possibilities, a compiler error will warn them that
 * they must revise this part of the code as well.
 *
 * An example of how this function may be used is below:
 *
 *     type Names = "bar" | "baz";
 *
 *     function foo(name: Names) {
 *       if (name === "bar") { ... }
 *       else if (name === "baz") { ... }
 *       else assertUnreachable(name);
 *     }
 *
 * Let's say someone changes the type Names to `type Names = "bar" | "baz" | "ham";`. Thanks to this
 * assertion, the compiler will warn them that this branch is now reachable, and something is wrong.
 *
 * @param x
 */
function assertUnreachable(_never) {
    throw new DendronError({
        message: ErrorMessages.formatShouldNeverOccurMsg(),
    });
}
exports.assertUnreachable = assertUnreachable;
/**
 * Helper function to raise invalid state
 */
function assertInvalidState(msg) {
    throw new DendronError({
        status: constants_1.ERROR_STATUS.INVALID_STATE,
        message: msg,
    });
}
exports.assertInvalidState = assertInvalidState;
/** Utility class for helping to correctly construct common errors. */
class ErrorFactory {
    static createUnexpectedEventError({ event }) {
        return new DendronError({
            message: `unexpected event: '${this.safeStringify(event)}'`,
        });
    }
    static createInvalidStateError({ message, }) {
        return new DendronError({
            status: constants_1.ERROR_STATUS.INVALID_STATE,
            message,
        });
    }
    /** Stringify that will not throw if it fails to stringify
     * (for example: due to circular references)  */
    static safeStringify(obj) {
        try {
            return JSON.stringify(obj);
        }
        catch (exc) {
            return `Failed to stringify the given object. Due to '${exc.message}'`;
        }
    }
}
exports.ErrorFactory = ErrorFactory;
class ErrorUtils {
    static isAxiosError(error) {
        return lodash_1.default.has(error, "isAxiosError");
    }
    static isDendronError(error) {
        return lodash_1.default.get(error, "name", "") === "DendronError";
    }
}
exports.ErrorUtils = ErrorUtils;
function isTSError(err) {
    return err.message !== undefined && err.name !== undefined;
}
exports.isTSError = isTSError;
//# sourceMappingURL=error.js.map