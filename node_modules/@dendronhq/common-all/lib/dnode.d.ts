import { URI } from "vscode-uri";
import { DendronError } from "./error";
import { DEngineClient, DLink, DNodeOpts, DNodeProps, DNodePropsDict, DNodePropsQuickInputV2, DNoteLoc, DVault, NoteOpts, NoteProps, NotePropsDict, SchemaModuleDict, SchemaModuleOpts, SchemaModuleProps, SchemaOpts, SchemaProps, SchemaPropsDict, SchemaRaw, SchemaTemplate } from "./types";
/**
 * Utilities for dealing with nodes
 */
export declare class DNodeUtils {
    static addChild(parent: DNodeProps, child: DNodeProps): void;
    static create(opts: DNodeOpts): DNodeProps;
    static basename(nodePath: string, rmExtension?: boolean): string;
    static dirName(nodePath: string): string;
    static domainName(nodePath: string): string;
    static fname(nodePath: string): string;
    static enhancePropForQuickInput({ props, schemas, vaults, wsRoot, }: {
        props: DNodeProps;
        schemas: SchemaModuleDict;
        vaults: DVault[];
        wsRoot: string;
    }): DNodePropsQuickInputV2;
    static enhancePropForQuickInputV3(opts: {
        props: DNodeProps;
        schemas: SchemaModuleDict;
        vaults: DVault[];
        wsRoot: string;
        alwaysShow?: boolean;
    }): DNodePropsQuickInputV2;
    static findClosestParent(fpath: string, nodes: DNodeProps[], opts: {
        noStubs?: boolean;
        vault: DVault;
        wsRoot: string;
    }): DNodeProps;
    static getCustomProps(props: any): any;
    static getDepth(node: DNodeProps): number;
    static getFNameDepth(fname: string): number;
    static getDomain(node: DNodeProps, opts: {
        nodeDict: DNodePropsDict;
    }): DNodeProps;
    static getFullPath(opts: {
        wsRoot: string;
        vault: DVault;
        basename: string;
    }): string;
    static getParent(node: DNodeProps, opts: {
        nodeDict: DNodePropsDict;
    }): DNodeProps;
    static getChildren(node: DNodeProps, opts: {
        recursive?: boolean;
        nodeDict: DNodePropsDict;
    }): DNodeProps[];
    static isRoot(note: DNodeProps): boolean;
    /**
     * Given a note, return the leaf name
     * @param note DNodeProps
     * @returns name of leaf node
     */
    static getLeafName(note: DNodeProps): string | undefined;
}
export declare class NoteUtils {
    static RE_FM: RegExp;
    static RE_FM_UPDATED: RegExp;
    static RE_FM_CREATED: RegExp;
    static RE_FM_UPDATED_OR_CREATED: RegExp;
    /** Adds a backlink by mutating the 'to' argument in place.
     *
     *  @param from note that the link is pointing from.
     *  @param to note that the link is pointing to. (mutated)
     *  @param link backlink to add. */
    static addBacklink({ from, to, link, }: {
        from: NoteProps;
        to: NoteProps;
        link: DLink;
    }): void;
    /**
     * Add node to parent
     * Create stubs if no direct parent exists
     * @param opts
     * @returns All notes that were changed including the parent
     */
    static addParent(opts: {
        note: NoteProps;
        notesList: NoteProps[];
        createStubs: boolean;
        wsRoot: string;
    }): NoteProps[];
    static addSchema(opts: {
        note: NoteProps;
        schemaModule: SchemaModuleProps;
        schema: SchemaProps;
    }): void;
    static create(opts: NoteOpts): NoteProps;
    static createWithSchema({ noteOpts, engine, }: {
        noteOpts: NoteOpts;
        engine: DEngineClient;
    }): NoteProps;
    static createRoot(opts: Partial<NoteOpts> & {
        vault: DVault;
    }): NoteProps;
    /**
     * Create stubs and add notes to parent
     * @param from
     * @param to
     */
    static createStubs(from: NoteProps, to: NoteProps): NoteProps[];
    /**
     * Create a wiki link to the given note
     *
     * @returns
     */
    static createWikiLink(opts: {
        note: NoteProps;
        anchor?: {
            value: string;
            type: "header" | "blockAnchor";
        };
        alias?: {
            mode: "snippet" | "title" | "value" | "none";
            value?: string;
            tabStopIndex?: number;
        };
        useVaultPrefix?: boolean;
    }): string;
    static fromSchema({ fname, schemaModule, schemaId, vault, }: {
        fname: string;
        schemaModule: SchemaModuleProps;
        schemaId: string;
        vault: DVault;
    }): NoteProps;
    static genSchemaDesc(note: NoteProps, schemaMod?: SchemaModuleProps): string;
    static genJournalNoteTitle(opts: {
        fname: string;
        journalName: string;
    }): string;
    static genTitle(fname: string): string;
    static genUpdateTime(): number;
    /** Returns true when the note has reference links (Eg. ![[ref-link]]); false otherwise. */
    static hasRefLinks(note: NoteProps): boolean;
    /**
     * Retrieve the latest update time of the preview note tree.
     *
     * Preview note tree includes links whose content is rendered in the rootNote preview,
     * particularly the reference links (![[ref-link-example]]). */
    static getLatestUpdateTimeOfPreviewNoteTree({ rootNote, notes, }: {
        rootNote: NoteProps;
        notes: NotePropsDict;
    }): number;
    private static _getLatestUpdateTimeOfPreviewNoteTree;
    static getNotesByFname({ fname, notes, vault, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault?: DVault;
    }): NoteProps[];
    static getNoteByFnameV5({ fname, notes, vault, wsRoot, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault: DVault;
        wsRoot: string;
    }): NoteProps | undefined;
    /** If `to vault` is defined, returns note from that vault
     *  else searches all the vaults, to get the note with matching fname.
     * If more than one notes are with same fname, returns the note with same vault as `fromVault` */
    static getNoteFromMultiVault(opts: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        fromVault: DVault;
        wsRoot: string;
        toVault?: DVault;
    }): NoteProps;
    static getNoteOrThrow({ fname, notes, vault, wsRoot, }: {
        fname: string;
        notes: NotePropsDict | NoteProps[];
        vault: DVault;
        wsRoot: string;
    }): NoteProps;
    /**
     @deprecated
     */
    static getNoteByFname(fname: string, notes: NotePropsDict, opts?: {
        throwIfEmpty?: boolean;
        vault?: DVault;
    }): NoteProps | undefined;
    static getNotesWithLinkTo({ note, notes, }: {
        note: NoteProps;
        notes: NotePropsDict;
    }): NoteProps[];
    static getFullPath({ note, wsRoot, }: {
        note: NoteProps;
        wsRoot: string;
    }): string;
    static getURI({ note, wsRoot }: {
        note: NoteProps;
        wsRoot: string;
    }): URI;
    /**
     * Get a list that has all the parents of the current note with the current note
     */
    static getNoteWithParents({ note, notes, sortDesc, }: {
        note: NoteProps;
        notes: NotePropsDict;
        sortDesc?: boolean;
    }): NoteProps[];
    static getPathUpTo(hpath: string, numCompoenents: number): string;
    static getRoots(notes: NotePropsDict): NoteProps[];
    /**
     * Add {@link DNodeProps["parent"]} and {@link DNodeProps["children"]} from {@link noteHydrated} to {@link noteRaw}
     * @param noteRaw - note for other fields
     * @param noteHydrated - note to get {@link DNodeProps["parent"]} and {@link DNodeProps["children"]}  properties from
     * @returns Merged Note object
     */
    static hydrate({ noteRaw, noteHydrated, }: {
        noteRaw: NoteProps;
        noteHydrated: NoteProps;
    }): {
        children: string[];
        parent: string | null;
        id: string;
        title: string;
        desc: string;
        links: DLink[];
        anchors: {
            [index: string]: import("./types").DNoteAnchorPositioned | undefined;
        };
        fname: string;
        type: import("./types").DNodeType;
        updated: number;
        created: number;
        stub?: boolean | undefined;
        schemaStub?: boolean | undefined;
        data: any;
        body: string;
        custom?: any;
        schema?: {
            moduleId: string;
            schemaId: string;
        } | undefined;
        vault: DVault;
        contentHash?: string | undefined;
        color?: string | undefined;
        tags?: string | string[] | undefined;
        image?: import("./types").DNodeImage | undefined;
    };
    static match({ notePath, pattern }: {
        notePath: string;
        pattern: string;
    }): boolean;
    static isDefaultTitle(props: NoteProps): boolean;
    static normalizeFname(nodePath: string): string;
    static isNoteProps(props: Partial<NoteProps>): props is NoteProps;
    static serializeMeta(props: NoteProps): any;
    static serialize(props: NoteProps, opts?: {
        writeHierarchy?: boolean;
    }): string;
    static toLogObj(note: NoteProps): {
        fname: string;
        id: string;
        children: string[];
        vault: DVault;
        parent: string | null;
    };
    static toNoteLoc(note: NoteProps): DNoteLoc;
    static uri2Fname(uri: URI): string;
    static validate(noteProps: Partial<NoteProps>): true | DendronError;
    static createFnameNoteMap(notes: NoteProps[], removeStubs?: boolean): Map<string, NoteProps>;
    /** Generate a random color for `note`, but allow the user to override that color selection.
     *
     * @param note The fname of note that you want to get the color of.
     * @param notes: All notes in `engine.notes`, used to check the ancestors of `note`.
     * @returns The color, and whether this color was randomly generated or explicitly defined.
     */
    static color(opts: {
        fname: string;
        vault?: DVault;
        notes: NotePropsDict;
    }): {
        color: string;
        type: "configured" | "generated";
    };
    /** Get the ancestors of a note, in the order of the closest to farthest.
     *
     * This function will continue searching for ancestors even if a note with `fname`
     * doesn't exist, provided that it has ancestors.
     * For example, if fname is `foo.bar.baz` but only `foo` exists, this function
     * will find `foo`.
     *
     * ```ts
     * const ancestorNotes = NoteUtils.ancestors({ fname, notes: engine.notes });
     * for (const ancestor of ancestorNotes) { }
     * // or
     * const allAncestors = [...ancestorNotes];
     * ```
     *
     * @param opts.fname The fname of the note you are trying to get the ancestors of.
     * @param opts.vault The vault to look for. If provided, only notes from this vault will be included.
     * @param opts.notes All notes in `engine.notes`.
     * @param opts.includeSelf: If true, note with `fname` itself will be included in the ancestors.
     * @param opts.nonStubOnly: If true, only notes that are not stubs will be included.
     */
    static ancestors(opts: {
        fname: string;
        vault?: DVault;
        notes: NotePropsDict;
        includeSelf?: boolean;
        nonStubOnly?: boolean;
    }): Generator<NoteProps>;
}
declare type SchemaMatchResult = {
    schemaModule: SchemaModuleProps;
    schema: SchemaProps;
    namespace: boolean;
    notePath: string;
};
export declare class SchemaUtils {
    /** The props of a template note that will get copied over when the template is applied. */
    static TEMPLATE_COPY_PROPS: readonly (keyof NoteProps)[];
    static applyTemplate(opts: {
        template: SchemaTemplate;
        note: NoteProps;
        engine: DEngineClient;
    }): boolean;
    static create(opts: (SchemaOpts | SchemaRaw) & {
        vault: DVault;
    }): SchemaProps;
    static createModule(opts: SchemaModuleOpts): SchemaModuleOpts;
    static createModuleProps(opts: {
        fname: string;
        vault: DVault;
    }): SchemaModuleProps;
    static createRootModule(opts: Partial<SchemaProps> & {
        vault: DVault;
    }): SchemaModuleOpts;
    static createRootModuleProps(fname: string, vault: DVault, opts?: Partial<SchemaProps>): SchemaModuleProps;
    static enhanceForQuickInput({ props, vaults, }: {
        props: SchemaModuleProps;
        vaults: DVault[];
    }): DNodePropsQuickInputV2;
    static getModuleRoot(module: SchemaModuleOpts | SchemaModuleProps): SchemaProps;
    /**
     * If no pattern field, get the id.
     * If pattern field, check if namespace and translate into glob pattern
     * @param schema
     * @param opts
     * @returns
     */
    static getPattern: (schema: SchemaProps, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => string;
    /**
     * Get full pattern starting from the root
     * @param schema
     * @param schemas
     * @returns
     */
    static getPatternRecursive: (schema: SchemaProps, schemas: SchemaPropsDict) => string;
    /**
     * @param param0
     * @returns
     */
    static getPath({ root, fname }: {
        root: string;
        fname: string;
    }): string;
    /**
     @deprecated
     */
    static getSchemaModuleByFnameV4({ fname, schemas, wsRoot, vault, }: {
        fname: string;
        schemas: SchemaModuleDict | SchemaModuleProps[];
        wsRoot: string;
        vault: DVault;
    }): SchemaModuleProps | undefined;
    static getSchemaFromNote({ note, engine, }: {
        note: NoteProps;
        engine: DEngineClient;
    }): SchemaModuleProps | undefined;
    static hasSimplePattern: (schema: SchemaProps, opts?: {
        isNotNamespace?: boolean | undefined;
    } | undefined) => boolean;
    /**
     * Matcn and assign schemas to all nodes within
     * a domain
     *
     * @param domain
     * @param notes
     * @param schemas
     */
    static matchDomain(domain: NoteProps, notes: NotePropsDict, schemas: SchemaModuleDict): void;
    static matchDomainWithSchema(opts: {
        noteCandidates: NoteProps[];
        notes: NotePropsDict;
        schemaCandidates: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): void;
    static matchPath(opts: {
        notePath: string;
        schemaModDict: SchemaModuleDict;
    }): SchemaMatchResult | undefined;
    /**
     *
     * @param param0
     * @return
     *  - schemaModule
     *  - schema
     *  - namespace
     *  - notePath
     */
    static matchPathWithSchema({ notePath, matched, schemaCandidates, schemaModule, matchNamespace, }: {
        notePath: string;
        matched: string;
        schemaCandidates: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static matchNotePathWithSchemaAtLevel({ notePath, schemas, schemaModule, matchNamespace, }: {
        notePath: string;
        schemas: SchemaProps[];
        schemaModule: SchemaModuleProps;
        matchNamespace?: boolean;
    }): SchemaMatchResult | undefined;
    static serializeSchemaProps(props: SchemaProps | SchemaOpts): SchemaRaw;
    static serializeModuleProps(moduleProps: SchemaModuleProps): string;
    static serializeModuleOpts(moduleOpts: SchemaModuleOpts): string;
}
export {};
