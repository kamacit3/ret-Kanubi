"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConfigUtils = exports.PublishUtils = exports.TagUtils = exports.DefaultMap = exports.makeColorTranslucent = exports.randomColor = exports.isNotUndefined = exports.isBlockAnchor = exports.isNumeric = exports.getSlugger = exports.DUtils = void 0;
const github_slugger_1 = __importDefault(require("github-slugger"));
const lodash_1 = __importDefault(require("lodash"));
const minimatch_1 = __importDefault(require("minimatch"));
const querystring_1 = __importDefault(require("querystring"));
const semver_1 = __importDefault(require("semver"));
const colors_1 = require("./colors");
const intermediateConfigs_1 = require("./types/intermediateConfigs");
/**
 * Dendron utilities
 */
class DUtils {
    /**
     * Check if string is numeric
     * Credit to https://stackoverflow.com/questions/175739/built-in-way-in-javascript-to-check-if-a-string-is-a-valid-number
     * @param str
     * @returns
     */
    static isNumeric(str) {
        if (typeof str != "string")
            return false; // we only process strings!
        return (
        // @ts-ignore
        !isNaN(str) && // use type coercion to parse the _entirety_ of the string (`parseFloat` alone does not do this)...
            !isNaN(parseFloat(str))); // ...and ensure strings of whitespace fail
    }
}
exports.DUtils = DUtils;
DUtils.minimatch = minimatch_1.default;
DUtils.semver = semver_1.default;
DUtils.querystring = querystring_1.default;
const getSlugger = () => {
    return new github_slugger_1.default();
};
exports.getSlugger = getSlugger;
/**
 * determine if given parameter is numeric
 * https://stackoverflow.com/questions/18082/validate-decimal-numbers-in-javascript-isnumeric/1830844#1830844
 * @param n
 * @returns boolean
 */
const isNumeric = (n) => {
    return !isNaN(parseInt(n)) && isFinite(n);
};
exports.isNumeric = isNumeric;
function isBlockAnchor(anchor) {
    // not undefined, not an empty string, and the first character is ^
    return !!anchor && anchor[0] === "^";
}
exports.isBlockAnchor = isBlockAnchor;
/** A type guard for things that are not undefined.
 *
 * This is equivalent to !_.isUndefined(), except that it provides a type guard
 * ensuring the parameter is not undefined. This is useful when filtering:
 *
 * function foo(list: (string | undefined)[]) {
 *   const stringsOnly = list.filter(isNotUndefined);
 * }
 *
 * This will give stringsOnly the type string[]. Without the type guard, it would have
 * received the type (string | undefined)[] despite the fact that we filtered out undefined.
 */
function isNotUndefined(t) {
    return !lodash_1.default.isUndefined(t);
}
exports.isNotUndefined = isNotUndefined;
/** Calculates a basic integer hash for the given string.
 *
 * This is very unsafe, do not rely on this for anything where collisions are bad.
 *
 * Adapted from https://github.com/darkskyapp/string-hash.
 * Originally released under CC0 1.0 Universal (CC0 1.0) Public Domain Dedication.
 */
function basicStringHash(text) {
    // eslint-disable-next-line no-bitwise
    return (
    // eslint-disable-next-line no-bitwise
    lodash_1.default.reduce(text, (prev, curr) => {
        return prev + curr.charCodeAt(0);
    }, 5381) >>>
        // JavaScript does bitwise operations (like XOR, above) on 32-bit signed
        // integers. Since we want the results to be always positive, convert the
        // signed int to an unsigned by doing an unsigned bitshift.
        0);
}
/** Given a string, return a random color as a HTML color code.
 *
 * The same string will always generate the same color, and different strings will get different random colors.
 */
function randomColor(text) {
    return colors_1.COLORS_LIST[basicStringHash(text) % colors_1.COLORS_LIST.length];
}
exports.randomColor = randomColor;
/** Only some colors are recognized, other colors will be returned without being modified.
 *
 * Examples of recognized colors:
 * * #45AB35
 * * rgb(123, 23, 45)
 * * rgb(123 23 45)
 * * hsl(123, 23%, 45%)
 * * hsl(123 23% 45%)
 *
 * This function does not verify that the input colors are valid, but as long as a valid color is passed in
 * it will not generate an invalid color.
 *
 * @param color
 * @param translucency A number between 0 and 1, with 0 being fully transparent and 1 being fully opaque.
 * @returns
 */
function makeColorTranslucent(color, translucency) {
    let match = color.match(/^#[\dA-Fa-f]{6}$/);
    if (match)
        return `${color}${(translucency * 255).toString(16)}`;
    match = color.match(/^((rgb|hsl)\( *[\d.]+ *, *[\d.]+%? *, *[\d.]+%? *)\)$/);
    if (match)
        return `${match[1]}, ${translucency})`;
    match = color.match(/^((rgb|hsl)\( *[\d.]+ *[\d.]+%? *[\d.]+%? *)\)$/);
    if (match)
        return `${match[1]} / ${translucency})`;
    return color;
}
exports.makeColorTranslucent = makeColorTranslucent;
/** A map that automatically inserts a value provided by the factory when a missing key is looked up.
 *
 * Modeled after python's `defaultdict`.
 *
 * Mind that `get` may mutate the map, which may be unintuitive.
 *
 * Example usage:
 *
 * ```ts
 * const myMap = new DefaultMap<string, string[]>(() => []);
 * myMap.get("foo").push("bar");
 * ```
 */
class DefaultMap {
    constructor(factory) {
        this._internalMap = new Map();
        this._factory = factory;
    }
    get(key) {
        let value = this._internalMap.get(key);
        if (lodash_1.default.isUndefined(value)) {
            value = this._factory(key);
            this._internalMap.set(key, value);
        }
        return value;
    }
    set(key, value) {
        return this._internalMap.set(key, value);
    }
    has(key) {
        return this._internalMap.has(key);
    }
    keys() {
        return this._internalMap.keys();
    }
    values() {
        return this._internalMap.values();
    }
    entries() {
        return this._internalMap.entries();
    }
    delete(key) {
        return this._internalMap.delete(key);
    }
    get size() {
        return this._internalMap.size;
    }
}
exports.DefaultMap = DefaultMap;
class TagUtils {
    /** Removes `oldTag` from the frontmatter tags of `note` and replaces it with `newTag`, if any. */
    static replaceTag({ note, oldTag, newTag, }) {
        if (lodash_1.default.isUndefined(note.tags) || lodash_1.default.isString(note.tags)) {
            note.tags = newTag;
        }
        else {
            const index = lodash_1.default.findIndex(note.tags, (tag) => tag === oldTag);
            if (newTag) {
                if (index >= 0) {
                    note.tags[index] = newTag;
                }
                else {
                    // Weird, can't find the old tag. Add the new one anyway.
                    note.tags.push(newTag);
                }
            }
            else {
                lodash_1.default.pull(note.tags, oldTag);
            }
        }
    }
}
exports.TagUtils = TagUtils;
class PublishUtils {
    static getSEOPropsFromConfig(config) {
        const { title, twitter, description: excerpt } = config.site;
        return {
            title,
            twitter,
            excerpt,
        };
    }
    static getSEOPropsFromNote(note) {
        const { title, created, updated, image } = note;
        const { excerpt, canonicalUrl, noindex, canonicalBaseUrl, twitter } = note.custom ? note.custom : {};
        return {
            title,
            excerpt,
            updated,
            created,
            canonicalBaseUrl,
            canonicalUrl,
            noindex,
            image,
            twitter,
        };
    }
}
exports.PublishUtils = PublishUtils;
class ConfigUtils {
    static usePrettyRef(config) {
        var _a;
        let usePrettyRefs = lodash_1.default.find([config === null || config === void 0 ? void 0 : config.usePrettyRefs, (_a = config === null || config === void 0 ? void 0 : config.site) === null || _a === void 0 ? void 0 : _a.usePrettyRefs], (ent) => !lodash_1.default.isUndefined(ent));
        if (lodash_1.default.isUndefined(usePrettyRefs)) {
            usePrettyRefs = true;
        }
        return usePrettyRefs;
    }
    static genDefaultConfig() {
        const common = {
            useFMTitle: true,
            useNoteTitleForLink: true,
            noLegacyNoteRef: true,
            mermaid: true,
            useKatex: true,
            usePrettyRefs: true,
            dev: {
                enablePreviewV2: true,
            },
            site: {
                copyAssets: true,
                siteHierarchies: ["root"],
                siteRootDir: "docs",
                usePrettyRefs: true,
                title: "Dendron",
                description: "Personal knowledge space",
                siteLastModified: true,
                gh_edit_branch: "main",
            },
        };
        return {
            version: 3,
            ...common,
            commands: intermediateConfigs_1.genDefaultCommandConfig(),
            workspace: intermediateConfigs_1.genDefaultWorkspaceConfig(),
        };
    }
    // get
    static getProp(config, key) {
        const defaultConfig = ConfigUtils.genDefaultConfig();
        const configWithDefaults = lodash_1.default.defaultsDeep(config, defaultConfig);
        return configWithDefaults[key];
    }
    static getCommands(config) {
        return ConfigUtils.getProp(config, "commands");
    }
    static getWorkspace(config) {
        return ConfigUtils.getProp(config, "workspace");
    }
    static getVaults(config) {
        return ConfigUtils.getWorkspace(config).vaults;
    }
    static getHooks(config) {
        return ConfigUtils.getWorkspace(config).hooks;
    }
    static getJournal(config) {
        return ConfigUtils.getWorkspace(config).journal;
    }
    static getScratch(config) {
        return ConfigUtils.getWorkspace(config).scratch;
    }
    static getLookup(config) {
        return ConfigUtils.getCommands(config).lookup;
    }
    // set
    static setProp(config, key, value) {
        lodash_1.default.set(config, key, value);
    }
    static setCommandsProp(config, key, value) {
        const path = `commands.${key}`;
        lodash_1.default.set(config, path, value);
    }
    static setWorkspaceProp(config, key, value) {
        const path = `workspace.${key}`;
        lodash_1.default.set(config, path, value);
    }
    static setVaults(config, value) {
        ConfigUtils.setWorkspaceProp(config, "vaults", value);
    }
    static setNoteLookupProps(config, key, value) {
        const path = `commands.lookup.note.${key}`;
        lodash_1.default.set(config, path, value);
    }
    static setJournalProps(config, key, value) {
        const path = `workspace.journal.${key}`;
        lodash_1.default.set(config, path, value);
    }
    static setScratchProps(config, key, value) {
        const path = `workspace.scratch.${key}`;
        lodash_1.default.set(config, path, value);
    }
    static setHooks(config, value) {
        ConfigUtils.setWorkspaceProp(config, "hooks", value);
    }
}
exports.ConfigUtils = ConfigUtils;
//# sourceMappingURL=utils.js.map