"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MarkdownExportPodV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const engine_server_1 = require("@dendronhq/engine-server");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const __1 = require("../../..");
const __2 = require("../..");
const common_server_1 = require("@dendronhq/common-server");
class MarkdownExportPodV2 {
    constructor({ podConfig, engine, dendronConfig, }) {
        this._config = podConfig;
        this._engine = engine;
        this._dendronConfig = dendronConfig;
    }
    async exportNote(input) {
        if (this._config.destination === "clipboard") {
            const exportedNotes = this.renderNote(input);
            return common_all_1.ResponseUtil.createHappyResponse({
                data: {
                    exportedNotes,
                },
            });
        }
        return this.exportNotes([input]);
    }
    async exportNotes(input) {
        const { logger, dispose } = (0, common_server_1.createDisposableLogger)("MarkdownExportV2");
        const { destination, exportScope } = this._config;
        try {
            fs_extra_1.default.ensureDirSync(path_1.default.dirname(destination));
        }
        catch (err) {
            return {
                data: {},
                error: err,
            };
        }
        logger.debug({ msg: "pre:iterate_notes" });
        const errors = [];
        const result = await Promise.all(input.map(async (note) => {
            try {
                const body = this.renderNote(note);
                const hpath = this.dot2Slash(note.fname) + ".md";
                const vname = common_all_1.VaultUtils.getName(note.vault);
                const fpath = path_1.default.join(destination, vname, hpath);
                logger.debug({ fpath, msg: "pre:write" });
                await fs_extra_1.default.ensureDir(path_1.default.dirname(fpath));
                await fs_extra_1.default.writeFile(fpath, body);
                return note;
            }
            catch (err) {
                errors.push(err);
                return;
            }
        }));
        // Export Assets for vault and workspace exportScope
        const vaultsArray = [];
        switch (exportScope) {
            case __2.PodExportScope.Vault: {
                vaultsArray.push(input[0].vault);
                break;
            }
            case __2.PodExportScope.Workspace: {
                vaultsArray.push(...this._engine.vaults);
                break;
            }
        }
        await Promise.all(vaultsArray.map(async (vault) => {
            const destPath = path_1.default.join(destination, common_all_1.VaultUtils.getRelPath(vault), "assets");
            const srcPath = path_1.default.join(this._engine.wsRoot, common_all_1.VaultUtils.getRelPath(vault), "assets");
            if (fs_extra_1.default.pathExistsSync(srcPath)) {
                await fs_extra_1.default.copy(srcPath, destPath);
            }
        })).catch((err) => {
            errors.push(err);
        });
        dispose();
        const exportedNotes = result.filter((ent) => !lodash_1.default.isUndefined(ent));
        if (errors.length > 0) {
            return {
                data: {
                    exportedNotes,
                },
                error: new common_all_1.DendronCompositeError(errors),
            };
        }
        else {
            return common_all_1.ResponseUtil.createHappyResponse({
                data: {
                    exportedNotes,
                },
            });
        }
    }
    renderNote(input) {
        const { convertTagNotesToLinks = false, convertUserNotesToLinks = false, addFrontmatterTitle, } = this._config;
        const engine = this._engine;
        const overrideConfig = { ...this._engine.config };
        const workspaceConfig = common_all_1.ConfigUtils.getWorkspace(overrideConfig);
        workspaceConfig.enableUserTags = convertUserNotesToLinks;
        workspaceConfig.enableHashTags = convertTagNotesToLinks;
        if (!lodash_1.default.isUndefined(addFrontmatterTitle)) {
            const previewConfig = common_all_1.ConfigUtils.getPreview(overrideConfig);
            previewConfig.enableFMTitle = addFrontmatterTitle;
        }
        let remark = engine_server_1.MDUtilsV4.procFull({
            dest: engine_server_1.DendronASTDest.MD_REGULAR,
            config: {
                ...overrideConfig,
                usePrettyRefs: false,
            },
            engine,
            fname: input.fname,
            vault: input.vault,
            shouldApplyPublishRules: false,
            blockAnchorsOpts: { hideBlockAnchors: true },
        });
        if (this._config.wikiLinkToURL && !lodash_1.default.isUndefined(this._dendronConfig)) {
            remark = remark.use(engine_server_1.RemarkUtils.convertWikiLinkToNoteUrl(input, [], this._engine, this._dendronConfig));
        }
        else {
            remark = remark.use(engine_server_1.RemarkUtils.convertLinksFromDotNotation(input, []));
        }
        const out = remark.processSync(input.body).toString();
        return lodash_1.default.trim(out);
    }
    dot2Slash(fname) {
        const hierarchy = fname.split(".");
        return path_1.default.join(...hierarchy);
    }
    static config() {
        return __1.ConfigFileUtils.createExportConfig({
            required: ["destination"],
            properties: {
                wikiLinkToURL: {
                    description: "How to convert the wikilinks",
                    type: "boolean",
                    default: false,
                    nullable: true,
                },
                destination: {
                    description: "export destination. Specify either a file path or 'clipboard' to export to your clipboard",
                    type: "string",
                },
                convertTagNotesToLinks: {
                    type: "boolean",
                    default: false,
                    nullable: true,
                },
                convertUserNotesToLinks: {
                    type: "boolean",
                    default: false,
                    nullable: true,
                },
                addFrontmatterTitle: {
                    type: "boolean",
                    nullable: true,
                },
            },
        });
    }
}
exports.MarkdownExportPodV2 = MarkdownExportPodV2;
//# sourceMappingURL=MarkdownExportPodV2.js.map