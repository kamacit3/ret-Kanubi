"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkspaceUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
class WorkspaceUtils {
    /** Finds the workspace type using the VSCode plugin workspace variables. */
    static async getWorkspaceType({ workspaceFolders, workspaceFile, }) {
        if (!lodash_1.default.isUndefined(workspaceFile) &&
            path_1.default.basename(workspaceFile.fsPath) === common_all_1.CONSTANTS.DENDRON_WS_NAME) {
            return common_all_1.WorkspaceType.CODE;
        }
        if (!lodash_1.default.isUndefined(workspaceFolders)) {
            const rootFolder = await this.findWSRootsInWorkspaceFolders(workspaceFolders);
            if (!lodash_1.default.isEmpty(rootFolder))
                return common_all_1.WorkspaceType.NATIVE;
        }
        return common_all_1.WorkspaceType.NONE;
    }
    /** Finds the workspace type by analyzing the given directory. Use if plugin is not available.
     * @returns WorkspaceType
     */
    static async getWorkspaceTypeFromDir(dir) {
        if (fs_extra_1.default.pathExistsSync(path_1.default.join(dir, common_all_1.CONSTANTS.DENDRON_WS_NAME))) {
            return common_all_1.WorkspaceType.CODE;
        }
        const wsRoot = await (0, common_server_1.findDownTo)({
            base: dir,
            fname: common_all_1.CONSTANTS.DENDRON_CONFIG_FILE,
            returnDirPath: true,
        });
        if (!wsRoot)
            return common_all_1.WorkspaceType.NONE;
        if (fs_extra_1.default.pathExistsSync(path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_CONFIG_FILE))) {
            return common_all_1.WorkspaceType.NATIVE;
        }
        return common_all_1.WorkspaceType.NONE;
    }
    /**
     * Find wsRoot if exists
     * @returns
     */
    static findWSRoot() {
        const cwd = process.cwd();
        const configPath = (0, common_server_1.findUpTo)({
            base: cwd,
            fname: "dendron.yml",
            maxLvl: 3,
            returnDirPath: true,
        });
        return configPath;
    }
    static async findWSRootsInWorkspaceFolders(workspaceFolders) {
        const folders = (0, common_server_1.uniqueOutermostFolders)(workspaceFolders.map((folder) => folder.uri.fsPath));
        const dendronWorkspaceFolders = await Promise.all(folders.map((folder) => (0, common_server_1.findDownTo)({
            base: folder,
            fname: common_all_1.CONSTANTS.DENDRON_CONFIG_FILE,
            returnDirPath: true,
        })));
        return dendronWorkspaceFolders.filter(common_all_1.isNotUndefined);
    }
    static isNativeWorkspace(workspace) {
        return workspace.type === common_all_1.WorkspaceType.NATIVE;
    }
    /**
     * Check if path is in workspace
     * @returns
     */
    static isPathInWorkspace({ wsRoot, vaults, fpath, }) {
        try {
            common_all_1.VaultUtils.getVaultByFilePath({
                vaults,
                wsRoot,
                fsPath: fpath,
            });
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * Return true if contents of note is different from engine
     * @param param0
     * @returns
     */
    static noteContentChanged({ content, note, }) {
        const noteHash = (0, common_server_1.genHash)(content);
        if (lodash_1.default.isUndefined(note.contentHash)) {
            return true;
        }
        return noteHash !== note.contentHash;
    }
    /**
     * Generate url for given note or return `undefined` if no url is specified
     * @param opts
     *
     */
    static getNoteUrl(opts) {
        var _a;
        const { config, note, anchor, vault } = opts;
        let { urlRoot } = opts;
        const notePrefix = "notes";
        /**
         * set to true if index node, don't append id at the end
         */
        let isIndex = false;
        const seeds = common_all_1.ConfigUtils.getWorkspace(config).seeds;
        if (vault.seed) {
            if (seeds && seeds[vault.seed]) {
                const maybeSite = (_a = seeds[vault.seed]) === null || _a === void 0 ? void 0 : _a.site;
                if (maybeSite) {
                    urlRoot = maybeSite.url;
                    if (!lodash_1.default.isUndefined(note)) {
                        // if custom index is set, match against that, otherwise `root` is default index
                        isIndex = maybeSite.index
                            ? note.fname === maybeSite.index
                            : common_all_1.DNodeUtils.isRoot(note);
                    }
                }
            }
        }
        let root = "";
        if (!lodash_1.default.isUndefined(urlRoot)) {
            root = urlRoot;
        }
        else {
            // assume github
            throw new common_all_1.DendronError({ message: "not implemented" });
        }
        let link = isIndex ? root : [root, notePrefix, note.id + ".html"].join("/");
        if (anchor) {
            if (!(0, common_all_1.isBlockAnchor)(anchor)) {
                link += `#${(0, common_all_1.getSlugger)().slug(anchor)}`;
            }
            else {
                link += `#${anchor}`;
            }
        }
        return link;
    }
}
exports.WorkspaceUtils = WorkspaceUtils;
//# sourceMappingURL=utils.js.map