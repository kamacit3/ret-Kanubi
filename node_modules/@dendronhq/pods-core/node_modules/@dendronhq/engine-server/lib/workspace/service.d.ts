import { DEngineClient, Disposable, DUser, DVault, DVaultSync, DWorkspace, DWorkspaceEntry, InstallStatus, IntermediateDendronConfig, WorkspaceSettings } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
import { MigrationChangeSetStatus } from "../migrations";
import { SeedService } from "../seed";
import { IWorkspaceService, SyncActionResult } from "./workspaceServiceInterface";
export declare type PathExistBehavior = "delete" | "abort" | "continue";
export declare type WorkspaceServiceCreateOpts = {
    wsRoot: string;
    vaults?: DVault[];
    /**
     * create dendron.code-workspace file
     */
    createCodeWorkspace?: boolean;
};
export declare type WorkspaceServiceOpts = {
    wsRoot: string;
    seedService?: SeedService;
};
declare type UrlTransformerFunc = (url: string) => string;
declare type AddRemoveCommonOpts = {
    /**
     * Default: true
     */
    updateConfig?: boolean;
    /**
     * Default: false
     */
    updateWorkspace?: boolean;
    /**
     * Method to run immediately before updating the workspace file - this is
     * useful as updating the workspace file while it's open will sometimes cause
     * the window to reload and the plugin to restart
     */
    onUpdatingWorkspace?: () => Promise<void>;
    /**
     * Method to run immediately after updating the workspace file
     */
    onUpdatedWorkspace?: () => Promise<void>;
};
/** You **must** dispose workspace services you create, otherwise you risk leaking file descriptors which may lead to crashes. */
export declare class WorkspaceService implements Disposable, IWorkspaceService {
    logger: DLogger;
    private loggerDispose;
    protected _seedService: SeedService;
    static isNewVersionGreater({ oldVersion, newVersion, }: {
        oldVersion: string;
        newVersion: string;
    }): boolean;
    static isWorkspaceVault(fpath: string): Promise<boolean>;
    wsRoot: string;
    /** Reminder: you **must** dispose workspace services you create, otherwise you risk leaking file descriptors which may lead to crashes. */
    constructor({ wsRoot, seedService }: WorkspaceServiceOpts);
    dispose(): void;
    get user(): DUser;
    static getOrCreateConfig(wsRoot: string): IntermediateDendronConfig;
    get config(): IntermediateDendronConfig;
    get dendronRoot(): string;
    get seedService(): SeedService;
    setConfig(config: IntermediateDendronConfig): Promise<void>;
    setWorkspaceConfig(config: WorkspaceSettings): void;
    getWorkspaceConfig(): WorkspaceSettings | undefined;
    /**
     *
     * @param param0
     * @returns `{vaults}` that have been added
     */
    addWorkspace({ workspace }: {
        workspace: DWorkspace;
    }): Promise<{
        vaults: DVault[];
    }>;
    /**
     *
     *
     * @param opts.vault - {@link DVault} to add to workspace
     * @param opts.config - if passed it, make modifications on passed in config instead of {wsRoot}/dendron.yml
     * @param opts.writeConfig - default: true, add to dendron.yml
     * @param opts.addToWorkspace - default: false, add to dendron.code-workspace. Make sure to keep false for Native workspaces.
     * @returns
     */
    addVault(opts: {
        vault: DVault;
        config?: IntermediateDendronConfig;
    } & AddRemoveCommonOpts): Promise<DVault>;
    /**
     * Create vault files if it does not exist
     * @param opts.noAddToConfig: don't add to dendron.yml
     * @param opts.addToCodeWorkspace: add to dendron.code-workspace
     * @returns void
     *
     * Effects:
     *   - updates `dendron.yml` if `noAddToConfig` is not set
     *   - create directory
     *   - create root note and root schema
     */
    createVault(opts: {
        noAddToConfig?: boolean;
        addToCodeWorkspace?: boolean;
    } & Parameters<WorkspaceService["addVault"]>[0]): Promise<DVault>;
    /** Converts a local vault to a remote vault, with `remoteUrl` as the upstream URL. */
    convertVaultRemote({ wsRoot, vault: targetVault, remoteUrl, }: {
        wsRoot: string;
        vault: DVault;
        remoteUrl: string;
    }): Promise<{
        remote: string;
        branch: string;
    }>;
    /** Converts a remote vault to a local vault. */
    convertVaultLocal({ wsRoot, vault: targetVault, }: {
        wsRoot: string;
        vault: DVault;
    }): Promise<void>;
    /** For vaults in the same repository, ensure that their sync configurations do not conflict. Returns the coordinated sync config. */
    verifyVaultSyncConfigs(vaults: DVault[]): DVaultSync | undefined;
    /** Checks if a given git command should be used on the vault based on user configuration.
     *
     * @param command The git command that we want to perform.
     * @param repo The location of the repository containing the vaults.
     * @param vaults The vaults on which the operation is being performed on.
     * @returns true if the command can be performed, false otherwise.
     */
    shouldVaultsSync(command: "commit" | "push" | "pull", [root, vaults]: [string, DVault[]]): Promise<boolean>;
    private static generateCommitMessage;
    commitAndAddAll({ engine, }: {
        engine: DEngineClient;
    }): Promise<SyncActionResult[]>;
    /**
     * Initialize all remote vaults
     * @param opts
     * @returns
     */
    initialize(opts?: {
        onSyncVaultsProgress: any;
        onSyncVaultsEnd: any;
    }): Promise<boolean>;
    /**
     * Remove vaults. Currently doesn't delete any files.
     * @param param0
     */
    removeVault(opts: {
        vault: DVault;
    } & AddRemoveCommonOpts): Promise<void>;
    createConfig(): void;
    /**
     * Initialize workspace with specified vaults
     * Files and folders created:
     * wsRoot/
     * - .gitignore
     * - dendron.yml
     * - {vaults}/
     *   - root.md
     *   - root.schema.yml
     *
     * NOTE: dendron.yml only gets created if you are adding a workspace...
     * @param opts
     */
    static createWorkspace(opts: WorkspaceServiceCreateOpts): Promise<WorkspaceService>;
    static createFromConfig(opts: {
        wsRoot: string;
    }): Promise<void>;
    addVaultToCodeWorkspace(vault: DVault): Promise<void>;
    /**
     * Used in createFromConfig
     */
    cloneVaultWithAccessToken(opts: {
        vault: DVault;
    }): Promise<void>;
    /**
     * Clone a vault from a remote source
     * @param opts.vault vaults field
     * @param opts.urlTransformer modify the git url
     */
    cloneVault(opts: {
        vault: DVault;
        urlTransformer?: UrlTransformerFunc;
    }): Promise<string>;
    cloneWorkspace(opts: {
        wsName: string;
        workspace: DWorkspaceEntry;
        wsRoot: string;
        urlTransformer?: UrlTransformerFunc;
    }): Promise<string>;
    getVaultRepo(vault: DVault): Promise<string | undefined>;
    getAllReposVaults(): Promise<Map<string, DVault[]>>;
    getAllRepos(): Promise<string[]>;
    /**
     * Check if a path belongs to a workspace
     @deprecated - use {@link WorkspaceUtils.isPathInWorkspace}
     */
    isPathInWorkspace(fpath: string): boolean;
    pullVault(opts: {
        vault: DVault;
    }): Promise<string>;
    /** Returns the list of vaults that were attempted to be pulled, even if there was nothing to pull. */
    pullVaults(): Promise<SyncActionResult[]>;
    /** Returns the list of vaults that were attempted to be pushed, even if there was nothing to push. */
    pushVaults(): Promise<SyncActionResult[]>;
    /**
     * Remove all vault caches in workspace
     */
    removeVaultCaches(): Promise<void>;
    /**
     * See if there's anythign we need to change with the configuration
     */
    runMigrationsIfNecessary({ forceUpgrade, workspaceInstallStatus, currentVersion, previousVersion, dendronConfig, wsConfig, }: {
        forceUpgrade?: boolean;
        workspaceInstallStatus: InstallStatus;
        currentVersion: string;
        previousVersion: string;
        dendronConfig: IntermediateDendronConfig;
        wsConfig?: WorkspaceSettings;
    }): Promise<MigrationChangeSetStatus[]>;
    /**
     * Check major version of configuration.
     * Because Dendron workspace relies on major version to be the same, we force a migration if that's not
     * the case
     */
    runConfigMigrationIfNecessary({ currentVersion, dendronConfig, }: {
        currentVersion: string;
        dendronConfig: IntermediateDendronConfig;
    }): Promise<MigrationChangeSetStatus[]>;
    /**
     * Make sure all vaults are present on file system
     * @param fetchAndPull for repositories that exist, should we also do a fetch? default: false
     * @param skipPrivate skip cloning and pulling of private vaults. default: false
     */
    syncVaults(opts: {
        config: IntermediateDendronConfig;
        progressIndicator?: () => void;
        urlTransformer?: UrlTransformerFunc;
        fetchAndPull?: boolean;
        skipPrivate?: boolean;
    }): Promise<{
        didClone: boolean;
    }>;
    writePort(port: number): void;
    writeMeta(opts: {
        version: string;
    }): void;
}
export {};
