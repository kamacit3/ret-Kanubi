import { BulkAddNoteOpts, IntermediateDendronConfig, DendronError, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DEngineInitSchemaResp, DLink, DNoteAnchorPositioned, DStore, DVault, EngineDeleteOptsV2, EngineUpdateNodesOptsV2, EngineWriteOptsV2, NoteChangeEntry, NoteProps, NotePropsDict, NoteFNamesDict, NotesCache, NotesCacheEntryMap, RenameNoteOpts, RenameNotePayload, SchemaModuleDict, SchemaModuleProps, StoreDeleteNoteResp, WriteNoteResp } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
export declare type FileMeta = {
    prefix: string;
    fpath: string;
};
export declare type FileMetaDict = {
    [key: string]: FileMeta[];
};
export declare class FileStorage implements DStore {
    vaults: DVault[];
    /**
     * Warning: currently this note dictionary contains backlink data that gets
     * populated upon initialization. However, the update note operations do not change
     * the backlink data in this dictionary hence it starts to contain stale backlink data.
     *  */
    notes: NotePropsDict;
    noteFnames: NoteFNamesDict;
    schemas: SchemaModuleDict;
    notesCache: NotesCache;
    logger: DLogger;
    links: DLink[];
    anchors: DNoteAnchorPositioned[];
    wsRoot: string;
    configRoot: string;
    config: IntermediateDendronConfig;
    private engine;
    constructor(props: {
        engine: DEngineClient;
        logger: DLogger;
    });
    init(): Promise<DEngineInitResp>;
    static createMalformedSchemaError(resp: DEngineInitSchemaResp): DendronError;
    deleteNote(id: string, opts?: EngineDeleteOptsV2): Promise<StoreDeleteNoteResp>;
    deleteSchema(id: string, opts?: EngineDeleteOptsV2): Promise<DEngineDeleteSchemaResp>;
    initSchema(): Promise<DEngineInitSchemaResp>;
    _initSchema(vault: DVault): Promise<{
        data: SchemaModuleProps[];
        errors: any[];
    }>;
    initNotes(): Promise<{
        notes: NoteProps[];
        errors: DendronError[];
    }>;
    /** Adds backlinks mutating 'allNotes' argument in place. */
    private _addBacklinks;
    private _addBacklinksImpl;
    _addLinkCandidates(allNotes: NoteProps[]): void[];
    _initNotes(vault: DVault): Promise<{
        notes: NoteProps[];
        cacheUpdates: NotesCacheEntryMap;
        cache: NotesCache;
        errors: DendronError[];
    }>;
    bulkAddNotes(opts: BulkAddNoteOpts): Promise<{
        error: null;
        data: NoteChangeEntry[];
    }>;
    private referenceRangeParts;
    /**
     * Update the links inside this note that need to be updated for the rename from `oldLoc` to `newLoc`
     * Will update the note in place
     */
    private processNoteChangedByRename;
    renameNote(opts: RenameNoteOpts): Promise<RenameNotePayload>;
    /** Utility function to write many notes concurrently. */
    private writeManyNotes;
    /**
     * Update a note. If note exists, call {@link NoteUtils.hydrate} to populate new note with parent/children properties
     * of the existing note
     *
     * If {@link newNode} is set, set the {@link NoteProps["parent"]} property and create stubs as necessary
     *
     * @param note
     * @param opts
     * @returns
     */
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<NoteProps>;
    updateSchema(schemaModule: SchemaModuleProps): Promise<void>;
    /**
     * Write a new note. Also take care of updating logic of parents and children if new note replaces an existing note
     */
    _writeNewNote({ note, existingNote, opts, }: {
        note: NoteProps;
        existingNote?: NoteProps;
        opts?: EngineWriteOptsV2;
    }): Promise<NoteProps[]>;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    writeSchema(schemaModule: SchemaModuleProps): Promise<void>;
}
