"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userTags = exports.matchUserTag = exports.USERTAG_REGEX_LOOSE = exports.USERTAG_REGEX = void 0;
const common_all_1 = require("@dendronhq/common-all");
const types_1 = require("../types");
const utils_1 = require("../utils");
const hashtag_1 = require("./hashtag");
const markdown_1 = require("../../markdown");
/** Can have period in the middle */
const GOOD_MIDDLE_CHARACTER = `[^#@|\\[\\]\\s${hashtag_1.PUNCTUATION_MARKS}]`;
/** Can't have period in the end */
const GOOD_END_CHARACTER = `[^#@|\\[\\]\\s.${hashtag_1.PUNCTUATION_MARKS}]`;
/** User tags have the form @Lovelace, or @Hamilton.Margaret, or @7of9.
 *
 * User tags are also not allowed to contain any punctuation or quotation marks, and will not include a trailing dot
 * This allows them to be more easily mixed into text, for example:
 *
 * ```
 * Please contact @Ben.Barres.
 * ```
 *
 * Here, the tag is `#important` without the following comma.
 */
exports.USERTAG_REGEX = new RegExp(
// Avoid matching it if there's a non-whitespace character before (like foo@example.com)
`^(?<!\\S)(?<tagSymbol>@)(?<tagContents>` +
    `${GOOD_MIDDLE_CHARACTER}*` +
    `${GOOD_END_CHARACTER}` +
    `)`);
/** Same as `USERTAG_REGEX`, except that that it doesn't have to be at the start of the string. */
exports.USERTAG_REGEX_LOOSE = new RegExp(
// Avoid matching it if there's a non-whitespace character before (like foo@example.com)
`(?<!\\S)(?<userTag>@)(?<userTagContents>` +
    `${GOOD_MIDDLE_CHARACTER}*` +
    `${GOOD_END_CHARACTER}` +
    `)`);
/**
 *
 * @param text The text to check if it matches an hashtag.
 * @param matchLoose If true, a hashtag anywhere in the string will match. Otherwise the string must contain only the anchor.
 * @returns The identifier for the matched hashtag, or undefined if it did not match.
 */
const matchUserTag = (text, matchLoose = true) => {
    const match = (matchLoose ? exports.USERTAG_REGEX : exports.USERTAG_REGEX_LOOSE).exec(text);
    if (match && match.groups)
        return match.groups.tagContents || match.groups.userTagContents;
    return undefined;
};
exports.matchUserTag = matchUserTag;
const plugin = function plugin(opts) {
    attachParser(this);
    if (this.Compiler != null) {
        attachCompiler(this, opts);
    }
};
exports.userTags = plugin;
function attachParser(proc) {
    function locator(value, fromIndex) {
        return value.indexOf("@", fromIndex);
    }
    function inlineTokenizer(eat, value) {
        var _a;
        const { enableUserTags } = common_all_1.ConfigUtils.getWorkspace(markdown_1.MDUtilsV5.getProcData(proc).config);
        if (enableUserTags === false)
            return;
        const match = exports.USERTAG_REGEX.exec(value);
        if (match && ((_a = match.groups) === null || _a === void 0 ? void 0 : _a.tagContents)) {
            return eat(match[0])({
                type: types_1.DendronASTTypes.USERTAG,
                // @ts-ignore
                value: match[0],
                fname: `${common_all_1.USERS_HIERARCHY}${match.groups.tagContents}`,
            });
        }
        return;
    }
    inlineTokenizer.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.users = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "users");
}
function attachCompiler(proc, _opts) {
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    if (visitors) {
        visitors.usertag = (node) => {
            var _a;
            const { dest } = utils_1.MDUtilsV4.getDendronData(proc);
            const prefix = ((_a = utils_1.MDUtilsV4.getProcOpts(proc).wikiLinksOpts) === null || _a === void 0 ? void 0 : _a.prefix) || "";
            switch (dest) {
                case types_1.DendronASTDest.MD_DENDRON:
                    return node.value;
                case types_1.DendronASTDest.MD_REGULAR:
                case types_1.DendronASTDest.MD_ENHANCED_PREVIEW:
                    return `[${node.value}](${prefix}${node.fname})`;
                default:
                    throw new common_all_1.DendronError({ message: "Unable to render user tag" });
            }
        };
    }
}
//# sourceMappingURL=userTags.js.map