import { IntermediateDendronConfig, DendronError, DEngineClient, DNoteLoc, DVault, GetNoteOpts, getSlugger, NotePropsDict, NoteProps } from "@dendronhq/common-all";
import remark from "remark";
import { default as unified, default as Unified, Processor } from "unified";
import { Node, Parent } from "unist";
import { DendronPubOpts } from "./remark/dendronPub";
import { NoteRefsOptsV2 } from "./remark/noteRefsV2";
import { WikiLinksOpts } from "./remark/wikiLinks";
import { BlockAnchorOpts } from "./remark/blockAnchors";
import { DendronASTData, DendronASTDest, VaultMissingBehavior } from "./types";
declare type ProcOpts = {
    engine: DEngineClient;
};
declare type ProcParseOpts = {
    dest: DendronASTDest;
    fname: string;
} & ProcOpts;
declare type ProcOptsFull = ProcOpts & {
    dest: DendronASTDest;
    shouldApplyPublishRules?: boolean;
    vault: DVault;
    fname: string;
    config?: IntermediateDendronConfig;
    mathOpts?: {
        katex?: boolean;
    };
    mermaid?: boolean;
    noteRefLvl?: number;
    usePrettyRefs?: boolean;
    wikiLinksOpts?: WikiLinksOpts;
    publishOpts?: DendronPubOpts;
    blockAnchorsOpts?: BlockAnchorOpts;
    noteRefOpts?: NoteRefsOptsV2;
};
declare type ProcDendron = ProcOpts & {
    dest: DendronASTDest;
    vault: DVault;
    fname: string;
    configOverride?: IntermediateDendronConfig;
};
export declare const renderFromNoteProps: (opts: {
    notes: NotePropsDict;
} & GetNoteOpts) => string;
export declare const renderFromNote: (opts: {
    note: NoteProps;
}) => string;
export declare type ParentWithIndex = {
    ancestor: Parent;
    index: number;
};
declare type VisitorParentsIndices = ({ node, index, ancestors, }: {
    node: Node;
    index: number;
    ancestors: ParentWithIndex[];
}) => boolean | undefined | "skip";
/** @deprecated Please use {@link MDUtilsV5} instead. */
export declare class MDUtilsV4 {
    static getDendronData(proc: Processor): DendronASTData;
    /**
     * Get the vault name, either from processor or passed in vaultName
     * @param opts.vaultMissingBehavior how to respond if no vault is found. See {@link VaultMissingBehavior}
     */
    static getVault(proc: Processor, vaultName?: string, opts?: {
        vaultMissingBehavior?: VaultMissingBehavior;
    }): DVault;
    static getFM(proc: Processor): any;
    static setDendronData(proc: Processor, data: Partial<DendronASTData>): unified.Processor<unified.Settings>;
    static getEngineFromProc(proc: Unified.Processor): {
        error: DendronError | undefined;
        engine: DEngineClient;
    };
    static getNoteRefLvl(proc: Unified.Processor): number;
    static getProcOpts(proc: Unified.Processor): ProcOptsFull;
    static setEngine(proc: Unified.Processor, engine: DEngineClient): void;
    static setNoteRefLvl(proc: Unified.Processor, lvl: number): void;
    static setProcOpts(proc: Unified.Processor, data: Partial<ProcOptsFull>): unified.Processor<unified.Settings>;
    /**
     * Get remark processor with a few default plugins
     */
    static remark(): unified.Processor<remark.PartialRemarkOptions>;
    /**
     * Simple proc just for parsing docs
     */
    static procParse(opts: ProcParseOpts): unified.Processor<remark.PartialRemarkOptions>;
    /**
     * Used to build other proces from
     */
    static proc(opts: ProcOpts): unified.Processor<remark.PartialRemarkOptions>;
    static procFull(opts: ProcOptsFull): unified.Processor<remark.PartialRemarkOptions>;
    /**
     * Just parse markdown
     */
    static procRemark(opts: {
        proc?: Processor;
    }): unified.Processor<unified.Settings>;
    /**
     * markdown -> html
     */
    static procRehype(opts: {
        proc?: Processor;
        mdPlugins?: Processor[];
        mathjax?: boolean;
        useLinks?: boolean;
    }): unified.Processor<unified.Settings>;
    /**
     * Used to refactor text
     */
    static procTransform(procOpts: Omit<ProcOptsFull, "dest">, transformOpts: {
        from: DNoteLoc;
        to: DNoteLoc;
    }): unified.Processor<remark.PartialRemarkOptions>;
    static procHTML(procOpts: Omit<ProcOptsFull, "dest"> & {
        noteIndex: NoteProps;
        useLinks?: boolean;
    }): unified.Processor<unified.Settings>;
    /**
     * Return a dendron processor
     * @param opts
     * @returns
     */
    static procDendron(opts: ProcDendron): unified.Processor<remark.PartialRemarkOptions>;
}
/** Contains functions that help dealing with MarkDown Abstract Syntax Trees. */
export declare class MdastUtils {
    static genMDMsg(msg: string): Parent;
    static genMDErrorMsg(msg: string): Parent;
    /** Find the index of the list element for which the predicate `fn` returns true.
     *
     * @returns The index where the element was found, -1 otherwise.
     */
    static findIndex<T>(array: T[], fn: (node: T, index: number) => boolean): number;
    /** A simplified and adapted version of visitParents from unist-utils-visit-parents, that also keeps track of indices of the ancestors as well.
     *
     * The limitations are:
     * * `test`, if used, can only be a string representing the type of the node that you want to visit
     * * Adding or removing siblings is undefined behavior
     * Please modify this function to add support for these if needed.
     */
    static visitParentsIndices({ nodes, test, visitor, }: {
        nodes: Node[];
        test?: string;
        visitor: VisitorParentsIndices;
    }): void;
    /** Similar to `unist-utils-visit`, but allows async visitors.
     *
     * Children are visited in-order, not concurrently.
     *
     * @param test Use an empty list to visit all nodes, otherwise specify node types to be visited.
     * @param visitor Similar to `unist-util-visit`, returning true or undefined continues traversal, false stops traversal, and "skip" skips the children of that node.
     *
     * Depth-first pre-order traversal, same as `unist-util-visits`.
     */
    static visitAsync(tree: Node, test: string[], visitor: (node: Node) => void | undefined | boolean | "skip" | Promise<void | undefined | boolean | "skip">): Promise<void>;
    static matchHeading(node: Node, text: string, opts: {
        depth?: number;
        slugger: ReturnType<typeof getSlugger>;
    }): boolean;
}
export declare class PublishUtils {
    static getAbsUrlForAsset(opts: {
        suffix?: string;
        config: IntermediateDendronConfig;
    }): string;
    static getSiteUrl: (config: IntermediateDendronConfig) => string | undefined;
}
export {};
