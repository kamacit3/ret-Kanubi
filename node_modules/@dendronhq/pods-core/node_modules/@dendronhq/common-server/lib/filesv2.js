"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tmp = exports.findNonNoteFile = exports.fileExists = exports.dot2Slash = exports.writeJSONWithComments = exports.vault2Path = exports.tmpDir = exports.readJSONWithCommentsSync = exports.readJSONWithComments = exports.assignJSONWithComment = exports.schemaModuleProps2File = exports.schemaModuleOpts2File = exports.note2File = exports.uniqueOutermostFolders = exports.isInsidePath = exports.findDownTo = exports.WS_FILE_MAX_SEARCH_DEPTH = exports.findUpTo = exports.goUpTo = exports.note2String = exports.file2NoteWithCache = exports.file2Note = exports.string2Note = exports.string2Schema = exports.genHash = exports.file2Schema = exports.createFileWatcher = exports.COMMON_FOLDER_IGNORES = void 0;
const common_all_1 = require("@dendronhq/common-all");
const comment_json_1 = require("comment-json");
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const yamljs_1 = __importDefault(require("yamljs"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
// @ts-ignore
const tmp_1 = __importStar(require("tmp"));
exports.tmp = tmp_1.default;
const files_1 = require("./files");
const parser_1 = require("./parser");
const spark_md5_1 = __importDefault(require("spark-md5"));
const anymatch_1 = __importDefault(require("anymatch"));
/** Dendron should ignore any of these folders when watching or searching folders.
 *
 * These folders are unlikely to contain anything Dendron would like to find, so we can ignore them.
 *
 * Example usage:
 * ```ts
 * if (!anymatch(COMMON_FOLDER_IGNORES, folder)) {
 *   // Good folder!
 * }
 * ```
 */
exports.COMMON_FOLDER_IGNORES = [
    "**/.*/**",
    "**/node_modules/**",
    "**/.git/**",
    "**/__pycache__/**", // python
];
async function createFileWatcher(opts) {
    const { numTries, fpath, onChange } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    const didCreate = false;
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            return setTimeout(() => {
                resolve(_createFileWatcher({
                    ...opts,
                    numTries: numTries - 1,
                    isCreate: true,
                }));
            }, 3000);
        }
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate });
    });
}
exports.createFileWatcher = createFileWatcher;
async function _createFileWatcher(opts) {
    const { numTries, fpath, onChange, onCreate } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    if (numTries <= 0) {
        throw new common_all_1.DendronError({ message: "exceeded numTries" });
    }
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            console.log({ fpath, msg: "not exist" });
            return setTimeout(() => {
                resolve(createFileWatcher({ ...opts, numTries: numTries - 1 }));
            }, 3000);
        }
        await onCreate({ fpath });
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate: true });
    });
}
async function file2Schema(fpath, wsRoot) {
    const root = { fsPath: path_1.default.dirname(fpath) };
    const fname = path_1.default.basename(fpath, ".schema.yml");
    const schemaOpts = yamljs_1.default.parse(await fs_extra_1.default.readFile(fpath, { encoding: "utf8" }));
    return await parser_1.SchemaParserV2.parseRaw(schemaOpts, { root, fname, wsRoot });
}
exports.file2Schema = file2Schema;
function genHash(contents) {
    return spark_md5_1.default.hash(contents); // OR raw hash (binary string)
}
exports.genHash = genHash;
async function string2Schema({ vault, content, fname, wsRoot, }) {
    const schemaOpts = yamljs_1.default.parse(content);
    return await parser_1.SchemaParserV2.parseRaw(schemaOpts, {
        root: vault,
        fname,
        wsRoot,
    });
}
exports.string2Schema = string2Schema;
/**
 *
 * @param calculateHash - when set, add `contentHash` property to the note
 *  Default: false
 * @returns
 */
function string2Note({ content, fname, vault, calculateHash, }) {
    const options = {
        engines: {
            yaml: {
                parse: (s) => yamljs_1.default.parse(s),
                stringify: (s) => yamljs_1.default.stringify(s),
            },
        },
    };
    const { data, content: body } = (0, gray_matter_1.default)(content, options);
    const custom = common_all_1.DNodeUtils.getCustomProps(data);
    const contentHash = calculateHash ? genHash(content) : undefined;
    const note = common_all_1.DNodeUtils.create({
        ...data,
        custom,
        fname,
        body,
        type: "note",
        vault,
        contentHash,
    });
    return note;
}
exports.string2Note = string2Note;
function file2Note(fpath, vault, toLowercase) {
    const content = fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" });
    const { name } = path_1.default.parse(fpath);
    const fname = toLowercase ? name.toLowerCase() : name;
    return string2Note({ content, fname, vault });
}
exports.file2Note = file2Note;
function file2NoteWithCache({ fpath, vault, cache, toLowercase, }) {
    var _a;
    const content = fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" });
    const { name } = path_1.default.parse(fpath);
    const sig = genHash(content);
    const matchHash = ((_a = cache.notes[name]) === null || _a === void 0 ? void 0 : _a.hash) === sig;
    const fname = toLowercase ? name.toLowerCase() : name;
    let note;
    // if hash matches, note hasn't changed
    if (matchHash) {
        // since we don't store the note body in the cache file, we need to re-parse the body
        const capture = content.match(/^---[\s\S]+?---/);
        if (capture) {
            const offset = capture[0].length;
            const body = content.slice(offset + 1);
            // vault can change without note changing so we need to add this
            // add `contentHash` to this signature because its not saved with note
            note = { ...cache.notes[name].data, body, vault, contentHash: sig };
            return { note, matchHash, noteHash: sig };
        }
    }
    note = string2Note({ content, fname, vault });
    note.contentHash = sig;
    return { note, matchHash, noteHash: sig };
}
exports.file2NoteWithCache = file2NoteWithCache;
/** Read the contents of a note from the filesystem.
 *
 * Warning! The note contents may be out of date compared to changes in the editor.
 * Consider using `NoteUtils.serialize` instead.
 */
function note2String(opts) {
    const notePath = common_all_1.NoteUtils.getFullPath(opts);
    return fs_extra_1.default.readFile(notePath, { encoding: "utf8" });
}
exports.note2String = note2String;
/**
 * Go to dirname that {fname} is contained in
 * @param maxLvl? - default: 10
 @deprecated use {@link findUpTo}
 */
function goUpTo(opts) {
    let { fname, base, maxLvl } = lodash_1.default.defaults(opts, { maxLvl: 10 });
    const lvls = [];
    while (maxLvl > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_extra_1.default.existsSync(tryPath)) {
            return path_1.default.dirname(tryPath);
        }
        maxLvl -= 1;
        lvls.push("..");
    }
    throw Error(`no root found from ${base}`);
}
exports.goUpTo = goUpTo;
/**
 * Go to dirname that {fname} is contained in, going out (up the tree) from base.
 * @param maxLvl - default: 3
 * @param returnDirPath - return path to directory, default: false
 */
function findUpTo(opts) {
    const { fname, base, maxLvl, returnDirPath } = lodash_1.default.defaults(opts, {
        maxLvl: 3,
        returnDirPath: false,
    });
    const lvls = [];
    let acc = 0;
    while (maxLvl - acc > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_extra_1.default.existsSync(tryPath)) {
            return returnDirPath ? path_1.default.dirname(tryPath) : tryPath;
        }
        acc += 1;
        lvls.push("..");
    }
    return undefined;
}
exports.findUpTo = findUpTo;
exports.WS_FILE_MAX_SEARCH_DEPTH = 3;
/**
 * Go to dirname that {fname} is contained in, going in (deeper into tree) from base.
 * @param maxLvl Default 3, how deep to go down in the file tree. Keep in mind that the tree gets wider and this search becomes exponentially more expensive the deeper we go.
 * @param returnDirPath - return path to directory, default: false
 *
 * One warning: this will not search into folders starting with `.` to avoid searching through things like the `.git` folder.
 */
async function findDownTo(opts) {
    const { fname, base, maxLvl, returnDirPath } = {
        maxLvl: exports.WS_FILE_MAX_SEARCH_DEPTH,
        returnDirPath: false,
        ...opts,
    };
    const contents = await fs_extra_1.default.readdir(base);
    let found = contents.filter((foundFile) => foundFile === fname)[0];
    if (found) {
        found = path_1.default.join(base, found);
        return returnDirPath ? path_1.default.dirname(found) : found;
    }
    if (maxLvl > 1) {
        // Keep searching recursively
        return (await Promise.all(contents.map(async (folder) => {
            // Find the folders in the current folder
            const subfolder = await fs_extra_1.default.stat(path_1.default.join(base, folder));
            if (!subfolder.isDirectory())
                return;
            // Exclude folders starting with . to skip stuff like `.git`
            if ((0, anymatch_1.default)(exports.COMMON_FOLDER_IGNORES, folder))
                return;
            return findDownTo({
                ...opts,
                base: path_1.default.join(base, folder),
                maxLvl: maxLvl - 1,
            });
        }))).filter(common_all_1.isNotUndefined)[0];
    }
    return undefined;
}
exports.findDownTo = findDownTo;
/** Returns true if `inner` is inside of `outer`, and false otherwise.
 *
 * If `inner === outer`, then that also returns false.
 */
function isInsidePath(outer, inner) {
    // When going from `outer` to `inner`
    const relPath = path_1.default.relative(outer, inner);
    // If we have to leave `outer`, or if we have to switch to a
    // different drive with an absolute path, then `inner` can't be
    // inside `outer` (or `inner` and `outer` are identical)
    return (!relPath.startsWith("..") && !path_1.default.isAbsolute(relPath) && relPath !== "");
}
exports.isInsidePath = isInsidePath;
/** Returns the list of unique, outermost folders. No two folders returned are nested within each other. */
function uniqueOutermostFolders(folders) {
    // Avoid duplicates
    folders = lodash_1.default.uniq(folders);
    if (folders.length === 1)
        return folders;
    return folders.filter((currentFolder) => folders.every((otherFolder) => {
        // `currentFolder` is not inside any other folder
        return !isInsidePath(otherFolder, currentFolder);
    }));
}
exports.uniqueOutermostFolders = uniqueOutermostFolders;
function note2File({ note, vault, wsRoot, }) {
    const { fname } = note;
    const ext = ".md";
    const payload = common_all_1.NoteUtils.serialize(note);
    const vpath = (0, exports.vault2Path)({ vault, wsRoot });
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), payload);
}
exports.note2File = note2File;
function schemaModuleOpts2File(schemaFile, vaultPath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vaultPath, fname + ext), common_all_1.SchemaUtils.serializeModuleOpts(schemaFile));
}
exports.schemaModuleOpts2File = schemaModuleOpts2File;
function schemaModuleProps2File(schemaMProps, vpath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), common_all_1.SchemaUtils.serializeModuleProps(schemaMProps));
}
exports.schemaModuleProps2File = schemaModuleProps2File;
function assignJSONWithComment(jsonObj, dataToAdd) {
    return (0, comment_json_1.assign)({
        ...dataToAdd,
    }, jsonObj);
}
exports.assignJSONWithComment = assignJSONWithComment;
async function readJSONWithComments(fpath) {
    const content = await fs_extra_1.default.readFile(fpath);
    const obj = (0, comment_json_1.parse)(content.toString());
    return obj;
}
exports.readJSONWithComments = readJSONWithComments;
function readJSONWithCommentsSync(fpath) {
    const content = fs_extra_1.default.readFileSync(fpath);
    const obj = (0, comment_json_1.parse)(content.toString());
    return obj;
}
exports.readJSONWithCommentsSync = readJSONWithCommentsSync;
function tmpDir() {
    const dirPath = (0, tmp_1.dirSync)();
    return dirPath;
}
exports.tmpDir = tmpDir;
const vault2Path = ({ vault, wsRoot, }) => {
    return (0, files_1.resolvePath)(common_all_1.VaultUtils.getRelPath(vault), wsRoot);
};
exports.vault2Path = vault2Path;
function writeJSONWithComments(fpath, data) {
    const payload = (0, comment_json_1.stringify)(data, null, 4);
    return fs_extra_1.default.writeFileSync(fpath, payload);
}
exports.writeJSONWithComments = writeJSONWithComments;
/**
 * Turn . delimited file to / separated
 */
function dot2Slash(fname) {
    return fname.replace(/\./g, "/");
}
exports.dot2Slash = dot2Slash;
/** Checks that the `path` contains a file. */
async function fileExists(path) {
    try {
        const stat = await fs_extra_1.default.stat(path);
        return stat.isFile();
    }
    catch {
        return false;
    }
}
exports.fileExists = fileExists;
/** Finds if a file `fpath` is located in any vault.
 *
 * @param fpath A file name or relative path that we are searching inside vaults.
 */
async function findFileInVault({ fpath, wsRoot, vaults, }) {
    // Assets from later vaults will overwrite earlier ones.
    vaults = [...vaults].reverse();
    for (const vault of vaults) {
        const fullPath = path_1.default.join(wsRoot, common_all_1.VaultUtils.getRelPath(vault), fpath);
        // Doing this sequentially to simulate how publishing handles conflicting assets.
        // eslint-disable-next-line no-await-in-loop
        if (await fileExists(fullPath)) {
            return { vault, fullPath };
        }
    }
    return;
}
async function findNonNoteFile(opts) {
    let { fpath } = opts;
    // Especially for assets, `/assets` and `assets` refers to the same place.
    fpath = lodash_1.default.trim(fpath, "/\\");
    // Check if this is an asset first
    if (fpath.startsWith("assets")) {
        const out = await findFileInVault(opts);
        if (out !== undefined)
            return out;
    }
    // If not an asset, or if we couldn't find it in assets, then check from wsRoot for out-of-vault files
    const fullPath = path_1.default.join(opts.wsRoot, fpath);
    if (await fileExists(fullPath))
        return { fullPath };
    // Otherwise, it just doesn't exist
    return undefined;
}
exports.findNonNoteFile = findNonNoteFile;
//# sourceMappingURL=filesv2.js.map