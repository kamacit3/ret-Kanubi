/// <reference types="node" />
import { DVault, NoteProps, NotesCache, SchemaModuleOpts, SchemaModuleProps } from "@dendronhq/common-all";
import { FSWatcher } from "fs";
import tmp, { DirResult } from "tmp";
/** Dendron should ignore any of these folders when watching or searching folders.
 *
 * These folders are unlikely to contain anything Dendron would like to find, so we can ignore them.
 *
 * Example usage:
 * ```ts
 * if (!anymatch(COMMON_FOLDER_IGNORES, folder)) {
 *   // Good folder!
 * }
 * ```
 */
export declare const COMMON_FOLDER_IGNORES: string[];
declare type FileWatcherCb = {
    fpath: string;
};
declare type CreateFileWatcherOpts = {
    fpath: string;
    numTries?: number;
    onChange: (opts: FileWatcherCb) => Promise<any>;
    onCreate: (opts: FileWatcherCb) => Promise<any>;
};
declare type CreateFileWatcherResp = {
    watcher: FSWatcher;
    didCreate: boolean;
};
export declare function createFileWatcher(opts: CreateFileWatcherOpts): Promise<CreateFileWatcherResp>;
export declare function file2Schema(fpath: string, wsRoot: string): Promise<SchemaModuleProps>;
export declare function genHash(contents: any): string;
export declare function string2Schema({ vault, content, fname, wsRoot, }: {
    vault: DVault;
    content: string;
    fname: string;
    wsRoot: string;
}): Promise<SchemaModuleProps>;
/**
 *
 * @param calculateHash - when set, add `contentHash` property to the note
 *  Default: false
 * @returns
 */
export declare function string2Note({ content, fname, vault, calculateHash, }: {
    content: string;
    fname: string;
    vault: DVault;
    calculateHash?: boolean;
}): import("@dendronhq/common-all").DNodeProps<any, any>;
export declare function file2Note(fpath: string, vault: DVault, toLowercase?: boolean): NoteProps;
export declare function file2NoteWithCache({ fpath, vault, cache, toLowercase, }: {
    fpath: string;
    vault: DVault;
    cache: NotesCache;
    toLowercase?: boolean;
}): {
    note: NoteProps;
    matchHash: boolean;
    noteHash: string;
};
/** Read the contents of a note from the filesystem.
 *
 * Warning! The note contents may be out of date compared to changes in the editor.
 * Consider using `NoteUtils.serialize` instead.
 */
export declare function note2String(opts: {
    note: NoteProps;
    wsRoot: string;
}): Promise<string>;
/**
 * Go to dirname that {fname} is contained in
 * @param maxLvl? - default: 10
 @deprecated use {@link findUpTo}
 */
export declare function goUpTo(opts: {
    base: string;
    fname: string;
    maxLvl?: number;
}): string;
/**
 * Go to dirname that {fname} is contained in, going out (up the tree) from base.
 * @param maxLvl - default: 3
 * @param returnDirPath - return path to directory, default: false
 */
export declare function findUpTo(opts: {
    base: string;
    fname: string;
    maxLvl?: number;
    returnDirPath?: boolean;
}): string | undefined;
export declare const WS_FILE_MAX_SEARCH_DEPTH = 3;
/**
 * Go to dirname that {fname} is contained in, going in (deeper into tree) from base.
 * @param maxLvl Default 3, how deep to go down in the file tree. Keep in mind that the tree gets wider and this search becomes exponentially more expensive the deeper we go.
 * @param returnDirPath - return path to directory, default: false
 *
 * One warning: this will not search into folders starting with `.` to avoid searching through things like the `.git` folder.
 */
export declare function findDownTo(opts: {
    base: string;
    fname: string;
    maxLvl?: number;
    returnDirPath?: boolean;
}): Promise<string | undefined>;
/** Returns true if `inner` is inside of `outer`, and false otherwise.
 *
 * If `inner === outer`, then that also returns false.
 */
export declare function isInsidePath(outer: string, inner: string): boolean;
/** Returns the list of unique, outermost folders. No two folders returned are nested within each other. */
export declare function uniqueOutermostFolders(folders: string[]): string[];
export declare function note2File({ note, vault, wsRoot, }: {
    note: NoteProps;
    vault: DVault;
    wsRoot: string;
}): Promise<void>;
export declare function schemaModuleOpts2File(schemaFile: SchemaModuleOpts, vaultPath: string, fname: string): Promise<void>;
export declare function schemaModuleProps2File(schemaMProps: SchemaModuleProps, vpath: string, fname: string): Promise<void>;
export declare function assignJSONWithComment(jsonObj: any, dataToAdd: any): any;
export declare function readJSONWithComments(fpath: string): Promise<any>;
export declare function readJSONWithCommentsSync(fpath: string): any;
export declare function tmpDir(): DirResult;
export declare const vault2Path: ({ vault, wsRoot, }: {
    vault: DVault;
    wsRoot: string;
}) => string;
export declare function writeJSONWithComments(fpath: string, data: any): void;
/**
 * Turn . delimited file to / separated
 */
export declare function dot2Slash(fname: string): string;
/** Checks that the `path` contains a file. */
export declare function fileExists(path: string): Promise<boolean>;
export declare function findNonNoteFile(opts: {
    fpath: string;
    wsRoot: string;
    vaults: DVault[];
}): Promise<{
    vault?: DVault;
    fullPath: string;
} | undefined>;
export { tmp, DirResult };
