import Fuse from "fuse.js";
import { DEngineMode, SchemaProps, NoteProps, SchemaModuleDict, NotePropsDict, SchemaModuleProps, DEngineClient } from ".";
import { DVault } from "./types";
export declare type NoteIndexProps = {
    id: string;
    title: string;
    fname: string;
    vault: DVault;
    updated: number;
    stub?: boolean;
};
/** https://fusejs.io/examples.html#extended-search */
export declare const FuseExtendedSearchConstants: {
    PrefixExactMatch: string;
};
declare function createFuse<T>(initList: T[], opts: Fuse.IFuseOptions<T> & {
    preset: "schema" | "note";
}, index?: Fuse.FuseIndex<T>): Fuse<T>;
export declare function createFuseNote(publishedNotes: NotePropsDict | NoteProps[], overrideOpts?: Partial<Fuse.IFuseOptions<NoteProps>>, index?: Fuse.FuseIndex<NoteProps>): Fuse<NoteProps>;
export declare function createSerializedFuseNoteIndex(publishedNotes: NotePropsDict | NoteProps[], overrideOpts?: Partial<Parameters<typeof createFuse>[1]>): {
    keys: readonly string[];
    collection: Fuse.FuseIndexRecords;
};
export declare type FuseNote = Fuse<NoteProps>;
export declare type FuseNoteIndex = Fuse.FuseIndex<NoteProps>;
export declare type SerializedFuseIndex = ReturnType<typeof createSerializedFuseNoteIndex>;
declare type FuseEngineOpts = {
    mode?: DEngineMode;
    /** If specified must be within 0-1 range. */
    fuzzThreshold: number;
};
export declare const getCleanThresholdValue: (configThreshold: number) => number;
export declare class FuseEngine {
    /**
     * Characters that are specially treated by FuseJS search
     * Reference https://fusejs.io/examples.html#extended-search
     *
     * Includes '*' which is not specially treated by FuseJS but we currently
     * map '*' to ' ' which specially treated by FuseJS.
     */
    private static readonly SPECIAL_QUERY_CHARACTERS;
    notesIndex: Fuse<NoteIndexProps>;
    schemaIndex: Fuse<SchemaProps>;
    private readonly threshold;
    constructor(opts: FuseEngineOpts);
    querySchema({ qs }: {
        qs: string;
    }): Promise<SchemaProps[]>;
    /**
     * If qs = "", return root note
     * @param qs query string.
     * @param onlyDirectChildren query for direct children only.
     * @param originalQS original query string that was typed by the user.
     * @returns
     */
    queryNote({ qs, onlyDirectChildren, originalQS, }: {
        qs: string;
        onlyDirectChildren?: boolean;
        originalQS: string;
    }): NoteIndexProps[];
    private filterByThreshold;
    updateSchemaIndex(schemas: SchemaModuleDict): Promise<void>;
    updateNotesIndex(notes: NotePropsDict): Promise<void>;
    removeNoteFromIndex(note: NoteProps): Promise<void>;
    removeSchemaFromIndex(smod: SchemaModuleProps): Promise<void>;
    static formatQueryForFuse({ qs }: {
        qs: string;
    }): string;
    /**
     * When there are multiple items with exact same score apply sorting
     * within that group of elements. (The items with better match scores
     * should still come before elements with worse match scores).
     * */
    static sortResults({ results, originalQS, }: {
        results: Fuse.FuseResult<NoteIndexProps>[];
        originalQS: string;
    }): Fuse.FuseResult<NoteIndexProps>[];
    private postQueryFilter;
    /**
     * Returns true when string contains characters that FuseJS treats as special characters.
     * */
    static doesContainSpecialQueryChars(str: string): boolean;
}
export declare class NoteLookupUtils {
    /**
     * Get qs for current level of the hierarchy
     * @param qs
     * @returns
     */
    static getQsForCurrentLevel: (qs: string) => string;
    static fetchRootResults: (notes: NotePropsDict) => NoteProps[];
    static lookup({ qs, originalQS, engine, showDirectChildrenOnly, }: {
        qs: string;
        originalQS: string;
        engine: DEngineClient;
        showDirectChildrenOnly?: boolean;
    }): Promise<NoteProps[]>;
    static slashToDot(ent: string): string;
}
export {};
