"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EngineUtils = exports.HierarchyUtils = exports.stripLocalOnlyTags = exports.removeCache = exports.writeNotesToCache = exports.readNotesFromCache = exports.getCachePath = exports.createCacheEntry = exports.matchRefMarker = exports.parseFileLink = exports.parseDendronRef = exports.writeWSMetaFile = exports.openWSMetaFile = exports.openPortFile = exports.getWSMetaFilePath = exports.getEngine = exports.refLink2Stringv2 = exports.refLink2String = exports.normalizev2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const engineClient_1 = require("./engineClient");
const markdown_1 = require("./markdown");
function normalize(text) {
    return lodash_1.default.toLower(lodash_1.default.trim(text, " #"));
}
function normalizev2(text, slugger) {
    const u = lodash_1.default.trim(text, " #");
    if (u === "*") {
        return u;
    }
    return slugger.slug(u);
}
exports.normalizev2 = normalizev2;
/**
 * take a ref link and parse it as regular markdown
 */
function refLink2String(link, opts) {
    const cleanOpts = lodash_1.default.defaults(opts, {
        includeParen: false,
        includeRefTag: false,
    });
    const { anchorStart, anchorStartOffset, anchorEnd } = link.data;
    const { fname: name } = link.from;
    // [[foo]]#head1:#*"
    const linkParts = [`[[${name}]]`];
    if (anchorStart) {
        linkParts.push(`#${normalize(anchorStart)}`);
    }
    if (anchorStartOffset) {
        linkParts.push(`,${anchorStartOffset}`);
    }
    if (anchorEnd) {
        linkParts.push(`:#${normalize(anchorEnd)}`);
    }
    if (cleanOpts.includeRefTag) {
        linkParts.splice(0, 0, "ref: ");
    }
    if (cleanOpts.includeParen) {
        linkParts.splice(0, 0, "((");
        linkParts.push("))");
    }
    return linkParts.join("");
}
exports.refLink2String = refLink2String;
function refLink2Stringv2(opts) {
    const { link, useVaultPrefix, rawAnchors } = opts;
    const slugger = (0, common_all_1.getSlugger)();
    const { anchorStart, anchorStartOffset, anchorEnd } = link.data;
    const { fname: name } = link.from;
    // [[foo]]#head1:#*"
    const linkParts = [`![[`];
    if (useVaultPrefix) {
        linkParts.push(common_all_1.CONSTANTS.DENDRON_DELIMETER + link.from.vaultName + "/");
    }
    linkParts.push(name);
    if (anchorStart) {
        if (rawAnchors) {
            linkParts.push(`#${anchorStart}`);
        }
        else {
            linkParts.push(`#${normalizev2(anchorStart, slugger)}`);
        }
    }
    if (anchorStartOffset) {
        linkParts.push(`,${anchorStartOffset}`);
    }
    if (anchorEnd) {
        if (rawAnchors) {
            linkParts.push(`:#${anchorEnd}`);
        }
        else {
            linkParts.push(`:#${normalizev2(anchorEnd, slugger)}`);
        }
    }
    linkParts.push("]]");
    return linkParts.join("");
}
exports.refLink2Stringv2 = refLink2Stringv2;
async function getEngine(opts) {
    const { numTries, wsRoot, vaults } = lodash_1.default.defaults(opts, { numTries: 5 });
    if (numTries <= 0) {
        return {
            error: new common_all_1.DendronError({ message: "exceeded numTries" }),
        };
    }
    return new Promise((resolve, _reject) => {
        try {
            const port = engineClient_1.DendronEngineClient.getPort({ wsRoot });
            const dendronEngine = engineClient_1.DendronEngineClient.create({
                port,
                ws: wsRoot,
                vaults,
            });
            resolve({
                data: dendronEngine,
            });
        }
        catch (err) {
            setTimeout(() => {
                resolve(getEngine({ ...opts, numTries: numTries - 1 }));
            }, 5000);
        }
    });
}
exports.getEngine = getEngine;
function getWSMetaFilePath({ wsRoot }) {
    const fsPath = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_WS_META);
    return fsPath;
}
exports.getWSMetaFilePath = getWSMetaFilePath;
function openPortFile({ fpath }) {
    return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" })));
}
exports.openPortFile = openPortFile;
function openWSMetaFile({ fpath }) {
    return fs_extra_1.default.readJSONSync(fpath);
}
exports.openWSMetaFile = openWSMetaFile;
function writeWSMetaFile({ fpath, data, }) {
    return fs_extra_1.default.writeJSONSync(fpath, data);
}
exports.writeWSMetaFile = writeWSMetaFile;
function parseDendronRef(ref) {
    const [idOrRef, ...rest] = lodash_1.default.trim(ref).split(":");
    const cleanArgs = lodash_1.default.trim(rest.join(":"));
    let link;
    let direction;
    if (idOrRef === "ref") {
        direction = "to";
        link = parseLink(cleanArgs);
    }
    else {
        throw Error(`parse non ref not implemented, ref: ${ref}`);
    }
    return { direction, link };
}
exports.parseDendronRef = parseDendronRef;
function parseFileLink(ref) {
    var _a;
    const wikiFileName = /([^\]:]+)/.source;
    const reLink = new RegExp("" +
        /\[\[/.source +
        `(?<name>${wikiFileName})` +
        /\]\]/.source +
        `(${new RegExp(
        // anchor start
        "" +
            /#?/.source +
            `(?<anchorStart>${wikiFileName})` +
            // anchor stop
            `(:#(?<anchorEnd>${wikiFileName}))?`).source})?`, "i");
    const groups = (_a = reLink.exec(ref)) === null || _a === void 0 ? void 0 : _a.groups;
    const clean = {
        type: "file",
    };
    let fname;
    lodash_1.default.each(groups, (v, k) => {
        if (lodash_1.default.isUndefined(v)) {
            return;
        }
        if (k === "name") {
            fname = path_1.default.basename(v, ".md");
        }
        else {
            // @ts-ignore
            clean[k] = v;
        }
    });
    if (lodash_1.default.isUndefined(fname)) {
        throw new common_all_1.DendronError({ message: `fname for ${ref} is undefined` });
    }
    if (clean.anchorStart && clean.anchorStart.indexOf(",") >= 0) {
        const [anchorStart, offset] = clean.anchorStart.split(",");
        clean.anchorStart = anchorStart;
        clean.anchorStartOffset = parseInt(offset, 10);
    }
    return { from: { fname }, data: clean, type: "ref" };
}
exports.parseFileLink = parseFileLink;
function parseLink(ref) {
    if (ref.indexOf("]") >= 0) {
        return parseFileLink(ref);
    }
    else {
        throw Error(`parseLink, non-file link, not implemented, ${ref}`);
    }
}
const matchRefMarker = (txt) => {
    return txt.match(/\(\((?<ref>[^)]+)\)\)/);
};
exports.matchRefMarker = matchRefMarker;
function createCacheEntry(opts) {
    const { noteProps, hash } = opts;
    return {
        data: lodash_1.default.omit(noteProps, "body"),
        hash,
    };
}
exports.createCacheEntry = createCacheEntry;
const getCachePath = (vpath) => {
    const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
    return cachePath;
};
exports.getCachePath = getCachePath;
const readNotesFromCache = (vpath) => {
    const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
    if (fs_extra_1.default.existsSync(cachePath)) {
        return fs_extra_1.default.readJSONSync(cachePath);
    }
    return {
        version: 0,
        notes: {},
    };
};
exports.readNotesFromCache = readNotesFromCache;
const writeNotesToCache = (vpath, cache) => {
    const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
    return fs_extra_1.default.writeJSONSync(cachePath, cache);
};
exports.writeNotesToCache = writeNotesToCache;
const removeCache = (vpath) => {
    const cachePath = path_1.default.join(vpath, common_all_1.CONSTANTS.DENDRON_CACHE_FILE);
    if (fs_extra_1.default.pathExistsSync(cachePath)) {
        return fs_extra_1.default.remove(cachePath);
    }
    return;
};
exports.removeCache = removeCache;
/**
 @deprecated - remove after version 0.76
 * @param doc
 * @returns
 */
function stripLocalOnlyTags(doc) {
    const re = new RegExp(/(?<raw>.+<!--LOCAL_ONLY_LINE-->)/);
    let matches;
    do {
        matches = doc.match(re);
        if (matches) {
            // @ts-ignore
            const { raw, body } = matches.groups;
            doc = doc.replace(raw, "");
        }
    } while (matches);
    return doc;
}
exports.stripLocalOnlyTags = stripLocalOnlyTags;
class HierarchyUtils {
}
exports.HierarchyUtils = HierarchyUtils;
/**
 * Get children of current note
 * @param opts.skipLevels: how many levels to skip for child
 * @returns
 */
HierarchyUtils.getChildren = (opts) => {
    const { skipLevels, note, notes } = opts;
    let children = note.children
        .map((id) => notes[id])
        .filter((ent) => !lodash_1.default.isUndefined(ent));
    let acc = 0;
    while (acc !== skipLevels) {
        children = children
            .flatMap((ent) => ent.children.map((id) => notes[id]))
            .filter((ent) => !lodash_1.default.isUndefined(ent));
        acc += 1;
    }
    return children;
};
class EngineUtils {
    /**
     * Try to discover file for engine port. Will use following heuristic:
     * - look for file for workspace
     * - look for file for CLI
     * @param param0
     */
    static getPortFilePath(opts) {
        let portFilePath = EngineUtils.getPortFilePathForWorkspace(opts);
        if (fs_extra_1.default.existsSync(portFilePath)) {
            return { data: portFilePath };
        }
        portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        if (fs_extra_1.default.existsSync(portFilePath)) {
            return { data: portFilePath };
        }
        return { error: common_all_1.ErrorFactory.create404Error({ url: portFilePath }) };
    }
    static getPortFilePathForTarget({ wsRoot, target, }) {
        const suffix = target === "cli" ? ".cli" : "";
        const portFile = path_1.default.join(wsRoot, common_all_1.CONSTANTS.DENDRON_SERVER_PORT) + suffix;
        return portFile;
    }
    static getPortFilePathForWorkspace({ wsRoot }) {
        return this.getPortFilePathForTarget({ wsRoot, target: "workspace" });
    }
    static getPortFilePathForCLI({ wsRoot }) {
        return this.getPortFilePathForTarget({ wsRoot, target: "cli" });
    }
    static getEnginePort(opts) {
        const resp = EngineUtils.getPortFilePath(opts);
        if (resp.error) {
            return resp;
        }
        const port = openPortFile({ fpath: resp.data });
        return { data: port };
    }
    static getEnginePortForCLI(opts) {
        const portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        const port = openPortFile({ fpath: portFilePath });
        return port;
    }
    static getLocalEngineUrl({ port }) {
        return common_all_1.APIUtils.getLocalEndpoint(port);
    }
    static writeEnginePortForCLI(opts) {
        const portFilePath = EngineUtils.getPortFilePathForCLI(opts);
        fs_extra_1.default.writeFileSync(portFilePath, lodash_1.default.toString(opts.port), { encoding: "utf8" });
    }
    /**
     * NOTE: if the `note.body.length < maxNoteLength`, we will not add any links or anchors to the note
     * @param param0
     * @returns
     */
    static async refreshNoteLinksAndAnchors({ note, engine, notesMap, }) {
        const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(engine.config).maxNoteLength;
        if (note.body.length <
            (maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH)) {
            const links = markdown_1.LinkUtils.findLinks({ note, engine });
            const anchors = await markdown_1.AnchorUtils.findAnchors({
                note,
                wsRoot: engine.wsRoot,
            });
            // update links for note
            note.links = links.concat(links);
            const devConfig = common_all_1.ConfigUtils.getProp(engine.config, "dev");
            const linkCandidatesEnabled = devConfig === null || devConfig === void 0 ? void 0 : devConfig.enableLinkCandidates;
            if (linkCandidatesEnabled) {
                const linkCandidates = markdown_1.LinkUtils.findLinkCandidates({
                    note,
                    notesMap,
                    engine,
                });
                note.links = links.concat(linkCandidates);
            }
            note.anchors = anchors;
            return note;
        }
        return note;
    }
}
exports.EngineUtils = EngineUtils;
//# sourceMappingURL=utils.js.map