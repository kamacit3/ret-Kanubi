"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DendronEngineClient = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const config_1 = require("./config");
const storev2_1 = require("./drivers/file/storev2");
const utils_1 = require("./utils");
class DendronEngineClient {
    constructor({ api, vaults, ws, history, logger, }) {
        this.api = api;
        this.notes = {};
        this.noteFnames = new common_all_1.NoteFNamesDict();
        this.schemas = {};
        this.links = [];
        this.vaults = vaults;
        this.wsRoot = ws;
        this.ws = ws;
        this.configRoot = this.wsRoot;
        this.history = history;
        this.logger = logger || (0, common_server_1.createLogger)();
        const cpath = config_1.DConfig.configPath(ws);
        this.config = (0, common_server_1.readYAML)(cpath);
        this.fuseEngine = new common_all_1.FuseEngine({
            fuzzThreshold: common_all_1.ConfigUtils.getLookup(this.config).note.fuzzThreshold,
        });
        this.store = new storev2_1.FileStorage({
            engine: this,
            logger: this.logger,
        });
        this.hooks = common_all_1.ConfigUtils.getWorkspace(this.config).hooks || {
            onCreate: [],
        };
    }
    static create({ port, vaults, ws, history, logger, }) {
        const api = new common_all_1.DendronAPI({
            endpoint: common_all_1.APIUtils.getLocalEndpoint(lodash_1.default.isString(port) ? parseInt(port, 10) : port),
            apiPath: "api",
            logger,
        });
        return new DendronEngineClient({ api, vaults, ws, history });
    }
    static getPort({ wsRoot }) {
        const portFile = utils_1.EngineUtils.getPortFilePathForWorkspace({ wsRoot });
        if (!fs_extra_1.default.pathExistsSync(portFile)) {
            throw new common_all_1.DendronError({ message: "no port file" });
        }
        return lodash_1.default.toInteger(lodash_1.default.trim(fs_extra_1.default.readFileSync(portFile, { encoding: "utf8" })));
    }
    /**
     * Load all nodes
     */
    async init() {
        const resp = await this.api.workspaceInit({
            uri: this.ws,
            config: { vaults: this.vaults },
        });
        if (resp.error && resp.error.severity !== common_all_1.ERROR_SEVERITY.MINOR) {
            return {
                error: resp.error,
            };
        }
        if (!resp.data) {
            throw new common_all_1.DendronError({ message: "no data" });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.noteFnames = new common_all_1.NoteFNamesDict(lodash_1.default.values(notes));
        this.schemas = schemas;
        await this.fuseEngine.updateNotesIndex(notes);
        await this.fuseEngine.updateSchemaIndex(schemas);
        this.store.notes = notes;
        this.store.schemas = schemas;
        return {
            error: resp.error,
            data: {
                notes,
                schemas,
                config: this.config,
                wsRoot: this.wsRoot,
                vaults: this.vaults,
            },
        };
    }
    async bulkAddNotes(opts) {
        const resp = await this.api.engineBulkAdd({ opts, ws: this.ws });
        const changed = resp.data;
        await this.refreshNotesV2(changed);
        return resp;
    }
    async deleteNote(id, opts) {
        const ws = this.ws;
        const resp = await this.api.engineDelete({ id, opts, ws });
        if (!resp.data) {
            throw new common_all_1.DendronError({ message: "no data" });
        }
        await this.refreshNotesV2(resp.data);
        return {
            error: null,
            data: resp.data,
        };
    }
    async deleteSchema(id, opts) {
        var _a, _b;
        const ws = this.ws;
        const resp = await this.api.schemaDelete({ id, opts, ws });
        delete this.schemas[id];
        if (!((_a = resp === null || resp === void 0 ? void 0 : resp.data) === null || _a === void 0 ? void 0 : _a.notes) || !((_b = resp === null || resp === void 0 ? void 0 : resp.data) === null || _b === void 0 ? void 0 : _b.schemas)) {
            throw new common_all_1.DendronError({ message: "bad delete operation" });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.noteFnames = new common_all_1.NoteFNamesDict(lodash_1.default.values(notes));
        this.schemas = schemas;
        this.fuseEngine.updateNotesIndex(notes);
        this.fuseEngine.updateSchemaIndex(schemas);
        return {
            error: null,
            data: resp.data,
        };
    }
    async getConfig() {
        const resp = await this.api.configGet({
            ws: this.ws,
        });
        return resp;
    }
    async getNoteByPath(opts) {
        const resp = await this.api.engineGetNoteByPath({
            ...opts,
            ws: this.ws,
        });
        if (!lodash_1.default.isUndefined(resp.data)) {
            await this.refreshNotesV2(resp.data.changed);
        }
        return resp;
    }
    async info() {
        const resp = await this.api.engineInfo();
        return resp;
    }
    async queryNote(opts) {
        const { qs, onlyDirectChildren, vault, originalQS } = opts;
        let noteIndexProps = await this.fuseEngine.queryNote({
            qs,
            onlyDirectChildren,
            originalQS,
        });
        // TODO: hack
        if (!lodash_1.default.isUndefined(vault)) {
            noteIndexProps = noteIndexProps.filter((ent) => common_all_1.VaultUtils.isEqual(vault, ent.vault, this.wsRoot));
        }
        return noteIndexProps.map((ent) => this.notes[ent.id]);
    }
    async queryNotes(opts) {
        const items = await this.queryNote(opts);
        return {
            data: items,
            error: null,
        };
    }
    queryNotesSync({ qs, originalQS, vault, }) {
        let items = this.fuseEngine.queryNote({ qs, originalQS });
        if (vault) {
            items = items.filter((ent) => {
                return common_all_1.VaultUtils.isEqual(ent.vault, vault, this.wsRoot);
            });
        }
        return {
            error: null,
            data: items.map((ent) => this.notes[ent.id]),
        };
    }
    async renderNote(opts) {
        return this.api.noteRender({ ...opts, ws: this.ws });
    }
    async refreshNotes(opts) {
        await this.refreshNotesV2(opts.notes);
        return { error: null };
    }
    async refreshNotesV2(notes) {
        notes.forEach((ent) => {
            var _a, _b, _c, _d;
            const { id } = ent.note;
            const uri = common_all_1.NoteUtils.getURI({ note: ent.note, wsRoot: this.wsRoot });
            if (ent.status === "delete") {
                delete this.notes[id];
                this.noteFnames.delete(ent.note);
                (_a = this.history) === null || _a === void 0 ? void 0 : _a.add({ source: "engine", action: "delete", uri });
            }
            else {
                if (ent.status === "create") {
                    this.noteFnames.add(ent.note);
                    (_b = this.history) === null || _b === void 0 ? void 0 : _b.add({ source: "engine", action: "create", uri });
                }
                if (ent.status === "update") {
                    // If the note id or fname has been changed, need to update fname dict
                    if (((_c = ent.prevNote) === null || _c === void 0 ? void 0 : _c.fname) !== ent.note.fname ||
                        ((_d = ent.prevNote) === null || _d === void 0 ? void 0 : _d.id) !== ent.note.id) {
                        if (ent.prevNote)
                            this.noteFnames.delete(ent.prevNote);
                        this.noteFnames.add(ent.note);
                    }
                    ent.note.children = lodash_1.default.sortBy(ent.note.children, (id) => {
                        var _a;
                        return lodash_1.default.get(this.notes, id, ((_a = lodash_1.default.find(notes, (ent) => ent.note.id === id)) === null || _a === void 0 ? void 0 : _a.note) || {
                            title: "foo",
                        }).title;
                    });
                }
                this.notes[id] = ent.note;
            }
        });
        this.fuseEngine.updateNotesIndex(this.notes);
    }
    async refreshSchemas(smods) {
        smods.forEach((smod) => {
            const id = common_all_1.SchemaUtils.getModuleRoot(smod).id;
            this.schemas[id] = smod;
        });
    }
    /** Renames the note.
     *
     *  WARNING: When doing bulk operations. Do not invoke multiple requests to this
     *  command in parallel, wait for a single call to finish before requesting another call.
     *  Otherwise some race condition starts to cause intermittent failures.
     *  */
    async renameNote(opts) {
        const resp = await this.api.engineRenameNote({ ...opts, ws: this.ws });
        if (resp.error || lodash_1.default.isUndefined(resp.data)) {
            throw resp.error;
        }
        await this.refreshNotesV2(resp.data);
        return resp;
    }
    async sync() {
        const resp = await this.api.workspaceSync({ ws: this.ws });
        if (!resp.data) {
            throw new common_all_1.DendronError({ message: "no data", payload: resp });
        }
        const { notes, schemas } = resp.data;
        this.notes = notes;
        this.noteFnames = new common_all_1.NoteFNamesDict(lodash_1.default.values(notes));
        this.schemas = schemas;
        await this.fuseEngine.updateNotesIndex(notes);
        await this.fuseEngine.updateSchemaIndex(schemas);
        return {
            error: resp.error,
            data: {
                notes,
                schemas,
                vaults: this.vaults,
                wsRoot: this.wsRoot,
                config: this.config,
            },
        };
    }
    async updateNote(note, opts) {
        const resp = await this.api.engineUpdateNote({ ws: this.ws, note, opts });
        const noteClean = resp.data;
        if (lodash_1.default.isUndefined(noteClean)) {
            throw new common_all_1.DendronError({ message: "error updating note", payload: resp });
        }
        await this.refreshNotesV2([
            { note: noteClean, prevNote: note, status: "update" },
        ]);
        return noteClean;
    }
    async writeNote(note, opts) {
        const resp = await this.api.engineWrite({
            node: note,
            opts,
            ws: this.ws,
        });
        let changed = resp.data;
        if (resp.error) {
            return resp;
        }
        // we are updating in place, remove deletes
        if (opts === null || opts === void 0 ? void 0 : opts.updateExisting) {
            changed = lodash_1.default.reject(changed, (ent) => ent.status === "delete");
        }
        await this.refreshNotesV2(changed);
        return resp;
    }
    // ~~~ schemas
    async getSchema(_qs) {
        throw Error("not implemetned");
    }
    async querySchema(qs) {
        const out = await this.api.schemaQuery({ qs, ws: this.ws });
        return lodash_1.default.defaults(out, { data: [] });
    }
    async updateSchema(schema) {
        await this.api.schemaUpdate({ schema, ws: this.ws });
        await this.refreshSchemas([schema]);
        return;
    }
    async writeConfig(opts) {
        await this.api.configWrite({ ...opts, ws: this.ws });
        return {
            error: null,
        };
    }
    async writeSchema(schema) {
        await this.api.schemaWrite({ schema, ws: this.ws });
        await this.refreshSchemas([schema]);
        return;
    }
    async getNoteBlocks({ id, filterByAnchorType, }) {
        const out = await this.api.getNoteBlocks({
            id,
            filterByAnchorType,
            ws: this.ws,
        });
        return out;
    }
    async getDecorations(opts) {
        const out = await this.api.getDecorations({
            ...opts,
            ws: this.ws,
        });
        return out;
    }
}
exports.DendronEngineClient = DendronEngineClient;
//# sourceMappingURL=engineClient.js.map