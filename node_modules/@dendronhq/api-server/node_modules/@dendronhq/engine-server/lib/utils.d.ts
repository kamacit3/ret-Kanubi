import { DendronError, DEngineClient, DNoteRefLink, DVault, getSlugger, NoteProps, NotePropsDict, NotesCache, NotesCacheEntry, RespV3 } from "@dendronhq/common-all";
import { WSMeta } from "./types";
export declare function normalizev2(text: string, slugger: ReturnType<typeof getSlugger>): string;
/**
 * take a ref link and parse it as regular markdown
 */
export declare function refLink2String(link: DNoteRefLink, opts?: {
    includeParen: boolean;
    includeRefTag?: boolean;
}): string;
export declare function refLink2Stringv2(opts: {
    link: DNoteRefLink;
    useVaultPrefix?: boolean;
    rawAnchors?: boolean;
}): string;
export declare function getEngine(opts: {
    numTries?: number;
    wsRoot: string;
    vaults: DVault[];
}): Promise<{
    error?: DendronError;
    data?: DEngineClient;
}>;
export declare function getWSMetaFilePath({ wsRoot }: {
    wsRoot: string;
}): string;
export declare function openPortFile({ fpath }: {
    fpath: string;
}): number;
export declare function openWSMetaFile({ fpath }: {
    fpath: string;
}): WSMeta;
export declare function writeWSMetaFile({ fpath, data, }: {
    fpath: string;
    data: WSMeta;
}): void;
export declare function parseDendronRef(ref: string): {
    direction: "to";
    link: DNoteRefLink | undefined;
};
export declare function parseFileLink(ref: string): DNoteRefLink;
export declare const matchRefMarker: (txt: string) => RegExpMatchArray | null;
export declare function createCacheEntry(opts: {
    noteProps: NoteProps;
    hash: string;
}): NotesCacheEntry;
export declare const getCachePath: (vpath: string) => string;
export declare const readNotesFromCache: (vpath: string) => NotesCache;
export declare const writeNotesToCache: (vpath: string, cache: NotesCache) => void;
export declare const removeCache: (vpath: string) => Promise<void> | undefined;
/**
 @deprecated - remove after version 0.76
 * @param doc
 * @returns
 */
export declare function stripLocalOnlyTags(doc: string): string;
export declare class HierarchyUtils {
    /**
     * Get children of current note
     * @param opts.skipLevels: how many levels to skip for child
     * @returns
     */
    static getChildren: (opts: {
        skipLevels: number;
        note: NoteProps;
        notes: NotePropsDict;
    }) => NoteProps[];
}
export declare class EngineUtils {
    /**
     * Try to discover file for engine port. Will use following heuristic:
     * - look for file for workspace
     * - look for file for CLI
     * @param param0
     */
    static getPortFilePath(opts: {
        wsRoot: string;
    }): RespV3<string>;
    static getPortFilePathForTarget({ wsRoot, target, }: {
        wsRoot: string;
        target: "workspace" | "cli";
    }): string;
    static getPortFilePathForWorkspace({ wsRoot }: {
        wsRoot: string;
    }): string;
    static getPortFilePathForCLI({ wsRoot }: {
        wsRoot: string;
    }): string;
    static getEnginePort(opts: {
        wsRoot: string;
    }): RespV3<number>;
    static getEnginePortForCLI(opts: {
        wsRoot: string;
    }): number;
    static getLocalEngineUrl({ port }: {
        port: number;
    }): string;
    static writeEnginePortForCLI(opts: {
        port: number;
        wsRoot: string;
    }): void;
    /**
     * NOTE: if the `note.body.length < maxNoteLength`, we will not add any links or anchors to the note
     * @param param0
     * @returns
     */
    static refreshNoteLinksAndAnchors({ note, engine, notesMap, }: {
        note: NoteProps;
        engine: DEngineClient;
        notesMap: Map<string, NoteProps>;
    }): Promise<NoteProps>;
}
