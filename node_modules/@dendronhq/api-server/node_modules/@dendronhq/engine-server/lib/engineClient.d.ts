import { BulkAddNoteOpts, ConfigGetPayload, ConfigWriteOpts, DendronAPI, DendronError, DEngine, DEngineClient, DEngineDeleteSchemaResp, DEngineInitResp, DHookDict, DLink, DVault, EngineDeleteNoteResp, EngineDeleteOptsV2, EngineInfoResp, EngineUpdateNodesOptsV2, EngineWriteOptsV2, FuseEngine, GetDecorationsOpts, GetDecorationsPayload, GetNoteBlocksOpts, GetNoteBlocksPayload, GetNoteOptsV2, GetNotePayload, IntermediateDendronConfig, NoteChangeEntry, NoteFNamesDict, NoteProps, NotePropsDict, QueryNotesOpts, RefreshNotesOpts, RenameNoteOpts, RenameNotePayload, RenderNoteOpts, RespRequired, RespV2, SchemaModuleDict, SchemaModuleProps, SchemaQueryResp, WriteNoteResp } from "@dendronhq/common-all";
import { DLogger } from "@dendronhq/common-server";
import { FileStorage } from "./drivers/file/storev2";
import { HistoryService } from "./history";
declare type DendronEngineClientOpts = {
    vaults: DVault[];
    ws: string;
};
export declare class DendronEngineClient implements DEngineClient {
    notes: NotePropsDict;
    noteFnames: NoteFNamesDict;
    wsRoot: string;
    schemas: SchemaModuleDict;
    links: DLink[];
    ws: string;
    fuseEngine: FuseEngine;
    api: DendronAPI;
    vaults: DVault[];
    configRoot: string;
    history?: HistoryService;
    logger: DLogger;
    store: FileStorage;
    config: IntermediateDendronConfig;
    hooks: DHookDict;
    static create({ port, vaults, ws, history, logger, }: {
        port: number | string;
        history?: HistoryService;
        logger?: DLogger;
    } & DendronEngineClientOpts): DendronEngineClient;
    static getPort({ wsRoot }: {
        wsRoot: string;
    }): number;
    constructor({ api, vaults, ws, history, logger, }: {
        api: DendronAPI;
        history?: HistoryService;
        logger?: DLogger;
    } & DendronEngineClientOpts);
    /**
     * Load all nodes
     */
    init(): Promise<DEngineInitResp>;
    bulkAddNotes(opts: BulkAddNoteOpts): Promise<Required<RespV2<NoteChangeEntry[]>>>;
    deleteNote(id: string, opts?: EngineDeleteOptsV2): Promise<EngineDeleteNoteResp>;
    deleteSchema(id: string, opts?: EngineDeleteOptsV2): Promise<DEngineDeleteSchemaResp>;
    getConfig(): Promise<RespV2<ConfigGetPayload>>;
    getNoteByPath(opts: GetNoteOptsV2): Promise<RespV2<GetNotePayload>>;
    info(): Promise<RespRequired<EngineInfoResp>>;
    queryNote(opts: Parameters<DEngineClient["queryNotes"]>[0]): Promise<NoteProps[]>;
    queryNotes(opts: QueryNotesOpts): Promise<{
        data: NoteProps[];
        error: null;
    }>;
    queryNotesSync({ qs, originalQS, vault, }: {
        qs: string;
        originalQS: string;
        vault?: DVault;
    }): {
        error: null;
        data: NoteProps[];
    };
    renderNote(opts: RenderNoteOpts): Promise<{
        data: import("@dendronhq/common-all").RenderNotePayload;
        error: DendronError | null;
    }>;
    refreshNotes(opts: RefreshNotesOpts): Promise<{
        error: null;
    }>;
    refreshNotesV2(notes: NoteChangeEntry[]): Promise<void>;
    refreshSchemas(smods: SchemaModuleProps[]): Promise<void>;
    /** Renames the note.
     *
     *  WARNING: When doing bulk operations. Do not invoke multiple requests to this
     *  command in parallel, wait for a single call to finish before requesting another call.
     *  Otherwise some race condition starts to cause intermittent failures.
     *  */
    renameNote(opts: RenameNoteOpts): Promise<RespV2<RenameNotePayload>>;
    sync(): Promise<DEngineInitResp>;
    updateNote(note: NoteProps, opts?: EngineUpdateNodesOptsV2): Promise<NoteProps>;
    writeNote(note: NoteProps, opts?: EngineWriteOptsV2): Promise<WriteNoteResp>;
    getSchema(_qs: string): Promise<RespV2<SchemaModuleProps>>;
    querySchema(qs: string): Promise<SchemaQueryResp>;
    updateSchema(schema: SchemaModuleProps): Promise<void>;
    writeConfig(opts: ConfigWriteOpts): ReturnType<DEngine["writeConfig"]>;
    writeSchema(schema: SchemaModuleProps): Promise<void>;
    getNoteBlocks({ id, filterByAnchorType, }: GetNoteBlocksOpts): Promise<GetNoteBlocksPayload>;
    getDecorations(opts: GetDecorationsOpts): Promise<GetDecorationsPayload>;
}
export {};
