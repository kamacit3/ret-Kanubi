"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.dendronPreview = exports.dendronHoverPreview = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const _1 = require(".");
const utils_1 = require("../../utils");
const utilsv5_1 = require("../utilsv5");
/**
 *
 * @param useFullPathUrl `false` by default, and the generated URL for images will go through engine API.
 *   When `true`, the image URL will be a full path to the image on disk instead.
 * @returns
 */
function handleImage({ proc, node, useFullPathUrl = false, }) {
    const { logger, dispose } = (0, common_server_1.createDisposableLogger)("handleImage");
    try {
        const ctx = "handleImage";
        // ignore web images
        if (lodash_1.default.some(["http://", "https://"], (ent) => node.url.startsWith(ent))) {
            logger.debug({ ctx, url: node.url });
            return;
        }
        // assume that the path is relative to vault
        const { wsRoot, vault } = utilsv5_1.MDUtilsV5.getProcData(proc);
        const fpath = path_1.default.join((0, common_server_1.vault2Path)({ vault, wsRoot }), node.url);
        if (useFullPathUrl === true) {
            logger.debug({
                ctx,
                wsRoot,
                vault,
                url: node.url,
                fpath,
                useFullPathUrl,
            });
            node.url = fpath;
            return;
        }
        const resp = utils_1.EngineUtils.getEnginePort({ wsRoot });
        if (resp.error) {
            logger.error(resp.error);
            return;
        }
        const port = resp.data;
        const url = utils_1.EngineUtils.getLocalEngineUrl({ port }) + "/api/assets";
        const params = {
            fpath,
            ws: wsRoot,
        };
        node.url = common_all_1.APIUtils.genUrlWithQS({ url, params });
        logger.debug({
            ctx,
            url: node.url,
            useFullPathUrl,
            opts: utilsv5_1.MDUtilsV5.getProcOpts(proc),
        });
    }
    finally {
        dispose();
    }
}
function plugin(_opts) {
    const proc = this;
    function transformer(tree, _file) {
        (0, unist_util_visit_1.default)(tree, (node, _index, _parent) => {
            if (_1.RemarkUtils.isImage(node) || _1.RemarkUtils.isExtendedImage(node)) {
                return handleImage({ proc, node });
            }
        });
    }
    return transformer;
}
exports.dendronPreview = plugin;
function dendronHoverPreview(_opts) {
    const proc = this;
    function transformer(tree, _file) {
        (0, unist_util_visit_1.default)(tree, (node, index, parent) => {
            if (_1.RemarkUtils.isImage(node) || _1.RemarkUtils.isExtendedImage(node)) {
                // Hover preview can't use API URL's because they are http not https, so we instead have to get the image from disk.
                return handleImage({ proc, node, useFullPathUrl: true });
            }
            // Remove the frontmatter because it will break the output
            if (_1.RemarkUtils.isFrontmatter(node) && parent) {
                // Remove this node
                parent.children.splice(index, 1);
                // Since we removed this node, the next node to process will be the same index
                return index;
            }
        });
    }
    return transformer;
}
exports.dendronHoverPreview = dendronHoverPreview;
//# sourceMappingURL=dendronPreview.js.map