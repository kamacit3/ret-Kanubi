"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hierarchies = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const unist_builder_1 = __importDefault(require("unist-builder"));
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const site_1 = require("../../topics/site");
const utils_1 = require("../../utils");
const types_1 = require("../types");
const utils_2 = require("../utils");
const utilsv5_1 = require("../utilsv5");
const utils_3 = require("./utils");
// These are the HTML IDs for footnotes. This replicates what the footnotes plugin was doing.
const FOOTNOTE_DEF_ID_PREFIX = `${common_all_1.FOOTNOTE_DEF_CLASS}-`;
const FOOTNOTE_REF_ID_PREFIX = `${common_all_1.FOOTNOTE_REF_CLASS}-`;
/** The symbol that will be shown as the "return to reference" button. */
const FOOTNOTE_RETURN_SYMBOL = "Ë„";
function footnote2html(reference) {
    return (0, mdast_builder_1.html)(`<a id="${FOOTNOTE_REF_ID_PREFIX}${reference.identifier}"` +
        `class="${common_all_1.FOOTNOTE_REF_CLASS}"` +
        `href="#${FOOTNOTE_DEF_ID_PREFIX}${reference.identifier}">` +
        (reference.label || reference.identifier) +
        `</a>`);
}
function footnoteDef2html(definition) {
    // Add a back arrow to the end of the definition that takes user to the
    // footnote reference. We have to inject the back arrow into the text inside
    // the definition, otherwise it renders in a different line than the definition.
    const backArrow = (0, mdast_builder_1.html)(`<a class="${common_all_1.FOOTNOTE_DEF_CLASS}" href="#${FOOTNOTE_REF_ID_PREFIX}${definition.identifier}">${FOOTNOTE_RETURN_SYMBOL}</a>`);
    const lastChild = lodash_1.default.last(definition.children);
    if (lastChild && utils_3.RemarkUtils.isParent(lastChild)) {
        lastChild.children.push(backArrow);
    }
    else {
        // Fallback, not sure if this can actually happen because definition always seems to have a paragraph as a child
        definition.children.push(backArrow);
    }
    return (0, mdast_builder_1.paragraph)([
        // Put the ID target first, so even if the footnote is multiple lines long, it jumps to the start
        (0, mdast_builder_1.html)(`<span id="${FOOTNOTE_DEF_ID_PREFIX}${definition.identifier}" style="width: 0; height: 0;"></span>`),
        ...definition.children,
    ]);
}
/** Adds the "Children", "Tags", and "Footnotes" items to the end of the note. Also renders footnotes. */
// eslint-disable-next-line func-names
const plugin = function (opts) {
    const proc = this;
    const { config } = utilsv5_1.MDUtilsV5.getProcData(this);
    // MDUtilsV4 explicitly passes these options in, while MDUtilsV5 relies on the config. We need to check both here for now.
    const hierarchyDisplayTitle = (opts === null || opts === void 0 ? void 0 : opts.hierarchyDisplayTitle) || (config === null || config === void 0 ? void 0 : config.hierarchyDisplayTitle) || "Children";
    let hierarchyDisplay = opts === null || opts === void 0 ? void 0 : opts.hierarchyDisplay;
    if (hierarchyDisplay === undefined)
        hierarchyDisplay = config === null || config === void 0 ? void 0 : config.hierarchyDisplay;
    if (hierarchyDisplay === undefined)
        hierarchyDisplay = true;
    function transformer(tree) {
        const root = tree;
        const { fname, vault, dest, config, insideNoteRef } = utils_2.MDUtilsV4.getDendronData(proc);
        let addedBreak = false;
        if (dest !== types_1.DendronASTDest.HTML) {
            return;
        }
        // TODO: remove
        if (!hierarchyDisplay) {
            return;
        }
        function addBreak() {
            if (addedBreak)
                return;
            root.children.push({
                type: "thematicBreak",
            });
            addedBreak = true;
        }
        function addFootnotes() {
            /** Maps footnote identifiers to their definitions. */
            const footnotes = new Map(utils_3.RemarkUtils.extractFootnoteDefs(root).map((definition) => [
                definition.identifier,
                definition,
            ]));
            /** All footnote definitions that have been referenced in this document. */
            const usedFootnotes = new Set();
            (0, unist_util_visit_1.default)(root, [types_1.DendronASTTypes.FOOTNOTE_REFERENCE], (reference, index, parent) => {
                const definition = footnotes.get(reference.identifier);
                if (definition && parent) {
                    parent.children[index] = footnote2html(reference);
                    usedFootnotes.add(definition);
                }
            });
            if (usedFootnotes.size > 0) {
                addBreak();
                root.children.push((0, mdast_builder_1.heading)(2, (0, mdast_builder_1.text)("Footnotes")));
                const footnoteItems = [];
                for (const definition of usedFootnotes) {
                    footnoteItems.push((0, mdast_builder_1.listItem)(footnoteDef2html(definition)));
                }
                root.children.push((0, mdast_builder_1.list)("ordered", footnoteItems));
            }
        }
        if (!fname || insideNoteRef) {
            // Even inside a note ref, render footnotes because we want them in there too
            addFootnotes();
            return;
        }
        const { engine } = utils_2.MDUtilsV4.getEngineFromProc(proc);
        const note = common_all_1.NoteUtils.getNoteByFnameFromEngine({
            fname,
            engine,
            vault: vault,
        });
        // check if v5 is active
        if (utilsv5_1.MDUtilsV5.isV5Active(proc)) {
            const resp = utilsv5_1.MDUtilsV5.getProcData(proc);
            hierarchyDisplay = common_all_1.ConfigUtils.getEnableChildLinks(resp.config, { note });
        }
        /** Add frontmatter tags, if any, ahead of time. This way wikilink compiler will pick them up and render them. */
        function addTags() {
            var _a;
            if (((_a = config === null || config === void 0 ? void 0 : config.site) === null || _a === void 0 ? void 0 : _a.showFrontMatterTags) !== false &&
                (note === null || note === void 0 ? void 0 : note.tags) &&
                note.tags.length > 0) {
                addBreak();
                root.children.push((0, mdast_builder_1.heading)(2, (0, mdast_builder_1.text)("Tags")));
                const tags = lodash_1.default.isString(note.tags) ? [note.tags] : note.tags;
                const tagLinks = lodash_1.default.sortBy(lodash_1.default.map(tags, (tag) => {
                    var _a;
                    return (0, mdast_builder_1.listItem)((0, mdast_builder_1.paragraph)((0, utils_3.frontmatterTag2WikiLinkNoteV4)(tag, (_a = config === null || config === void 0 ? void 0 : config.site) === null || _a === void 0 ? void 0 : _a.useHashesForFMTags)));
                }), ["custom.nav_order", "title"]);
                root.children.push((0, mdast_builder_1.list)("ordered", tagLinks));
            }
        }
        function addChildren() {
            var _a, _b, _c;
            // don't include if collection present
            if (!note || note.children.length <= 0 || ((_a = note === null || note === void 0 ? void 0 : note.custom) === null || _a === void 0 ? void 0 : _a.has_collection)) {
                return;
            }
            if (lodash_1.default.isBoolean((_b = note.custom) === null || _b === void 0 ? void 0 : _b.hierarchyDisplay) &&
                !note.custom.hierarchyDisplay) {
                return;
            }
            const children = utils_1.HierarchyUtils.getChildren({
                skipLevels: ((_c = note.custom) === null || _c === void 0 ? void 0 : _c.skipLevels) || 0,
                note,
                notes: engine.notes,
            })
                .filter((note) => site_1.SiteUtils.canPublish({ note, engine, config }))
                .filter((note) => { var _a, _b; return lodash_1.default.isUndefined((_a = note.custom) === null || _a === void 0 ? void 0 : _a.nav_exclude) || !((_b = note.custom) === null || _b === void 0 ? void 0 : _b.nav_exclude); });
            if (!lodash_1.default.isEmpty(children)) {
                addBreak();
                root.children.push((0, unist_builder_1.default)("strong", [{ type: "text", value: hierarchyDisplayTitle }]));
                root.children.push((0, mdast_builder_1.list)("ordered", lodash_1.default.sortBy(children, ["custom.nav_order", "title"]).map((note) => {
                    return (0, mdast_builder_1.listItem)((0, mdast_builder_1.paragraph)({
                        type: types_1.DendronASTTypes.WIKI_LINK,
                        value: note.fname,
                        data: {
                            alias: note.title,
                            vaultName: common_all_1.VaultUtils.getName(note.vault),
                        },
                        children: [],
                    }));
                })));
            }
        }
        // Will appear on page in this order
        if (hierarchyDisplay) {
            addChildren();
        }
        addTags();
        addFootnotes();
        // end transformer
    }
    return transformer;
};
exports.hierarchies = plugin;
//# sourceMappingURL=hierarchies.js.map