"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DConfig = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
class DConfig {
    static configPath(configRoot) {
        return path_1.default.join(configRoot, common_all_1.CONSTANTS.DENDRON_CONFIG_FILE);
    }
    /**
     * Get without filling in defaults
     * @param wsRoot
     */
    static getRaw(wsRoot) {
        const configPath = DConfig.configPath(wsRoot);
        const config = common_server_1.readYAML(configPath);
        return config;
    }
    static getOrCreate(dendronRoot, defaults) {
        const configPath = DConfig.configPath(dendronRoot);
        let config = {
            ...defaults,
            ...common_all_1.ConfigUtils.genDefaultConfig(),
        };
        if (!fs_extra_1.default.existsSync(configPath)) {
            common_server_1.writeYAML(configPath, config);
        }
        else {
            config = {
                ...config,
                ...common_server_1.readYAML(configPath),
            };
        }
        return config;
    }
    static getSiteIndex(sconfig) {
        let { siteIndex, siteHierarchies } = sconfig;
        return siteIndex || siteHierarchies[0];
    }
    /**
     * fill in defaults
     */
    static cleanSiteConfig(config) {
        let out = lodash_1.default.defaults(config, {
            copyAssets: true,
            usePrettyRefs: true,
            siteNotesDir: "notes",
            siteFaviconPath: "favicon.ico",
            gh_edit_link: true,
            gh_edit_link_text: "Edit this page on GitHub",
            gh_edit_branch: "main",
            gh_root: "docs/",
            gh_edit_view_mode: "edit",
            writeStubs: true,
            description: "Personal knowledge space",
        });
        let { siteRootDir, siteHierarchies, siteIndex, siteUrl } = out;
        if (process.env["SITE_URL"]) {
            siteUrl = process.env["SITE_URL"];
        }
        if (!siteRootDir) {
            throw `siteRootDir is undefined`;
        }
        if (!siteUrl && common_all_1.getStage() === "dev") {
            // this gets overridden in dev so doesn't matter
            siteUrl = "https://foo";
        }
        if (!siteUrl) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.INVALID_CONFIG,
                message: "siteUrl is undefined. See https://dendron.so/notes/f2ed8639-a604-4a9d-b76c-41e205fb8713.html#siteurl for more details",
            });
        }
        if (lodash_1.default.size(siteHierarchies) < 1) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.INVALID_CONFIG,
                message: `siteHiearchies must have at least one hiearchy`,
            });
        }
        siteIndex = this.getSiteIndex(config);
        return {
            ...out,
            siteIndex,
            siteUrl,
        };
    }
    static writeConfig({ wsRoot, config, }) {
        const configPath = DConfig.configPath(wsRoot);
        return common_server_1.writeYAML(configPath, config);
    }
    /**
     * Create a backup of dendron.yml with an optional custom infix string.
     * e.g.) createBackup(wsRoot, "foo") will result in a backup file name
     * `dendron.yyyy.MM.dd.HHmmssS.foo.yml`
     * @param wsRoot workspace root
     * @param infix custom string used in the backup name
     */
    static createBackup(wsRoot, infix) {
        const configPath = DConfig.configPath(wsRoot);
        const today = common_all_1.Time.now().toFormat("yyyy.MM.dd.HHmmssS");
        const prefix = `dendron.${today}.`;
        const suffix = `yml`;
        const maybeInfix = infix ? `${infix}.` : "";
        const backupName = `${prefix}${maybeInfix}${suffix}`;
        const backupPath = path_1.default.join(wsRoot, backupName);
        fs_extra_1.default.copyFileSync(configPath, backupPath);
        return backupPath;
    }
}
exports.DConfig = DConfig;
//# sourceMappingURL=config.js.map