"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Git = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
/**
 * Work directly with git repositories
 */
class Git {
    constructor(opts) {
        this.opts = opts;
    }
    static async getRepo(fpath) {
        return fs_extra_1.default.existsSync(path_1.default.join(fpath, ".git"));
    }
    async _execute(cmd) {
        const [git, ...args] = cmd.split(" ");
        return execa_1.default(git, args, { cwd: this.opts.localUrl });
    }
    async isRepo() {
        return Git.getRepo(this.opts.localUrl);
    }
    async client(gitArgs) {
        const { localUrl: cwd } = this.opts;
        const { stdout } = await execa_1.default("git", gitArgs, { cwd });
        return stdout;
    }
    async commit(opts) {
        const { msg } = opts;
        const { localUrl: cwd } = this.opts;
        await execa_1.default.command([`git commit -m '${msg}'`].join(" "), {
            shell: true,
            cwd,
        });
    }
    async add(args) {
        await this._execute(`git add ${args}`);
    }
    async clone(destOverride) {
        const { localUrl, remoteUrl } = this.opts;
        const cmdParts = ["git clone", remoteUrl];
        if (destOverride) {
            cmdParts.push(destOverride);
        }
        await execa_1.default.command(cmdParts.join(" "), {
            shell: true,
            cwd: localUrl,
        });
        return localUrl;
    }
    /** Adds the `remoteUrl` set in the constructor as a remote. */
    async remoteAdd() {
        const { remoteUrl } = this.opts;
        await this._execute(`git remote add origin ${remoteUrl}`);
    }
    async init() {
        await this._execute(`git init${this.opts.bare ? " --bare" : ""}`);
    }
    /** Equivalent to `git branch`.
     *
     * @param opts.m Can be used to rename a branch. If `opts.m.oldBranch` is not provided, it's the current branch.
     */
    async branch(opts) {
        const args = ["git", "branch"];
        if (opts.m) {
            args.push("-m");
            if (opts.m.oldBranch)
                args.push(opts.m.oldBranch);
            args.push(opts.m.newBranch);
        }
        await this._execute(args.join(" "));
    }
    async pull() {
        const { localUrl: cwd } = this.opts;
        await execa_1.default.command([`git pull --rebase`].join(" "), {
            shell: true,
            cwd,
        });
    }
    async push(setUpstream) {
        const { localUrl: cwd } = this.opts;
        let setUpstremArg = "";
        if (setUpstream)
            setUpstremArg = ` --set-upstream ${setUpstream.remote} ${setUpstream.branch}`;
        await execa_1.default.command([`git push${setUpstremArg}`].join(" "), {
            shell: true,
            cwd,
        });
    }
    // === extra commands
    async addAll() {
        await execa_1.default.command(["git add ."].join(" "), {
            shell: true,
            cwd: this.opts.localUrl,
        });
    }
    async getCommitUpTo(commit) {
        const { localUrl: cwd } = this.opts;
        const suffix = commit ? [`${commit}..HEAD`] : [];
        console.log(suffix);
        const { stdout } = await execa_1.default("git", [`log`, `--pretty=format:'%H'`].concat(suffix), { cwd });
        return stdout
            .split("\n")
            .filter((ent) => !lodash_1.default.isEmpty(ent))
            .map((ent) => lodash_1.default.trim(ent));
    }
    async getCurrentBranch() {
        const { localUrl: cwd } = this.opts;
        const { stdout } = await execa_1.default("git", [`rev-parse`, `--abbrev-ref`, `HEAD`], {
            cwd,
        });
        return stdout.trim();
    }
    async hasChanges(opts) {
        let untrackedFilesArg = "";
        if (opts && opts.untrackedFiles)
            untrackedFilesArg = ` --untracked-files=${opts.untrackedFiles}`;
        const { stdout } = await this._execute(`git status --porcelain${untrackedFilesArg}`);
        return !lodash_1.default.isEmpty(stdout);
    }
    async hasRemote() {
        const { stdout } = await this._execute("git remote");
        return !lodash_1.default.isEmpty(stdout);
    }
    /** Gets the upstream the current branch is set up to push to, or `undefined` if it is not set up to push anywhere. */
    async getUpstream() {
        try {
            const { stdout } = await this._execute("git rev-parse --abbrev-ref @{upstream}");
            return lodash_1.default.trim(stdout);
        }
        catch {
            return undefined;
        }
    }
    /**
     * @param nameOnly: If true, only return the file names. Otherwise the full diff including contents is returned.
     * @param oldCommit: The old identifier (e.g. commit, tag, branch) that we are diffing against.
     * @param newCommit: The new identifier (e.g. commit, tag, branch) that we are diffing from.
     */
    async diff({ nameOnly, oldCommit, newCommit, }) {
        const nameOnlyOption = nameOnly ? "--name-only" : "";
        if (lodash_1.default.isUndefined(oldCommit))
            oldCommit = "";
        if (lodash_1.default.isUndefined(newCommit))
            newCommit = "";
        const { stdout } = await this._execute(`git diff ${nameOnlyOption} ${oldCommit} ${newCommit}`);
        return lodash_1.default.trim(stdout);
    }
}
exports.Git = Git;
//# sourceMappingURL=git.js.map