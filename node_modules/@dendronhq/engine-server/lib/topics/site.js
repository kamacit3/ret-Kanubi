"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SiteUtils = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../config");
const utils_1 = require("../utils");
const LOGGER_NAME = "SiteUtils";
class SiteUtils {
    static canPublish(opts) {
        var _a, _b;
        const { note, config, engine } = opts;
        const { wsRoot, vaults } = engine;
        // not private note
        if (((_a = note.custom) === null || _a === void 0 ? void 0 : _a.published) === false) {
            return false;
        }
        // check if note is note blocked
        const hconfig = this.getConfigForHierarchy({
            config: config.site,
            noteOrName: note,
        });
        const noteVault = common_all_1.VaultUtils.matchVault({
            vault: note.vault,
            vaults,
            wsRoot,
        });
        common_all_1.assert(noteVault !== false, `noteVault ${note.vault.fsPath} should exist`);
        const cNoteVault = noteVault;
        // not from private vault
        if (noteVault.visibility &&
            noteVault.visibility === common_all_1.DVaultVisibility.PRIVATE) {
            return false;
        }
        // check if allowed in hconfig
        let publishByDefault = undefined;
        if (!lodash_1.default.isUndefined(hconfig === null || hconfig === void 0 ? void 0 : hconfig.publishByDefault)) {
            // handle property being a boolean or an object
            publishByDefault = lodash_1.default.isBoolean(hconfig.publishByDefault)
                ? hconfig.publishByDefault
                : hconfig.publishByDefault[common_all_1.VaultUtils.getName(cNoteVault)];
        }
        if (!publishByDefault && !(((_b = note.custom) === null || _b === void 0 ? void 0 : _b.published) === true)) {
            return false;
        }
        return true;
    }
    static isPublished(opts) {
        const { note, config } = opts;
        // check if note is in index
        const domain = common_all_1.DNodeUtils.domainName(note.fname);
        if (config.site.siteHierarchies[0] !== "root" &&
            config.site.siteHierarchies.indexOf(domain) < 0) {
            return false;
        }
        return this.canPublish(opts);
    }
    static async copyAssets(opts) {
        const { wsRoot, vault, siteAssetsDir, deleteSiteAssetsDir } = opts;
        const vaultAssetsDir = path_1.default.join(common_server_1.vault2Path({ wsRoot, vault }), "assets");
        if (fs_extra_1.default.existsSync(siteAssetsDir) && deleteSiteAssetsDir) {
            console.log("removing existing assets");
            fs_extra_1.default.removeSync(siteAssetsDir);
        }
        if (fs_extra_1.default.existsSync(vaultAssetsDir)) {
            // TODO: be smarter about this
            return fs_extra_1.default.copy(path_1.default.join(vaultAssetsDir), siteAssetsDir, {
                overwrite: true,
                errorOnExist: false,
            });
        }
        return;
    }
    static addSiteOnlyNotes(opts) {
        const { engine } = opts;
        const vaults = engine.vaults;
        const note = common_all_1.NoteUtils.create({
            vault: vaults[0],
            fname: "403",
            id: "403",
            title: "This page has not yet sprouted",
            body: [
                "[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page",
                "",
                "![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)",
            ].join("\n"),
        });
        const changelog = common_all_1.NoteUtils.create({
            vault: vaults[0],
            fname: "root.changelog",
            id: "changelog",
            title: "Changelog",
            body: [].join("\n"),
        });
        return [note, changelog];
    }
    static async filterByConfig(opts) {
        const logger = common_server_1.createLogger(LOGGER_NAME);
        const { engine, config } = opts;
        const notes = lodash_1.default.clone(engine.notes);
        config.site = config_1.DConfig.cleanSiteConfig(config.site);
        const sconfig = config.site;
        const { siteHierarchies } = sconfig;
        logger.info({ ctx: "filterByConfig", config });
        let domains = [];
        let hiearchiesToPublish = [];
        // async pass to process all notes
        const domainsAndhiearchiesToPublish = await Promise.all(siteHierarchies.map(async (domain, idx) => {
            const out = await SiteUtils.filterByHiearchy({
                domain,
                config,
                engine,
                navOrder: idx,
            });
            if (lodash_1.default.isUndefined(out)) {
                return undefined;
            }
            return out;
        }));
        // synchronous pass to add notes in order
        lodash_1.default.forEach(domainsAndhiearchiesToPublish, (ent) => {
            if (lodash_1.default.isUndefined(ent)) {
                return;
            }
            const { domain, notes } = ent;
            domains.push(domain);
            hiearchiesToPublish.push(notes);
        });
        // if single hiearchy, domain includes all immediate children
        if (!opts.noExpandSingleDomain &&
            siteHierarchies.length === 1 &&
            domains.length === 1) {
            const rootDomain = domains[0];
            // special case, check if any of these children were supposed to be hidden
            domains = domains
                .concat(rootDomain.children.map((id) => notes[id]))
                .filter((note) => this.canPublish({ note, config, engine }));
        }
        logger.info({
            ctx: "filterByConfig",
            domains: domains.map((ent) => ent.fname),
        });
        return {
            notes: lodash_1.default.reduce(hiearchiesToPublish, (ent, acc) => {
                return lodash_1.default.merge(acc, ent);
            }, {}),
            domains,
        };
    }
    /**
     * Filter notes to be published using hiearchy
     */
    static async filterByHiearchy(opts) {
        const { domain, engine, navOrder, config } = opts;
        const logger = common_server_1.createLogger(LOGGER_NAME);
        logger.info({ ctx: "filterByHiearchy:enter", domain, config });
        const sconfig = config.site;
        let hConfig = this.getConfigForHierarchy({
            config: sconfig,
            noteOrName: domain,
        });
        const notesForHiearchy = lodash_1.default.clone(engine.notes);
        // get the domain note
        let notes = common_all_1.NoteUtils.getNotesByFname({
            fname: domain,
            notes: notesForHiearchy,
        });
        logger.info({
            ctx: "filterByHiearchy:candidates",
            domain,
            hConfig,
            notes: notes.map((ent) => ent.id),
        });
        let domainNote;
        if (notes.length > 1) {
            domainNote = SiteUtils.handleDup({
                allowStubs: false,
                dupBehavior: sconfig.duplicateNoteBehavior,
                engine,
                config,
                fname: domain,
                noteCandidates: notes,
                noteDict: notesForHiearchy,
            });
        }
        else if (notes.length < 1) {
            logger.error({ ctx: "filterByHiearchy", msg: "note not found", domain });
            // TODO: add warning
            return;
        }
        else {
            domainNote = { ...notes[0] };
        }
        if (lodash_1.default.isUndefined(domainNote) ||
            !this.canPublish({ note: domainNote, config, engine })) {
            return;
        }
        if (!domainNote.custom) {
            domainNote.custom = {};
        }
        // set domain note settings
        domainNote.custom.nav_order = navOrder;
        domainNote.parent = null;
        if (domainNote.fname === sconfig.siteIndex) {
            domainNote.custom.permalink = "/";
        }
        logger.info({
            ctx: "filterByHiearchy",
            fname: domainNote.fname,
            domainNote: common_all_1.NoteUtils.toLogObj(domainNote),
        });
        const out = {};
        const processQ = [domainNote];
        while (!lodash_1.default.isEmpty(processQ)) {
            const note = processQ.pop();
            logger.debug({
                ctx: "filterByHiearchy",
                fname: note.fname,
                note: common_all_1.NoteUtils.toLogObj(note),
            });
            // check if we can publish this note
            const maybeNote = SiteUtils.filterByNote({ note, hConfig });
            if (maybeNote) {
                if (sconfig.writeStubs && maybeNote.stub) {
                    maybeNote.stub = false;
                    await engine.writeNote(note);
                }
                const siteFM = maybeNote.custom || {};
                // if we skip, wire new children to current note
                let children = utils_1.HierarchyUtils.getChildren({
                    skipLevels: siteFM.skipLevels || 0,
                    note: maybeNote,
                    notes: notesForHiearchy,
                });
                if (siteFM.skipLevels && siteFM.skipLevels > 0) {
                    maybeNote.children = children.map((ent) => ent.id);
                    children.forEach((ent) => (ent.parent = maybeNote.id));
                }
                // remove any children that shouldn't be published
                children = lodash_1.default.filter(children, (note) => SiteUtils.canPublish({
                    note,
                    config,
                    engine,
                }));
                logger.debug({
                    ctx: "filterByHiearchy:post-filter-children",
                    note: note.fname,
                    children: children.map((ent) => ent.id),
                });
                // TODO: handle dups
                // add children to Q
                children.forEach((n) => {
                    // update parent to be current note
                    // dup merging at the top could cause children from multiple vaults
                    // to be present
                    n.parent = maybeNote.id;
                    processQ.push(n);
                });
                // updated children
                out[maybeNote.id] = {
                    ...maybeNote,
                    children: children.map((ent) => ent.id),
                };
            }
        }
        return { notes: out, domain: domainNote };
    }
    static filterByNote(opts) {
        var _a;
        const { note, hConfig } = opts;
        // apply custom frontmatter if exist
        (_a = hConfig.customFrontmatter) === null || _a === void 0 ? void 0 : _a.forEach((fm) => {
            const { key, value } = fm;
            // @ts-ignore
            meta[key] = value;
        });
        if (hConfig.noindexByDefault && !lodash_1.default.has(note, "custom.noindex")) {
            lodash_1.default.set(note, "custom.noindex", true);
        }
        // remove site-only stuff
        return {
            ...note,
            body: utils_1.stripLocalOnlyTags(note.body),
        };
    }
    static getConfigForHierarchy(opts) {
        const { config, noteOrName } = opts;
        const fname = lodash_1.default.isString(noteOrName) ? noteOrName : noteOrName.fname;
        const domain = common_all_1.DNodeUtils.domainName(fname);
        const siteConfig = config;
        // get config
        let rConfig = lodash_1.default.defaults(lodash_1.default.get(siteConfig.config, "root", {
            publishByDefault: true,
            noindexByDefault: false,
            customFrontmatter: [],
        }));
        let hConfig = lodash_1.default.defaults(lodash_1.default.get(siteConfig.config, domain), rConfig);
        return hConfig;
    }
    static getDomains(opts) {
        const { notes, config } = opts;
        if (config.siteHierarchies.length === 1) {
            const fname = config.siteHierarchies[0];
            const rootNotes = common_all_1.NoteUtils.getNotesByFname({ fname, notes });
            return [rootNotes[0]].concat(rootNotes[0].children.map((ent) => notes[ent]));
        }
        else {
            return lodash_1.default.filter(lodash_1.default.values(notes), { parent: null });
        }
    }
    static getSiteOutputPath(opts) {
        const { config, wsRoot, stage } = opts;
        let siteRootPath;
        if (stage === "dev") {
            siteRootPath = path_1.default.join(wsRoot, "build", "site");
            fs_extra_1.default.ensureDirSync(siteRootPath);
        }
        else {
            siteRootPath = common_server_1.resolvePath(config.site.siteRootDir, wsRoot);
        }
        return siteRootPath;
    }
    static handleDup(opts) {
        const { engine, fname, noteCandidates, noteDict, config, dupBehavior, allowStubs, } = lodash_1.default.defaults(opts, {
            dupBehavior: {
                action: common_all_1.DuplicateNoteAction.USE_VAULT,
                payload: [],
            },
            allowStubs: true,
        });
        const ctx = "handleDup";
        let domainNote;
        if (lodash_1.default.isArray(dupBehavior.payload)) {
            const vaultNames = dupBehavior.payload;
            lodash_1.default.forEach(vaultNames, (vname) => {
                if (domainNote) {
                    return;
                }
                const vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
                    vname,
                    vaults: engine.vaults,
                });
                const maybeNote = common_all_1.NoteUtils.getNoteByFnameV5({
                    fname,
                    notes: noteDict,
                    vault,
                    wsRoot: engine.wsRoot,
                });
                if (maybeNote && maybeNote.stub && !allowStubs) {
                    return;
                }
                if (maybeNote &&
                    this.canPublish({
                        config,
                        note: maybeNote,
                        engine,
                    })) {
                    domainNote = maybeNote;
                    const logger = common_server_1.createLogger(LOGGER_NAME);
                    logger.info({
                        ctx,
                        status: "found",
                        note: common_all_1.NoteUtils.toLogObj(domainNote),
                    });
                }
            });
            if (!domainNote) {
                throw new common_all_1.DendronError({
                    message: `no notes found for ${fname} in vaults ${vaultNames}`,
                });
            }
        }
        else {
            const vault = dupBehavior.payload.vault;
            let maybeDomainNotes = noteCandidates.filter((n) => common_all_1.VaultUtils.isEqual(n.vault, vault, engine.wsRoot));
            const logger = common_server_1.createLogger(LOGGER_NAME);
            if (maybeDomainNotes.length < 1) {
                logger.error({
                    ctx: "filterByHiearchy",
                    msg: "dup-resolution: no note found",
                    vault,
                });
                throw new common_all_1.DendronError({
                    message: `no notes found for ${fname} in vault ${vault.fsPath}`,
                });
            }
            if (!this.canPublish({
                config,
                note: maybeDomainNotes[0],
                engine,
            })) {
                return;
            }
            domainNote = maybeDomainNotes[0];
        }
        let domainId = domainNote.id;
        // merge children
        domainNote.children = getUniqueChildrenIds(noteCandidates);
        // update parents
        domainNote.children.map((id) => {
            const maybeNote = noteDict[id];
            maybeNote.parent = domainId;
        });
        const logger = common_server_1.createLogger(LOGGER_NAME);
        logger.info({
            ctx: "filterByHiearchy",
            msg: "dup-resolution: resolving dup",
            parent: domainNote.id,
            children: domainNote.children,
        });
        return domainNote;
    }
    static validateConfig(sconfig) {
        // asset prefix needs one slash
        if (!lodash_1.default.isUndefined(sconfig.assetsPrefix)) {
            if (!sconfig.assetsPrefix.startsWith("/")) {
                return {
                    data: false,
                    error: new common_all_1.DendronError({
                        message: "assetsPrefix requires a '/' in front of the path",
                    }),
                };
            }
        }
        return { data: true, error: null };
    }
}
exports.SiteUtils = SiteUtils;
function getUniqueChildrenIds(notes) {
    return lodash_1.default.uniq(notes.flatMap((ent) => ent.children));
}
//# sourceMappingURL=site.js.map