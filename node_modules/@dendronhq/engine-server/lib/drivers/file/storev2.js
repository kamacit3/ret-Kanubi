"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FileStorage = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("../../markdown/remark/utils");
const hooks_1 = require("../../topics/hooks");
const utils_2 = require("../../utils");
const noteParser_1 = require("./noteParser");
const schemaParser_1 = require("./schemaParser");
const inMemoryNoteCache_1 = require("../../util/inMemoryNoteCache");
class FileStorage {
    constructor(props) {
        const { vaults, wsRoot, config } = props.engine;
        const { logger } = props;
        this.wsRoot = wsRoot;
        this.configRoot = wsRoot;
        this.vaults = vaults;
        this.notes = {};
        this.schemas = {};
        this.notesCache = {
            version: 0,
            notes: {},
        };
        this.links = [];
        this.anchors = [];
        this.logger = logger;
        const ctx = "FileStorageV2";
        this.logger.info({ ctx, wsRoot, vaults, level: this.logger.level });
        this.config = config;
        this.engine = props.engine;
    }
    async init() {
        let errors = [];
        try {
            const resp = await this.initSchema();
            if (common_all_1.ResponseUtil.hasError(resp)) {
                errors.push(FileStorage.createMalformedSchemaError(resp));
            }
            resp.data.map((ent) => {
                this.schemas[ent.root.id] = ent;
            });
            const { notes: _notes, errors: initErrors } = await this.initNotes();
            errors = errors.concat(initErrors);
            _notes.map((ent) => {
                this.notes[ent.id] = ent;
            });
            const { notes, schemas } = this;
            let error = errors[0] || null;
            if (errors.length > 1) {
                error = new common_all_1.DendronCompositeError(errors);
            }
            return {
                data: {
                    notes,
                    schemas,
                    wsRoot: this.wsRoot,
                    config: this.config,
                    vaults: this.vaults,
                },
                error,
            };
        }
        catch (err) {
            this.logger.error(err);
            throw err;
        }
    }
    static createMalformedSchemaError(resp) {
        return new common_all_1.DendronError({
            message: "schema malformed",
            severity: common_all_1.ERROR_SEVERITY.MINOR,
            payload: { schema: resp.error },
        });
    }
    async deleteNote(id, opts) {
        const ctx = "deleteNote";
        if (id === "root") {
            throw new common_all_1.DendronError({
                message: "",
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const noteToDelete = this.notes[id];
        this.logger.info({ ctx, noteToDelete, opts, id });
        if (lodash_1.default.isUndefined(noteToDelete))
            throw new common_all_1.DendronError({
                message: `Unable to find node ${id}`,
                severity: common_all_1.ERROR_SEVERITY.FATAL,
                payload: ctx,
            });
        const ext = ".md";
        const vault = noteToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, noteToDelete.fname + ext);
        let out = [];
        const noteAsLog = common_all_1.NoteUtils.toLogObj(noteToDelete);
        // remove from fs
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            this.logger.info({ ctx, noteAsLog, msg: "removing from disk", fpath });
            fs_extra_1.default.unlinkSync(fpath);
        }
        // if have children, keep this node around as a stub
        if (!lodash_1.default.isEmpty(noteToDelete.children)) {
            this.logger.info({ ctx, noteAsLog, msg: "keep as stub" });
            noteToDelete.stub = true;
            this.updateNote(noteToDelete);
            out.push({ note: noteToDelete, status: "update" });
        }
        else {
            // no children, delete reference from parent
            this.logger.info({ ctx, noteAsLog, msg: "delete from parent" });
            if (!noteToDelete.parent) {
                throw common_all_1.DendronError.createFromStatus({
                    status: common_all_1.ERROR_STATUS.NO_PARENT_FOR_NOTE,
                });
            }
            // remove from parent
            let parentNote = this.notes[noteToDelete.parent];
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === noteToDelete.id);
            // delete from note dictionary
            delete this.notes[noteToDelete.id];
            // if parent note is not a stub, update it
            if (!parentNote.stub) {
                out.push({ note: parentNote, status: "update" });
            }
            out.push({ note: noteToDelete, status: "delete" });
            // check all stubs
            const resps = [];
            while (parentNote.stub && !(opts === null || opts === void 0 ? void 0 : opts.noDeleteParentStub)) {
                const newParent = parentNote.parent;
                const resp = this.deleteNote(parentNote.id, {
                    metaOnly: true,
                    noDeleteParentStub: true,
                });
                resps.push(resp);
                if (newParent) {
                    parentNote = this.notes[newParent];
                }
                else {
                    common_all_1.assert(false, "illegal state in note delete");
                }
            }
            for (const resp of await Promise.all(resps)) {
                out = out.concat(resp);
            }
        }
        return out;
    }
    async deleteSchema(id, opts) {
        const ctx = "deleteSchema";
        this.logger.info({ ctx, msg: "enter", id });
        if (id === "root") {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.CANT_DELETE_ROOT,
            });
        }
        const schemaToDelete = this.schemas[id];
        const ext = ".schema.yml";
        const vault = schemaToDelete.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const fpath = path_1.default.join(vpath, schemaToDelete.fname + ext);
        if (!(opts === null || opts === void 0 ? void 0 : opts.metaOnly)) {
            fs_extra_1.default.unlinkSync(fpath);
        }
        delete this.schemas[id];
        return this.init();
    }
    async initSchema() {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const out = await Promise.all(this.vaults.map(async (vault) => {
            return this._initSchema(vault);
        }));
        const _out = lodash_1.default.reduce(out, (ent, acc) => {
            acc.data = acc.data.concat(ent.data);
            acc.errors = acc.errors.concat(ent.errors);
            return acc;
        }, { data: [], errors: [] });
        const { data, errors } = _out;
        return {
            data,
            error: lodash_1.default.isEmpty(errors)
                ? null
                : new common_all_1.DendronError({ message: "multiple errors", payload: errors }),
        };
    }
    async _initSchema(vault) {
        const ctx = "initSchema";
        this.logger.info({ ctx, msg: "enter" });
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        const schemaFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.schema.yml"],
        });
        this.logger.info({ ctx, schemaFiles });
        if (lodash_1.default.isEmpty(schemaFiles)) {
            throw common_all_1.DendronError.createFromStatus({
                status: common_all_1.ERROR_STATUS.NO_SCHEMA_FOUND,
            });
        }
        const { schemas, errors } = await new schemaParser_1.SchemaParser({
            store: this,
            logger: this.logger,
        }).parse(schemaFiles, vault);
        return {
            data: schemas,
            errors: lodash_1.default.isNull(errors) ? [] : errors,
        };
    }
    async initNotes() {
        var _a;
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        let notesWithLinks = [];
        let errors = [];
        const out = await Promise.all(this.vaults.map(async (vault) => {
            const { notes, cacheUpdates, cache, errors: initErrors, } = await this._initNotes(vault);
            errors = errors.concat(initErrors);
            notesWithLinks = notesWithLinks.concat(lodash_1.default.filter(notes, (n) => !lodash_1.default.isEmpty(n.links)));
            this.logger.info({
                ctx,
                vault,
                numEntries: lodash_1.default.size(notes),
                numCacheUpdates: lodash_1.default.size(cacheUpdates),
            });
            const newCache = {
                version: cache.version,
                notes: lodash_1.default.defaults(cacheUpdates, cache.notes),
            };
            const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
            // OPT:make async and don't wait for return
            if (!this.engine.config.noCaching) {
                utils_2.writeNotesToCache(vpath, newCache);
            }
            return notes;
        }));
        const allNotes = lodash_1.default.flatten(out);
        this._addBacklinks({ notesWithLinks, allNotes });
        if ((_a = this.engine.config.dev) === null || _a === void 0 ? void 0 : _a.enableLinkCandidates) {
            const ctx = "_addLinkCandidates";
            const start = process.hrtime();
            this._addLinkCandidates(allNotes);
            const duration = common_server_1.getDurationMilliseconds(start);
            this.logger.info({ ctx, duration });
        }
        return { notes: allNotes, errors };
    }
    /** Adds backlinks mutating 'allNotes' argument in place. */
    _addBacklinks({ notesWithLinks, allNotes, }) {
        const ctx = "_addBacklinks:ext";
        const start = process.hrtime();
        this._addBacklinksImpl(allNotes, notesWithLinks);
        const duration = common_server_1.getDurationMilliseconds(start);
        this.logger.info({ ctx, duration });
    }
    _addBacklinksImpl(allNotes, notesWithLinks) {
        const noteCache = new inMemoryNoteCache_1.InMemoryNoteCache(allNotes);
        notesWithLinks.forEach((noteFrom) => {
            try {
                noteFrom.links.forEach((link) => {
                    var _a;
                    const fname = (_a = link.to) === null || _a === void 0 ? void 0 : _a.fname;
                    if (fname) {
                        const notes = noteCache.getNotesByFileNameIgnoreCase(fname);
                        notes.forEach((noteTo) => {
                            common_all_1.NoteUtils.addBacklink({
                                from: noteFrom,
                                to: noteTo,
                                link,
                            });
                        });
                    }
                });
            }
            catch (err) {
                const error = common_all_1.error2PlainObject(err);
                this.logger.error({ error, noteFrom, message: "issue with backlinks" });
            }
        });
    }
    _addLinkCandidates(allNotes) {
        const notesMap = common_all_1.NoteUtils.createFnameNoteMap(allNotes, true);
        return lodash_1.default.map(allNotes, (noteFrom) => {
            try {
                const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(this.config).maxNoteLength;
                if (noteFrom.body.length <
                    (maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH)) {
                    const linkCandidates = utils_1.LinkUtils.findLinkCandidates({
                        note: noteFrom,
                        notesMap,
                        engine: this.engine,
                    });
                    noteFrom.links = noteFrom.links.concat(linkCandidates);
                }
            }
            catch (err) {
                const error = common_all_1.error2PlainObject(err);
                this.logger.error({
                    error,
                    noteFrom,
                    message: "issue with link candidates",
                });
                return;
            }
        });
    }
    async _initNotes(vault) {
        const ctx = "initNotes";
        this.logger.info({ ctx, msg: "enter" });
        const wsRoot = this.wsRoot;
        const vpath = common_server_1.vault2Path({ vault, wsRoot });
        const noteFiles = common_server_1.getAllFiles({
            root: vpath,
            include: ["*.md"],
        });
        let errors = [];
        const cache = !this.engine.config.noCaching
            ? utils_2.readNotesFromCache(vpath)
            : { version: 0, notes: {} };
        const { notes, cacheUpdates, errors: parseErrors, } = await new noteParser_1.NoteParser({
            store: this,
            cache,
            logger: this.logger,
        }).parseFile(noteFiles, vault);
        errors = errors.concat(parseErrors);
        this.logger.info({ ctx, msg: "parseNotes:fin" });
        await Promise.all(notes.map(async (n) => {
            this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(n) });
            if (n.stub) {
                return;
            }
            const maxNoteLength = common_all_1.ConfigUtils.getWorkspace(this.config).maxNoteLength;
            if (n.body.length >=
                (maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH)) {
                this.logger.info({
                    ctx,
                    msg: "Note too large, skipping",
                    note: common_all_1.NoteUtils.toLogObj(n),
                    length: n.body.length,
                });
                errors.push(new common_all_1.DendronError({
                    message: `Note "${n.fname}" in vault "${common_all_1.VaultUtils.getName(n.vault)}" is longer than ${maxNoteLength || common_all_1.CONSTANTS.DENDRON_DEFAULT_MAX_NOTE_LENGTH} characters, some features like backlinks may not work correctly for it. ` +
                        `You may increase "maxNoteLength" in "dendron.yml" to override this warning.`,
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                }));
                n.links = [];
                n.anchors = {};
                return;
            }
            if (lodash_1.default.has(cacheUpdates, n.fname)) {
                try {
                    const links = utils_1.LinkUtils.findLinks({
                        note: n,
                        engine: this.engine,
                    });
                    cacheUpdates[n.fname].data.links = links;
                    n.links = links;
                }
                catch (err) {
                    let error = err;
                    if (!(err instanceof common_all_1.DendronError)) {
                        error = new common_all_1.DendronError({
                            message: `Failed to read links in note ${n.fname}`,
                            payload: err,
                        });
                    }
                    errors.push(error);
                    this.logger.error({ ctx, error: err, note: common_all_1.NoteUtils.toLogObj(n) });
                    return;
                }
                try {
                    const anchors = await utils_1.AnchorUtils.findAnchors({
                        note: n,
                        wsRoot,
                    });
                    cacheUpdates[n.fname].data.anchors = anchors;
                    n.anchors = anchors;
                }
                catch (err) {
                    let error = err;
                    if (!(err instanceof common_all_1.DendronError)) {
                        error = new common_all_1.DendronError({
                            message: `Failed to read headers or block anchors in note ${n.fname}`,
                            payload: err,
                        });
                    }
                    errors.push(error);
                    return;
                }
            }
            else {
                n.links = cache.notes[n.fname].data.links;
            }
            return;
        }));
        return { notes, cacheUpdates, cache, errors };
    }
    async bulkAddNotes(opts) {
        this.logger.info({ ctx: "bulkAddNotes", msg: "enter" });
        await Promise.all(opts.notes.map((note) => {
            return common_server_1.note2File({
                note,
                vault: note.vault,
                wsRoot: this.wsRoot,
            });
        }));
        const notesChanged = opts.notes.map((n) => {
            return { note: n, status: "create" };
        });
        return {
            error: null,
            data: notesChanged,
        };
    }
    referenceRangeParts(anchorHeader) {
        if (!anchorHeader || anchorHeader.indexOf(":") === -1)
            return [];
        let [start, end] = anchorHeader.split(":");
        start = start.replace(/^#*/, "");
        end = end.replace(/^#*/, "");
        return [start, end];
    }
    async renameNote(opts) {
        const ctx = "Store:renameNote";
        const { oldLoc, newLoc } = opts;
        const { wsRoot } = this;
        this.logger.info({ ctx, msg: "enter", opts });
        const oldVault = common_all_1.VaultUtils.getVaultByName({
            vaults: this.engine.vaults,
            vname: oldLoc.vaultName,
        });
        if (!oldVault) {
            throw new common_all_1.DendronError({ message: "vault not set for loation" });
        }
        const vpath = common_server_1.vault2Path({ wsRoot, vault: oldVault });
        const oldLocPath = path_1.default.join(vpath, oldLoc.fname + ".md");
        // read from disk since contents migh have changed
        const noteRaw = common_server_1.file2Note(oldLocPath, oldVault);
        const oldNote = common_all_1.NoteUtils.hydrate({
            noteRaw,
            noteHydrated: this.notes[noteRaw.id],
        });
        const newNoteTitle = common_all_1.NoteUtils.isDefaultTitle(oldNote)
            ? common_all_1.NoteUtils.genTitle(newLoc.fname)
            : oldNote.title;
        // If the rename operation is changing the title and the caller did not tell us to use a special alias, calculate the alias change.
        // The aliases of links to this note will only change if they match the old note's title.
        if (newNoteTitle !== oldNote.title && !oldLoc.alias && !newLoc.alias) {
            oldLoc.alias = oldNote.title;
            newLoc.alias = newNoteTitle;
        }
        let notesChangedEntries = [];
        const notesToChange = await common_all_1.NoteUtils.getNotesWithLinkTo({
            note: oldNote,
            notes: this.notes,
        });
        this.logger.info({
            ctx,
            msg: "notesToChange:gather",
            notes: notesToChange.map((n) => common_all_1.NoteUtils.toLogObj(n)),
        });
        // update note body of all notes that have changed
        const notesChanged = await Promise.all(notesToChange.map(async (n) => {
            const vault = n.vault;
            const vaultPath = common_server_1.vault2Path({ vault, wsRoot });
            // read note in case its changed
            const _n = common_server_1.file2Note(path_1.default.join(vaultPath, n.fname + ".md"), vault);
            const foundLinks = utils_1.LinkUtils.findLinks({
                note: _n,
                engine: this.engine,
                filter: { loc: oldLoc },
            });
            let allLinks = lodash_1.default.orderBy(foundLinks, (link) => {
                var _a;
                return (_a = link.position) === null || _a === void 0 ? void 0 : _a.start.offset;
            }, "desc");
            if (oldLoc.fname === newLoc.fname &&
                oldLoc.vaultName === newLoc.vaultName &&
                oldLoc.anchorHeader &&
                newLoc.anchorHeader) {
                // Renaming the header, only update links that link to the old header
                allLinks = lodash_1.default.filter(allLinks, (link) => {
                    var _a, _b;
                    // This is a wikilink to this header
                    if (((_a = link.to) === null || _a === void 0 ? void 0 : _a.anchorHeader) === oldLoc.anchorHeader)
                        return true;
                    // Or this is a range reference, and one part of the range includes this header
                    return (link.type === "ref" &&
                        common_all_1.isNotUndefined(oldLoc.anchorHeader) &&
                        this.referenceRangeParts((_b = link.to) === null || _b === void 0 ? void 0 : _b.anchorHeader).includes(oldLoc.anchorHeader));
                });
            }
            const noteMod = lodash_1.default.reduce(allLinks, (note, link) => {
                var _a;
                const oldLink = utils_1.LinkUtils.dlink2DNoteLink(link);
                // current implementation adds alias for all notes
                // check if old note has alias thats different from its fname
                let alias;
                if (oldLink.from.alias &&
                    oldLink.from.alias !== oldLink.from.fname) {
                    alias = oldLink.from.alias;
                    // Update the alias if it was using the default alias.
                    if (((_a = oldLoc.alias) === null || _a === void 0 ? void 0 : _a.toLocaleLowerCase()) ===
                        oldLink.from.alias.toLocaleLowerCase() &&
                        newLoc.alias) {
                        alias = newLoc.alias;
                    }
                }
                // for hashtag links, we'll have to regenerate the alias
                if (newLoc.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                    const fnameWithoutTag = newLoc.fname.slice(common_all_1.TAGS_HIERARCHY.length);
                    // Frontmatter tags don't have the hashtag
                    if (link.type !== "frontmatterTag")
                        alias = `#${fnameWithoutTag}`;
                    else
                        alias = fnameWithoutTag;
                }
                else if (oldLink.from.fname.startsWith(common_all_1.TAGS_HIERARCHY)) {
                    // If this used to be a hashtag but no longer is, the alias is like `#foo.bar` and no longer makes sense.
                    // And if this used to be a frontmatter tag, the alias being undefined will force it to be removed because a frontmatter tag can't point to something outside of tags hierarchy.
                    alias = undefined;
                }
                // for user tag links, we'll have to regenerate the alias
                if (newLoc.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                    const fnameWithoutTag = newLoc.fname.slice(common_all_1.USERS_HIERARCHY.length);
                    alias = `@${fnameWithoutTag}`;
                }
                else if (oldLink.from.fname.startsWith(common_all_1.USERS_HIERARCHY)) {
                    // If this used to be a user tag but no longer is, the alias is like `@foo.bar` and no longer makes sense.
                    alias = undefined;
                }
                // Correctly handle header renames in references with range based references
                if (oldLoc.anchorHeader &&
                    link.type === "ref" &&
                    common_all_1.isNotUndefined(oldLink.from.anchorHeader) &&
                    oldLink.from.anchorHeader.indexOf(":") > -1 &&
                    common_all_1.isNotUndefined(newLoc.anchorHeader) &&
                    newLoc.anchorHeader.indexOf(":") === -1) {
                    // This is a reference, old anchor had a ":" in it, a new anchor header is provided and does not have ":" in it.
                    // For example, `![[foo#start:#end]]` to `![[foo#something]]`. In this case, `something` is actually supposed to replace only one part of the range.
                    // Find the part that matches the old header, and replace just that with the new one.
                    let [start, end] = this.referenceRangeParts(oldLink.from.anchorHeader);
                    if (start === oldLoc.anchorHeader)
                        start = newLoc.anchorHeader;
                    if (end === oldLoc.anchorHeader)
                        end = newLoc.anchorHeader;
                    newLoc.anchorHeader = `${start}:#${end}`;
                }
                const newBody = utils_1.LinkUtils.updateLink({
                    note,
                    oldLink,
                    newLink: {
                        ...oldLink,
                        from: {
                            ...newLoc,
                            anchorHeader: newLoc.anchorHeader || oldLink.from.anchorHeader,
                            alias,
                        },
                    },
                });
                _n.body = newBody;
                return _n;
            }, _n);
            // const resp = await MDUtilsV4.procTransform(
            //   { engine: this.engine, fname: n.fname, vault: n.vault },
            //   { from: oldLoc, to: newLoc }
            // ).process(_n.body);
            n.body = noteMod.body;
            n.tags = noteMod.tags;
            return n;
        })).catch((err) => {
            this.logger.error({ err });
            throw new common_all_1.DendronError({ message: " error rename note", payload: err });
        });
        /**
         * If the event source is not engine(ie: vscode rename context menu), we do not want to
         * delete the original files. We just update the references on onWillRenameFiles and return.
         */
        if (!lodash_1.default.isUndefined(opts.isEventSourceEngine)) {
            notesChangedEntries = await this.updateOldNoteReferences(notesChanged, ctx, notesChangedEntries);
            return notesChangedEntries;
        }
        const newNote = {
            ...oldNote,
            fname: newLoc.fname,
            vault: common_all_1.VaultUtils.getVaultByName({
                vaults: this.vaults,
                vname: newLoc.vaultName,
            }),
            title: newNoteTitle,
        };
        // NOTE: order matters. need to delete old note, otherwise can't write new note
        this.logger.info({
            ctx,
            msg: "deleteNote:meta:pre",
            note: common_all_1.NoteUtils.toLogObj(oldNote),
        });
        let deleteOldFile = false;
        let changedFromDelete = [];
        let changeFromWrite;
        if (oldNote.fname === newNote.fname &&
            common_all_1.VaultUtils.isEqual(oldNote.vault, newNote.vault, wsRoot)) {
            // The file is being renamed to itself. We do this to rename a header.
            this.logger.info({ ctx, msg: "Renaming the file to same name" });
            const out = await this.writeNote(newNote, { updateExisting: true });
            changeFromWrite = out.data;
        }
        else {
            // The file is being renamed to a new file.
            this.logger.info({ ctx, msg: "Renaming the file to a new name" });
            try {
                changedFromDelete = await this.deleteNote(oldNote.id, {
                    metaOnly: true,
                });
            }
            catch (err) {
                throw new common_all_1.DendronError({
                    message: `Unable to delete note "${oldNote.fname}" in vault "${common_all_1.VaultUtils.getName(oldNote.vault)}".` +
                        ` Check that this note exists, and make sure it has a frontmatter with an id.`,
                    severity: common_all_1.ERROR_SEVERITY.FATAL,
                    payload: err,
                });
            }
            deleteOldFile = true;
            this.logger.info({
                ctx,
                msg: "writeNewNote:pre",
                note: common_all_1.NoteUtils.toLogObj(newNote),
            });
            const out = await this.writeNote(newNote, { newNode: true });
            changeFromWrite = out.data;
        }
        this.logger.info({ ctx, msg: "updateAllNotes:pre" });
        // update all new notes
        notesChangedEntries = await this.updateOldNoteReferences(notesChanged, ctx, notesChangedEntries);
        // remove old note only when rename is success
        if (deleteOldFile)
            fs_extra_1.default.removeSync(oldLocPath);
        // create needs to be very last element added
        notesChangedEntries = changedFromDelete
            .concat(changeFromWrite)
            .concat(notesChangedEntries);
        // remove duplicate updates
        notesChangedEntries = lodash_1.default.uniqBy(notesChangedEntries, (ent) => {
            return [ent.status, ent.note.id, ent.note.fname].join("");
        });
        this.logger.info({ ctx, msg: "exit", opts, out: notesChangedEntries });
        return notesChangedEntries;
    }
    /**
     *  method to update references of old note
     */
    async updateOldNoteReferences(notesChanged, ctx, notesChangedEntries) {
        await Promise.all(notesChanged.map(async (n) => {
            this.logger.info({
                ctx,
                msg: "writeNote:pre",
                note: common_all_1.NoteUtils.toLogObj(n),
            });
            return this.writeNote(n, { updateExisting: true });
        }));
        notesChangedEntries = notesChangedEntries.concat(notesChanged.map((note) => ({
            status: "update",
            note,
        })));
        return notesChangedEntries;
    }
    /**
     * Update a note. If note exists, call {@link NoteUtils.hydrate} to populate new note with parent/children properties
     * of the existing note
     *
     * If {@link newNode} is set, set the {@link NoteProps["parent"]} property and create stubs as necessary
     *
     * @param note
     * @param opts
     * @returns
     */
    async updateNote(note, opts) {
        const ctx = "updateNote";
        this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(note), msg: "enter" });
        const maybeNote = this.notes[note.id];
        if (maybeNote) {
            note = common_all_1.NoteUtils.hydrate({ noteRaw: note, noteHydrated: maybeNote });
        }
        if (opts === null || opts === void 0 ? void 0 : opts.newNode) {
            common_all_1.NoteUtils.addParent({
                note,
                notesList: lodash_1.default.values(this.notes),
                createStubs: true,
                wsRoot: this.wsRoot,
            });
        }
        this.logger.debug({ ctx, note: common_all_1.NoteUtils.toLogObj(note) });
        this.notes[note.id] = note;
        return note;
    }
    async updateSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        // const vaultDir = this.vaults[0];
        // await schemaModuleProps2File(schemaModule, vaultDir, schemaModule.fname);
        // TODO: update notes
    }
    async _writeNewNote({ note, maybeNote, opts, }) {
        const ctx = "_writeNewNote";
        this.logger.info({
            ctx,
            msg: "enter",
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        let changed = [];
        // in this case, we are deleting the old note and writing a new note in its place with the same hierarchy
        // the parent of this note needs to have the old note removed (because the id is now different)
        // the new note needs to have the old note's children
        if (maybeNote) {
            // update changed
            const parentNote = this.notes[maybeNote.parent];
            // remove existing note from parent's children
            parentNote.children = lodash_1.default.reject(parentNote.children, (ent) => ent === maybeNote.id);
            // update parent's children
            this.notes[maybeNote.parent].children = parentNote.children;
            // move maybeNote's children to newly written note
            note.children = maybeNote.children;
            // delete maybeNote
            delete this.notes[maybeNote.id];
        }
        // check if we need to add parents
        // eg. if user created `baz.one.two` and neither `baz` or `baz.one` exist, then they need to be created
        // this is the default behavior
        if (!(opts === null || opts === void 0 ? void 0 : opts.noAddParent)) {
            changed = common_all_1.NoteUtils.addParent({
                note,
                notesList: lodash_1.default.values(this.notes),
                createStubs: true,
                wsRoot: this.wsRoot,
            });
        }
        this.logger.info({
            ctx,
            msg: "exit",
            changed: changed.map((n) => common_all_1.NoteUtils.toLogObj(n)),
        });
        return changed;
    }
    async writeNote(note, opts) {
        const ctx = `FileStore:writeNote:${note.fname}`;
        let changed = [];
        let error = null;
        this.logger.info({
            ctx,
            msg: "enter",
            opts,
            note: common_all_1.NoteUtils.toLogObj(note),
        });
        // check if note might already exist
        const maybeNote = common_all_1.NoteUtils.getNoteByFnameV5({
            fname: note.fname,
            notes: this.notes,
            vault: note.vault,
            wsRoot: this.wsRoot,
        });
        this.logger.info({
            ctx,
            msg: "check:existing",
            maybeNoteId: lodash_1.default.pick(maybeNote || {}, ["id", "stub"]),
        });
        // don't count as delete if we're updating existing note
        let noDelete = false;
        if ((maybeNote === null || maybeNote === void 0 ? void 0 : maybeNote.stub) || (opts === null || opts === void 0 ? void 0 : opts.updateExisting)) {
            note = { ...maybeNote, ...note };
            noDelete = true;
        }
        else {
            changed = await this._writeNewNote({ note, maybeNote, opts });
        }
        // add schema if applicable
        const match = common_all_1.SchemaUtils.matchPath({
            notePath: note.fname,
            schemaModDict: this.schemas,
        });
        this.logger.info({
            ctx,
            msg: "pre:note2File",
        });
        if ((opts === null || opts === void 0 ? void 0 : opts.runHooks) === false) {
            this.logger.info({
                ctx,
                msg: "hooks disabled for write",
            });
        }
        else {
            const hooks = lodash_1.default.filter(this.engine.hooks.onCreate, (hook) => common_all_1.NoteUtils.match({ notePath: note.fname, pattern: hook.pattern }));
            const resp = await lodash_1.default.reduce(hooks, async (notePromise, hook) => {
                const { note } = await notePromise;
                const script = hooks_1.HookUtils.getHookScriptPath({
                    wsRoot: this.wsRoot,
                    basename: hook.id + ".js",
                });
                return hooks_1.HookUtils.requireHook({
                    note,
                    fpath: script,
                    wsRoot: this.wsRoot,
                });
            }, Promise.resolve({ note })).catch((err) => new common_all_1.DendronError({
                severity: common_all_1.ERROR_SEVERITY.MINOR,
                message: "error with hook",
                payload: common_all_1.stringifyError(err),
            }));
            if (resp instanceof common_all_1.DendronError) {
                error = resp;
                this.logger.error({ ctx, error: common_all_1.stringifyError(error) });
            }
            else {
                const valResp = common_all_1.NoteUtils.validate(resp.note);
                if (valResp instanceof common_all_1.DendronError) {
                    error = valResp;
                    this.logger.error({ ctx, error: common_all_1.stringifyError(error) });
                }
                else {
                    note = resp.note;
                    this.logger.info({ ctx, msg: "fin:RunHooks", payload: resp.payload });
                }
            }
        }
        // order matters - only write file after parents are established @see(_writeNewNote)
        await common_server_1.note2File({
            note,
            vault: note.vault,
            wsRoot: this.wsRoot,
            opts: { writeHierarchy: opts === null || opts === void 0 ? void 0 : opts.writeHierarchy },
        });
        if (match) {
            this.logger.info({
                ctx,
                msg: "pre:addSchema",
            });
            const { schema, schemaModule } = match;
            common_all_1.NoteUtils.addSchema({ note, schema, schemaModule });
        }
        this.logger.info({
            ctx,
            msg: "pre:updateNotes",
        });
        await Promise.all([note].concat(changed).map((ent) => this.updateNote(ent)));
        const changedEntries = changed.map((ent) => ({
            note: ent,
            status: "update",
        }));
        changedEntries.push({ note, status: "create" });
        if (maybeNote && !noDelete) {
            changedEntries.push({ note: maybeNote, status: "delete" });
        }
        this.logger.info({
            ctx,
            msg: "exit",
        });
        return {
            error,
            data: changedEntries,
        };
    }
    async writeSchema(schemaModule) {
        this.schemas[schemaModule.root.id] = schemaModule;
        const vault = schemaModule.vault;
        const vpath = common_server_1.vault2Path({ vault, wsRoot: this.wsRoot });
        await common_server_1.schemaModuleProps2File(schemaModule, vpath, schemaModule.fname);
    }
}
exports.FileStorage = FileStorage;
//# sourceMappingURL=storev2.js.map