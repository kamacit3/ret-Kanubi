import { DNoteAnchor, DendronError, DEngineClient, DLink, DNoteAnchorPositioned, DNoteLink, DNoteLoc, DNoteRefLink, DNoteRefLinkRaw, getSlugger, NoteChangeEntry, NoteProps, Position, NoteBlock, LINK_CONTENTS, LINK_NAME, ALIAS_NAME, IntermediateDendronConfig } from "@dendronhq/common-all";
import type { Heading, List, Paragraph, Table, TableCell, TableRow, Image, Text, Link, FootnoteDefinition } from "mdast";
import * as mdastBuilder from "mdast-builder";
import { Processor } from "unified";
import { Node, Parent } from "unist";
import visit from "unist-util-visit";
import { VFile } from "vfile";
import { Anchor, ExtendedImage, DendronASTDest, DendronASTTypes, HashTag, NoteRefNoteV4, UserTag, WikiLinkNoteV4, WikiLinkProps } from "../types";
export { mdastBuilder };
export { select, selectAll } from "unist-util-select";
export { visit };
export { LINK_CONTENTS, LINK_NAME, ALIAS_NAME };
export declare function addError(proc: Processor, err: DendronError): void;
export declare function getNoteOrError(notes: NoteProps[], hint: any): {
    error: DendronError | undefined;
    note: undefined | NoteProps;
};
export declare type LinkFilter = {
    loc?: Partial<DNoteLoc>;
};
export declare function hashTag2WikiLinkNoteV4(hashtag: HashTag): WikiLinkNoteV4;
export declare function userTag2WikiLinkNoteV4(userTag: UserTag): WikiLinkNoteV4;
export declare function frontmatterTag2WikiLinkNoteV4(tag: string, useHashSymbol?: boolean): WikiLinkNoteV4;
export declare class LinkUtils {
    static astType2DLinkType(type: DendronASTTypes): DLink["type"];
    static dlink2DNoteLink(link: DLink): DNoteLink;
    /**
     * Get all links from the note body
     * Currently, just look for wiki links
     * @param opts.filter - {type, loc
     *
     * - type: filter by {@link DendronASTTypes}
     * - loc: filter by {@link DLoc}
     */
    static findLinks({ note, engine, filter, }: {
        note: NoteProps;
        engine: DEngineClient;
        filter?: LinkFilter;
    }): DLink[];
    static findHashTags({ links }: {
        links: DLink[];
    }): DLink[];
    static isAlias(link: string): boolean;
    static hasFilter(link: string): boolean;
    static parseAliasLink(link: string): {
        alias: string;
        value: string;
    };
    static parseDendronURI(linkString: string): {
        vaultName: string;
        link: string;
    } | {
        link: string;
        vaultName?: undefined;
    };
    /** Either value or anchorHeader will always be present if the function did not
     *  return null. A missing value means that the file containing this link is
     *  the value.
     */
    static parseLinkV2(linkString: string): {
        alias?: string;
        value: string;
        anchorHeader?: string;
        vaultName?: string;
        sameFile: false;
    } | {
        alias?: string;
        value?: string;
        anchorHeader: string;
        vaultName?: string;
        sameFile: true;
    } | null;
    static parseLink(linkMatch: string): WikiLinkProps;
    static parseNoteRefRaw(ref: string): DNoteRefLinkRaw;
    static parseNoteRef(ref: string): DNoteRefLink;
    static renderNoteLink({ link, dest, }: {
        link: DNoteLink;
        dest: DendronASTDest;
    }): string | never;
    static updateLink({ note, oldLink, newLink, }: {
        note: NoteProps;
        oldLink: DNoteLink;
        newLink: DNoteLink;
    }): string;
    static isHashtagLink(link: DNoteLoc): link is DNoteLoc & {
        alias: string;
    };
    static isUserTagLink(link: DNoteLoc): link is DNoteLoc & {
        alias: string;
    };
    static findLinkCandidates({ note, notesMap, engine, }: {
        note: NoteProps;
        notesMap: Map<string, NoteProps>;
        engine: DEngineClient;
    }): DLink[];
    static hasVaultPrefix(link: DLink): boolean;
}
export declare class AnchorUtils {
    /** Given a header, finds the text of that header, including any wikilinks or hashtags that are included in the header.
     *
     * For example, for the header `## Foo [[Bar|bar]] and #baz`, the text should be `Foo Bar and #baz`.
     */
    static headerText(header: Heading): string;
    /** Given a header, finds the range of text that marks the contents of the header.
     *
     * For example, for the header `## Foo [[Bar|bar]] and #baz`, the range will start after `## ` and end at the end of the line.
     */
    static headerTextPosition(header: Heading): Position;
    /** Given a *parsed* anchor node, returns the anchor id ("header" or "^block" and positioned anchor object for it. */
    static anchorNode2anchor(node: Anchor, slugger: ReturnType<typeof getSlugger>): [string, DNoteAnchorPositioned] | undefined;
    static findAnchors(opts: {
        note: NoteProps;
        wsRoot: string;
    }): Promise<{
        [index: string]: DNoteAnchorPositioned;
    }>;
    static anchor2string(anchor: DNoteAnchor): string;
}
export declare class RemarkUtils {
    static bumpHeadings(root: Node, baseDepth: number): void;
    static findAnchors(content: string): Anchor[];
    static isHeading(node: Node, text: string, depth?: number): node is Heading;
    static isRoot(node: Node): node is Parent;
    static isParent(node: Node): node is Parent;
    static isParagraph(node: Node): node is Paragraph;
    static isTable(node: Node): node is Table;
    static isTableRow(node: Node): node is TableRow;
    static isTableCell(node: Node): node is TableCell;
    static isList(node: Node): node is List;
    static isNoteRefV2(node: Node): node is NoteRefNoteV4;
    static isImage(node: Node): node is Image;
    static isExtendedImage(node: Node): node is ExtendedImage;
    static isText(node: Node): node is Text;
    static isLink(node: Node): node is Link;
    static isFootnoteDefinition(node: Node): node is FootnoteDefinition;
    static convertLinksToDotNotation(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static convertAssetReferences(note: NoteProps, assetHashMap: Map<string, string>, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static convertLinksFromDotNotation(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static convertWikiLinkToNoteUrl(note: NoteProps, changes: NoteChangeEntry[], engine: DEngineClient, dendronConfig: IntermediateDendronConfig): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static oldNoteRef2NewNoteRef(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static h1ToTitle(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    static h1ToH2(note: NoteProps, changes: NoteChangeEntry[]): (this: Processor) => (tree: Node, _vfile: VFile) => void;
    /**
     * Recursively check if two given node has identical children.
     * At each level _position_ is omitted as this can change if
     * you are comparing from two different trees.
     * @param a first {@link Node} to compare
     * @param b second {@link Node} to compare
     * @returns boolean
     */
    static hasIdenticalChildren: (a: Node, b: Node) => boolean;
    /**
     * Given a markdown AST and a target heading node,
     * Find all the node that belongs under the heading.
     * This will extract all nodes until it hits the next heading
     * with the same depth of the target heading.
     * @param tree Abstract syntax tree
     * @param targetHeader Heading to target
     * @returns nodes to extract
     */
    static extractHeaderBlock(tree: Node, targetHeader: Heading): Node[];
    /** Extract all blocks from the note which could be referenced by a block anchor.
     *
     * If those blocks already have anchors (or if they are a header), this will also find that anchor.
     *
     * @param note The note from which blocks will be extracted.
     */
    static extractBlocks({ note, engine, }: {
        note: NoteProps;
        engine: DEngineClient;
    }): Promise<NoteBlock[]>;
    static extractFootnoteDefs(root: Node): FootnoteDefinition[];
}
