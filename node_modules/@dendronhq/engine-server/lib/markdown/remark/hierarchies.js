"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hierarchies = void 0;
const common_all_1 = require("@dendronhq/common-all");
const unist_util_visit_1 = __importDefault(require("unist-util-visit"));
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const unist_builder_1 = __importDefault(require("unist-builder"));
const site_1 = require("../../topics/site");
const utils_1 = require("../../utils");
const types_1 = require("../types");
const utils_2 = require("../utils");
const utils_3 = require("./utils");
// These are the HTML IDs for footnotes. This replicates what the footnotes plugin was doing.
const FOOTNOTE_DEF_ID_PREFIX = "fn-";
const FOOTNOTE_REF_ID_PREFIX = "fnref-";
/** The symbol that will be shown as the "return to reference" button. */
const FOOTNOTE_RETURN_SYMBOL = "Ë„";
function footnote2html(reference) {
    return mdast_builder_1.html(`<a id="${FOOTNOTE_REF_ID_PREFIX}${reference.identifier}"` +
        `class="fnref"` +
        `href="#${FOOTNOTE_DEF_ID_PREFIX}${reference.identifier}">` +
        (reference.label || reference.identifier) +
        `</a>`);
}
function footnoteDef2html(definition) {
    // Add a back arrow to the end of the definition that takes user to the
    // footnote reference. We have to inject the back arrow into the text inside
    // the definition, otherwise it renders in a different line than the definition.
    const backArrow = mdast_builder_1.html(`<a class="fn" href="#${FOOTNOTE_REF_ID_PREFIX}${definition.identifier}">${FOOTNOTE_RETURN_SYMBOL}</a>`);
    let lastParent;
    unist_util_visit_1.default(definition, (node) => {
        if (utils_3.RemarkUtils.isParent(node))
            lastParent = node;
    });
    if (lastParent)
        lastParent.children.push(backArrow);
    return mdast_builder_1.paragraph([
        // Put the ID target first, so even if the footnote is multiple lines long, it jumps to the start
        mdast_builder_1.html(`<span id="${FOOTNOTE_DEF_ID_PREFIX}${definition.identifier}" style="display: none;"></span>`),
        ...definition.children,
    ]);
}
/** Adds the "Children", "Tags", and "Footnotes" items to the end of the note. Also renders footnotes. */
const plugin = function (opts) {
    const proc = this;
    const hierarchyDisplayTitle = (opts === null || opts === void 0 ? void 0 : opts.hierarchyDisplayTitle) || "Children";
    const hierarchyDisplay = lodash_1.default.isUndefined(opts === null || opts === void 0 ? void 0 : opts.hierarchyDisplay)
        ? true
        : opts === null || opts === void 0 ? void 0 : opts.hierarchyDisplay;
    function transformer(tree) {
        const root = tree;
        const { fname, vault, dest, config, insideNoteRef } = utils_2.MDUtilsV4.getDendronData(proc);
        let addedBreak = false;
        function addBreak() {
            if (addedBreak)
                return;
            root.children.push({
                type: "thematicBreak",
            });
            addedBreak = true;
        }
        function addFootnotes() {
            /** Maps footnote identifiers to their definitions. */
            const footnotes = new Map(utils_3.RemarkUtils.extractFootnoteDefs(root).map((definition) => [
                definition.identifier,
                definition,
            ]));
            /** All footnote definitions that have been referenced in this document. */
            const usedFootnotes = new Set();
            unist_util_visit_1.default(root, [types_1.DendronASTTypes.FOOTNOTE_REFERENCE], (reference, index, parent) => {
                const definition = footnotes.get(reference.identifier);
                if (definition && parent) {
                    parent.children[index] = footnote2html(reference);
                    usedFootnotes.add(definition);
                }
            });
            if (usedFootnotes.size > 0) {
                addBreak();
                root.children.push(mdast_builder_1.heading(2, mdast_builder_1.text("Footnotes")));
                const footnoteItems = [];
                for (const definition of usedFootnotes) {
                    footnoteItems.push(mdast_builder_1.listItem(footnoteDef2html(definition)));
                }
                root.children.push(mdast_builder_1.list("ordered", footnoteItems));
            }
        }
        if (dest !== types_1.DendronASTDest.HTML) {
            return;
        }
        if (!hierarchyDisplay) {
            return;
        }
        if (!fname || insideNoteRef) {
            // Even inside a note ref, render footnotes because we want them in there too
            addFootnotes();
            return;
        }
        const { engine } = utils_2.MDUtilsV4.getEngineFromProc(proc);
        const note = common_all_1.NoteUtils.getNoteByFnameV5({
            fname,
            notes: engine.notes,
            vault: vault,
            wsRoot: engine.wsRoot,
        });
        /** Add frontmatter tags, if any, ahead of time. This way wikilink compiler will pick them up and render them. */
        function addTags() {
            var _a;
            if (((_a = config === null || config === void 0 ? void 0 : config.site) === null || _a === void 0 ? void 0 : _a.showFrontMatterTags) !== false &&
                (note === null || note === void 0 ? void 0 : note.tags) &&
                note.tags.length > 0) {
                addBreak();
                root.children.push(mdast_builder_1.heading(2, mdast_builder_1.text("Tags")));
                const tags = lodash_1.default.isString(note.tags) ? [note.tags] : note.tags;
                const tagLinks = lodash_1.default.sortBy(lodash_1.default.map(tags, (tag) => {
                    var _a;
                    return mdast_builder_1.listItem(mdast_builder_1.paragraph(utils_3.frontmatterTag2WikiLinkNoteV4(tag, (_a = config === null || config === void 0 ? void 0 : config.site) === null || _a === void 0 ? void 0 : _a.useHashesForFMTags)));
                }), ["custom.nav_order", "title"]);
                root.children.push(mdast_builder_1.list("ordered", tagLinks));
            }
        }
        function addChildren() {
            var _a, _b, _c;
            // don't include if collection present
            if (!note || note.children.length <= 0 || ((_a = note === null || note === void 0 ? void 0 : note.custom) === null || _a === void 0 ? void 0 : _a.has_collection)) {
                return;
            }
            if (lodash_1.default.isBoolean((_b = note.custom) === null || _b === void 0 ? void 0 : _b.hierarchyDisplay) &&
                !note.custom.hierarchyDisplay) {
                return;
            }
            const children = utils_1.HierarchyUtils.getChildren({
                skipLevels: ((_c = note.custom) === null || _c === void 0 ? void 0 : _c.skipLevels) || 0,
                note,
                notes: engine.notes,
            })
                .filter((note) => site_1.SiteUtils.canPublish({ note, engine, config }))
                .filter((note) => { var _a, _b; return lodash_1.default.isUndefined((_a = note.custom) === null || _a === void 0 ? void 0 : _a.nav_exclude) || !((_b = note.custom) === null || _b === void 0 ? void 0 : _b.nav_exclude); });
            if (!lodash_1.default.isEmpty(children)) {
                addBreak();
                root.children.push(unist_builder_1.default(types_1.DendronASTTypes.HEADING, { depth: 2 }, [
                    unist_builder_1.default("text", hierarchyDisplayTitle),
                ]));
                root.children.push(mdast_builder_1.list("ordered", lodash_1.default.sortBy(children, ["custom.nav_order", "title"]).map((note) => {
                    return mdast_builder_1.listItem(mdast_builder_1.paragraph({
                        type: types_1.DendronASTTypes.WIKI_LINK,
                        value: note.fname,
                        data: {
                            alias: note.title,
                            vaultName: common_all_1.VaultUtils.getName(note.vault),
                        },
                        children: [],
                    }));
                })));
            }
        }
        // Will appear on page in this order
        addChildren();
        addTags();
        addFootnotes();
        // end transformer
    }
    return transformer;
};
exports.hierarchies = plugin;
//# sourceMappingURL=hierarchies.js.map