"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.wikiLinks = exports.matchWikiLink = exports.LINK_REGEX_LOOSE = exports.LINK_REGEX = void 0;
const common_all_1 = require("@dendronhq/common-all");
const common_server_1 = require("@dendronhq/common-server");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const types_1 = require("../types");
const utils_1 = require("../utils");
const utilsv5_1 = require("../utilsv5");
const utils_2 = require("./utils");
exports.LINK_REGEX = /^\[\[([^\]\n]+)\]\]/;
/**
 * Does not require wiki link be the start of the word
 */
exports.LINK_REGEX_LOOSE = /\[\[([^\]\n]+)\]\]/;
const parseWikiLink = (linkMatch) => {
    linkMatch = common_all_1.NoteUtils.normalizeFname(linkMatch);
    return utils_2.LinkUtils.parseLinkV2(linkMatch);
};
const matchWikiLink = (text) => {
    const match = exports.LINK_REGEX_LOOSE.exec(text);
    if (match) {
        const start = match.index;
        const end = match.index + match[0].length;
        const linkMatch = match[1].trim();
        const link = parseWikiLink(linkMatch);
        return { link, start, end };
    }
    return false;
};
exports.matchWikiLink = matchWikiLink;
function parseAnchorIfExist(link) {
    if (link.indexOf("#") !== -1) {
        return link.split("#");
    }
    else {
        return [link, undefined];
    }
}
function normalizeSpaces(link) {
    return link.replace(/ /g, "%20");
}
const plugin = function (opts) {
    attachParser(this);
    if (this.Compiler != null) {
        attachCompiler(this, opts);
    }
};
exports.wikiLinks = plugin;
function attachCompiler(proc, opts) {
    const copts = lodash_1.default.defaults(opts || {}, {
        convertObsidianLinks: false,
        useId: false,
    });
    const Compiler = proc.Compiler;
    const visitors = Compiler.prototype.visitors;
    if (visitors) {
        visitors.wikiLink = function (node) {
            const pOpts = utilsv5_1.MDUtilsV5.getProcOpts(proc);
            const data = node.data;
            let value = node.value;
            if (pOpts.mode === utilsv5_1.ProcMode.NO_DATA) {
                const { alias, anchorHeader } = data;
                const link = value;
                const calias = alias !== value ? `${alias}|` : "";
                const anchor = anchorHeader ? `#${anchorHeader}` : "";
                const vaultPrefix = data.vaultName
                    ? `${common_all_1.CONSTANTS.DENDRON_DELIMETER}${data.vaultName}/`
                    : "";
                return `[[${calias}${vaultPrefix}${link}${anchor}]]`;
            }
            const { dest } = utils_1.MDUtilsV4.getDendronData(proc);
            const vault = utils_1.MDUtilsV4.getVault(proc, data.vaultName);
            // if converting back to dendron md, no further processing
            if (dest === types_1.DendronASTDest.MD_DENDRON) {
                return utils_2.LinkUtils.renderNoteLink({
                    link: {
                        from: {
                            fname: value,
                            alias: data.alias,
                            anchorHeader: data.anchorHeader,
                            vaultName: data.vaultName,
                        },
                        data: {
                            xvault: !lodash_1.default.isUndefined(data.vaultName),
                        },
                        type: utils_2.LinkUtils.astType2DLinkType(types_1.DendronASTTypes.WIKI_LINK),
                        position: node.position,
                    },
                    dest,
                });
            }
            const { error, engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
            if (error) {
                utils_2.addError(proc, error);
                return "error with engine";
            }
            if (copts.useId && dest === types_1.DendronASTDest.HTML) {
                // TODO: check for vault
                const notes = common_all_1.NoteUtils.getNotesByFname({
                    fname: value,
                    notes: engine.notes,
                    vault,
                });
                const { error, note } = utils_2.getNoteOrError(notes, value);
                if (error) {
                    utils_2.addError(proc, error);
                    return "error with link";
                }
                else {
                    value = note.id;
                }
            }
            switch (dest) {
                case types_1.DendronASTDest.MD_REGULAR: {
                    const alias = data.alias ? data.alias : value;
                    return `[${alias}](${copts.prefix || ""}${normalizeSpaces(value)})`;
                }
                case types_1.DendronASTDest.MD_ENHANCED_PREVIEW: {
                    const alias = data.alias ? data.alias : value;
                    let cleanValue = normalizeSpaces(parseAnchorIfExist(value)[0]);
                    if (data.vaultName) {
                        const vaultByName = common_all_1.VaultUtils.getVaultByName({
                            vaults: engine.vaults,
                            vname: data.vaultName,
                        });
                        if (lodash_1.default.isUndefined(vaultByName)) {
                            return `ERROR: ${vaultByName} is not a vault in this workspace`;
                        }
                        const cpath = common_server_1.vault2Path({
                            wsRoot: engine.wsRoot,
                            vault: utils_1.MDUtilsV4.getVault(proc),
                        });
                        const npath = common_server_1.vault2Path({
                            vault: vaultByName,
                            wsRoot: engine.wsRoot,
                        });
                        cleanValue = path_1.default.join(path_1.default.relative(cpath, npath), cleanValue);
                    }
                    return `[${alias}](${copts.prefix || ""}${cleanValue}.md)`;
                }
                case types_1.DendronASTDest.HTML: {
                    const alias = data.alias ? data.alias : value;
                    return `[${alias}](${copts.prefix || ""}${value}.html${data.anchorHeader ? "#" + data.anchorHeader : ""})`;
                }
                default:
                    return `unhandled case: ${dest}`;
            }
        };
    }
}
function attachParser(proc) {
    function locator(value, fromIndex) {
        return value.indexOf("[", fromIndex);
    }
    function parseLink(linkMatch) {
        const pOpts = utilsv5_1.MDUtilsV5.getProcOpts(proc);
        linkMatch = common_all_1.NoteUtils.normalizeFname(linkMatch);
        const out = utils_2.LinkUtils.parseLinkV2(linkMatch);
        if (lodash_1.default.isNull(out)) {
            throw new common_all_1.DendronError({ message: `link is null: ${linkMatch}` });
        }
        if (pOpts.mode === utilsv5_1.ProcMode.NO_DATA) {
            return out;
        }
        const procData = utilsv5_1.MDUtilsV5.getProcData(proc);
        let { vault } = procData;
        const { config, dest, fname } = procData;
        const { engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
        if (out.vaultName) {
            const maybeVault = common_all_1.VaultUtils.getVaultByName({
                vaults: engine.vaults,
                vname: out.vaultName,
            });
            if (lodash_1.default.isUndefined(maybeVault)) {
                utils_2.addError(proc, new common_all_1.DendronError({
                    message: `fname: ${fname}, vault ${out.vaultName} not found in ${JSON.stringify(out)}`,
                }));
            }
            else {
                vault = maybeVault;
            }
            // default to current note
        }
        if (!out.value) {
            // same file block reference, value is implicitly current file
            out.value = lodash_1.default.trim(common_all_1.NoteUtils.normalizeFname(fname)); // recreate what value (and alias) would have been parsed
            if (!out.alias)
                out.alias = out.value;
        }
        if (dest !== types_1.DendronASTDest.MD_DENDRON &&
            (config === null || config === void 0 ? void 0 : config.useNoteTitleForLink) &&
            out.alias === out.value &&
            vault) {
            const wsRoot = engine.wsRoot;
            const note = common_all_1.NoteUtils.getNoteByFnameV5({
                fname: out.value,
                notes: engine.notes,
                vault,
                wsRoot,
            });
            if (note) {
                out.alias = note.title;
            }
        }
        return out;
    }
    function inlineTokenizer(eat, value) {
        const match = exports.LINK_REGEX.exec(value);
        if (match) {
            const linkMatch = match[1].trim();
            try {
                const { value, alias, anchorHeader, vaultName, sameFile } = parseLink(linkMatch);
                return eat(match[0])({
                    type: types_1.DendronASTTypes.WIKI_LINK,
                    value,
                    data: {
                        alias,
                        anchorHeader,
                        vaultName,
                        sameFile,
                    },
                });
            }
            catch {
                // Broken link, just refuse to parse it
                return;
            }
        }
        return;
    }
    inlineTokenizer.locator = locator;
    const Parser = proc.Parser;
    const inlineTokenizers = Parser.prototype.inlineTokenizers;
    const inlineMethods = Parser.prototype.inlineMethods;
    inlineTokenizers.wikiLink = inlineTokenizer;
    inlineMethods.splice(inlineMethods.indexOf("link"), 0, "wikiLink");
}
//# sourceMappingURL=wikiLinks.js.map