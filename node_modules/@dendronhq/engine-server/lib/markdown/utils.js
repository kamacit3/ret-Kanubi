"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishUtils = exports.MDUtilsV4 = exports.renderFromNoteWithCustomBody = exports.renderFromNote = exports.renderFromNoteProps = exports.nunjucks = void 0;
const common_all_1 = require("@dendronhq/common-all");
// @ts-ignore
const remark_mermaid_1 = __importDefault(require("@dendronhq/remark-mermaid"));
// @ts-ignore
const rehype_prism_1 = __importDefault(require("@mapbox/rehype-prism"));
const lodash_1 = __importDefault(require("lodash"));
const mdast_builder_1 = require("mdast-builder");
const nunjucks_1 = __importDefault(require("nunjucks"));
exports.nunjucks = nunjucks_1.default;
const path_1 = __importDefault(require("path"));
const rehype_autolink_headings_1 = __importDefault(require("rehype-autolink-headings"));
// @ts-ignore
const rehype_katex_1 = __importDefault(require("rehype-katex"));
const rehype_raw_1 = __importDefault(require("rehype-raw"));
const rehype_slug_1 = __importDefault(require("rehype-slug"));
const rehype_stringify_1 = __importDefault(require("rehype-stringify"));
const remark_1 = __importDefault(require("remark"));
const remark_abbr_1 = __importDefault(require("remark-abbr"));
// @ts-ignore
const remark_containers_1 = __importDefault(require("remark-containers"));
const remark_footnotes_1 = __importDefault(require("remark-footnotes"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const remark_math_1 = __importDefault(require("remark-math"));
const remark_parse_1 = __importDefault(require("remark-parse"));
const remark_rehype_1 = __importDefault(require("remark-rehype"));
const remark_stringify_1 = __importDefault(require("remark-stringify"));
// @ts-ignore
const remark_variables_1 = __importDefault(require("remark-variables"));
const unified_1 = __importDefault(require("unified"));
const remark_2 = require("./remark");
const backlinks_1 = require("./remark/backlinks");
const dendronPub_1 = require("./remark/dendronPub");
const noteRefs_1 = require("./remark/noteRefs");
const noteRefsV2_1 = require("./remark/noteRefsV2");
const publishSite_1 = require("./remark/publishSite");
const transformLinks_1 = require("./remark/transformLinks");
const wikiLinks_1 = require("./remark/wikiLinks");
const blockAnchors_1 = require("./remark/blockAnchors");
const types_1 = require("./types");
const hashtag_1 = require("./remark/hashtag");
const userTags_1 = require("./remark/userTags");
const extendedImage_1 = require("./remark/extendedImage");
const toString = require("mdast-util-to-string");
var DendronProcDataKeys;
(function (DendronProcDataKeys) {
    DendronProcDataKeys["PROC_OPTS"] = "procOpts";
    DendronProcDataKeys["NOTE_REF_LVL"] = "noteRefLvl";
    DendronProcDataKeys["ENGINE"] = "engine";
})(DendronProcDataKeys || (DendronProcDataKeys = {}));
const renderFromNoteProps = (opts) => {
    const note = common_all_1.NoteUtils.getNoteByFnameV5(opts);
    if (!note) {
        throw Error("no note found");
    }
    return exports.renderFromNote({ note });
};
exports.renderFromNoteProps = renderFromNoteProps;
const renderFromNote = (opts) => {
    const { note } = opts;
    const contents = nunjucks_1.default.renderString(note.body, {
        fm: { ...note.custom, title: note.title },
        fname: note.fname,
    });
    return contents;
};
exports.renderFromNote = renderFromNote;
const renderFromNoteWithCustomBody = (opts) => {
    const { note, body } = opts;
    const contents = nunjucks_1.default.renderString(body, { fm: note.custom });
    return contents;
};
exports.renderFromNoteWithCustomBody = renderFromNoteWithCustomBody;
class MDUtilsV4 {
    /** Find the index of the list element for which the predicate `fn` returns true.
     *
     * @returns The index where the element was found, -1 otherwise.
     */
    static findIndex(array, fn) {
        for (var i = 0; i < array.length; i++) {
            if (fn(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    /** A simplified and adapted version of visitParents from unist-utils-visit-parents, that also keeps track of indices of the ancestors as well.
     *
     * The limitations are:
     * * `test`, if used, can only be a string representing the type of the node that you want to visit
     * * Adding or removing siblings is undefined behavior
     * Please modify this function to add support for these if needed.
     */
    static visitParentsIndices({ nodes, test, visitor, }) {
        function recursiveTraversal(nodes, ancestors) {
            for (let i = 0; i < nodes.length; i++) {
                // visit the current node
                const node = nodes[i];
                let action = undefined;
                if (lodash_1.default.isUndefined(test) || node.type === test) {
                    action = visitor({ node, index: i, ancestors });
                }
                if (action === "skip")
                    return; // don't traverse the children of this node
                if (action === false)
                    return false; // stop traversing completely
                // visit the children of this node, if any
                if (node.children) {
                    const parent = node;
                    const newAncestors = [...ancestors, { ancestor: parent, index: i }];
                    const action = recursiveTraversal(parent.children, newAncestors);
                    if (action === false)
                        return; // stopping traversal
                }
            }
            return true; // continue traversal if needed
        }
        // Start recursion with no ancestors (everything is top level)
        recursiveTraversal(nodes, []);
    }
    static genMDMsg(msg) {
        return mdast_builder_1.root(mdast_builder_1.paragraph(mdast_builder_1.text(msg)));
    }
    static genMDErrorMsg(msg) {
        return mdast_builder_1.root(mdast_builder_1.blockquote(mdast_builder_1.text(msg)));
    }
    static getDendronData(proc) {
        return proc.data("dendron");
    }
    /**
     * Get the vault name, either from processor or passed in vaultName
     * @param opts.vaultMissingBehavior how to respond if no vault is found. See {@link VaultMissingBehavior}
     */
    static getVault(proc, vaultName, opts) {
        const copts = lodash_1.default.defaults(opts || {}, {
            vaultMissingBehavior: types_1.VaultMissingBehavior.THROW_ERROR,
        });
        let { vault } = MDUtilsV4.getDendronData(proc);
        const { engine } = MDUtilsV4.getEngineFromProc(proc);
        if (vaultName) {
            try {
                vault = common_all_1.VaultUtils.getVaultByNameOrThrow({
                    vaults: engine.vaults,
                    vname: vaultName,
                });
            }
            catch (err) {
                if (copts.vaultMissingBehavior === types_1.VaultMissingBehavior.THROW_ERROR) {
                    throw err;
                }
            }
        }
        return vault;
    }
    static getFM(proc) {
        return proc.data("fm");
    }
    static setDendronData(proc, data) {
        const _data = proc.data("dendron");
        return proc.data("dendron", { ..._data, ...data });
    }
    static getEngineFromProc(proc) {
        const engine = proc.data("engine");
        let error;
        if (lodash_1.default.isUndefined(engine) || lodash_1.default.isNull(engine)) {
            error = new common_all_1.DendronError({ message: "engine not defined" });
        }
        return {
            error,
            engine,
        };
    }
    static getNoteRefLvl(proc) {
        return this.getProcOpts(proc).noteRefLvl || 0;
    }
    static getProcOpts(proc) {
        const procOpts = proc.data(DendronProcDataKeys.PROC_OPTS);
        return procOpts;
    }
    static setEngine(proc, engine) {
        proc.data(DendronProcDataKeys.ENGINE, engine);
    }
    static setNoteRefLvl(proc, lvl) {
        this.setProcOpts(proc, { noteRefLvl: lvl });
    }
    static setProcOpts(proc, data) {
        const procOpts = proc.data(DendronProcDataKeys.PROC_OPTS);
        return proc.data(DendronProcDataKeys.PROC_OPTS, { ...procOpts, ...data });
    }
    static matchHeading(node, text, opts) {
        const { depth, slugger } = opts;
        if (node.type !== types_1.DendronASTTypes.HEADING) {
            return false;
        }
        // wildcard is always true
        if (text === "*") {
            return true;
        }
        if (text) {
            var headingText = toString(node);
            return text.trim().toLowerCase() === slugger.slug(headingText.trim());
        }
        if (depth) {
            return node.depth <= depth;
        }
        return true;
    }
    /**
     * Get remark processor with a few default plugins
     */
    static remark() {
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .use(remark_frontmatter_1.default, ["yaml"])
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        return _proc;
    }
    /**
     * Simple proc just for parsing docs
     */
    static procParse(opts) {
        const errors = [];
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .use(remark_frontmatter_1.default, ["yaml"])
            .use(wikiLinks_1.wikiLinks)
            .use(blockAnchors_1.blockAnchors)
            .use(hashtag_1.hashtags)
            .use(userTags_1.userTags)
            .use(extendedImage_1.extendedImage)
            .data("errors", errors);
        this.setDendronData(_proc, { dest: opts.dest, fname: opts.fname });
        this.setEngine(_proc, opts.engine);
        return _proc;
    }
    /**
     * Used to build other proces from
     */
    static proc(opts) {
        const { engine } = opts;
        const errors = [];
        let _proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .data("errors", errors)
            .data("engine", engine)
            .use(remark_frontmatter_1.default, ["yaml"])
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } });
        this.setProcOpts(_proc, opts);
        return _proc;
    }
    static procFull(opts) {
        var _a, _b, _c;
        const { dest, vault, fname, shouldApplyPublishRules, engine } = opts;
        const config = opts.config || engine.config;
        let proc = this.proc(opts);
        if (vault && fname) {
            const engine = MDUtilsV4.getEngineFromProc(proc).engine;
            const note = common_all_1.NoteUtils.getNoteByFnameV5({
                fname,
                notes: engine.notes,
                vault,
                wsRoot: engine.wsRoot,
            });
            const fm = {
                ...note === null || note === void 0 ? void 0 : note.custom,
                title: note === null || note === void 0 ? void 0 : note.title,
            };
            proc = proc.data("fm", fm);
        }
        let usePrettyRefs = opts.usePrettyRefs;
        if (lodash_1.default.isUndefined(usePrettyRefs))
            usePrettyRefs = common_all_1.ConfigUtils.usePrettyRef(config);
        let noLegacyNoteRef = lodash_1.default.isBoolean(config.noLegacyNoteRef)
            ? config.noLegacyNoteRef
            : false;
        proc = proc
            .data("dendron", {
            dest,
            vault,
            fname,
            config,
            shouldApplyPublishRules,
        })
            //.use(extract, { name: "fm" })
            .use(remark_abbr_1.default)
            .use(remark_variables_1.default)
            .use(remark_footnotes_1.default)
            .use(wikiLinks_1.wikiLinks, opts.wikiLinksOpts)
            .use(remark_2.hierarchies, {
            hierarchyDisplayTitle: config.hierarchyDisplayTitle,
            hierarchyDisplay: config.hierarchyDisplay,
        })
            .use(backlinks_1.backlinks)
            .use(blockAnchors_1.blockAnchors, lodash_1.default.merge(opts.blockAnchorsOpts))
            .use(hashtag_1.hashtags)
            .use(userTags_1.userTags)
            .use(extendedImage_1.extendedImage)
            .use(noteRefsV2_1.noteRefsV2, {
            ...opts.noteRefOpts,
            wikiLinkOpts: opts.wikiLinksOpts,
            prettyRefs: usePrettyRefs,
            insertTitle: config.useFMTitle,
        });
        if (!noLegacyNoteRef) {
            proc = proc.use(noteRefs_1.noteRefs, {
                ...opts.noteRefOpts,
                wikiLinkOpts: opts.wikiLinksOpts,
            });
        }
        if (((_a = opts.mathOpts) === null || _a === void 0 ? void 0 : _a.katex) || ((_b = opts.config) === null || _b === void 0 ? void 0 : _b.useKatex)) {
            proc = proc.use(remark_math_1.default);
        }
        if (opts.mermaid || ((_c = opts.config) === null || _c === void 0 ? void 0 : _c.mermaid)) {
            proc = proc.use(remark_mermaid_1.default, { simple: true });
        }
        // MD_DENDRON, convert back to itself, no need for transformations
        if (dest !== types_1.DendronASTDest.MD_DENDRON) {
            proc = proc.use(dendronPub_1.dendronPub, {
                insertTitle: config.useFMTitle,
                ...opts.publishOpts,
                wikiLinkOpts: opts.wikiLinksOpts,
                prettyRefs: usePrettyRefs,
            });
        }
        proc = proc.data("procFull", proc().freeze());
        proc = proc.data(DendronProcDataKeys.PROC_OPTS, opts);
        return proc;
    }
    /**
     * Just parse markdown
     */
    static procRemark(opts) {
        const { proc } = opts;
        let _proc = proc || this.remark();
        return _proc.use(remark_parse_1.default, { gfm: true }).use(remark_stringify_1.default);
    }
    /**
     * markdown -> html
     */
    static procRehype(opts) {
        const { proc, mdPlugins, useLinks } = lodash_1.default.defaults(opts, {
            mdPlugins: [],
            useLinks: true,
        });
        let _proc = proc || unified_1.default().use(remark_parse_1.default, { gfm: true });
        mdPlugins.forEach((p) => {
            _proc = _proc.use(p);
        });
        _proc = _proc
            .use(remark_rehype_1.default, { allowDangerousHtml: true })
            .use(rehype_prism_1.default, { ignoreMissing: true })
            .use(rehype_raw_1.default)
            .use(rehype_slug_1.default);
        if (useLinks) {
            _proc = _proc.use(rehype_autolink_headings_1.default, {
                properties: {
                    "aria-hidden": "true",
                    class: "anchor-heading",
                },
                content: {
                    type: "element",
                    tagName: "svg",
                    properties: {
                        "aria-hidden": "true",
                        viewBox: "0 0 16 16",
                    },
                    children: [
                        {
                            type: "element",
                            tagName: "use",
                            properties: {
                                "xlink:href": "#svg-link",
                            },
                        },
                    ],
                },
            });
        }
        if (opts.mathjax) {
            _proc = _proc.use(rehype_katex_1.default);
        }
        return _proc.use(rehype_stringify_1.default);
    }
    /**
     * Used to refactor text
     */
    static procTransform(procOpts, transformOpts) {
        const proc = this.procFull({
            dest: types_1.DendronASTDest.MD_DENDRON,
            ...procOpts,
        });
        return proc.use(transformLinks_1.transformLinks, transformOpts);
    }
    static procHTML(procOpts) {
        const { engine, vault, fname, noteIndex } = procOpts;
        const config = procOpts.config || engine.config;
        const siteNotesDir = config.site.siteNotesDir;
        const absUrl = PublishUtils.getAbsUrlForAsset({ config });
        const linkPrefix = absUrl + "/" + siteNotesDir + "/";
        const wikiLinksOpts = { useId: true, prefix: linkPrefix };
        let proc = MDUtilsV4.procFull({
            engine,
            dest: types_1.DendronASTDest.HTML,
            vault,
            fname,
            wikiLinksOpts,
            shouldApplyPublishRules: true,
            noteRefOpts: { wikiLinkOpts: wikiLinksOpts, prettyRefs: true },
            publishOpts: {
                assetsPrefix: common_all_1.getStage() === "prod" ? config.site.assetsPrefix : undefined,
                insertTitle: config.useFMTitle,
                transformNoPublish: true,
            },
            mathOpts: { katex: true },
            mermaid: config.mermaid,
            config,
        });
        proc = proc.use(publishSite_1.publishSite, { noteIndex });
        if (config.site.useContainers) {
            proc = proc.use(remark_containers_1.default);
        }
        return MDUtilsV4.procRehype({
            proc,
            mathjax: true,
            useLinks: procOpts.useLinks,
        });
    }
    /**
     * Return a dendron processor
     * @param opts
     * @returns
     */
    static procDendron(opts) {
        const { dest, engine, configOverride, fname, vault } = opts;
        if (dest === types_1.DendronASTDest.HTML) {
            throw Error("use procDendronHTML");
        }
        const proc = MDUtilsV4.procFull({
            engine,
            config: configOverride,
            fname,
            dest,
            vault,
        });
        return proc;
    }
    static procDendronForPublish(opts) {
        const { engine, configOverride, fname, vault, noteIndex } = opts;
        const proc = MDUtilsV4.procHTML({
            engine,
            config: configOverride,
            fname,
            vault,
            noteIndex,
        });
        return proc;
    }
}
exports.MDUtilsV4 = MDUtilsV4;
class PublishUtils {
    static getAbsUrlForAsset(opts) {
        const suffix = opts.suffix || "";
        const { config } = opts;
        const { assetsPrefix } = config.site;
        const siteUrl = this.getSiteUrl(config);
        let sitePrefix = lodash_1.default.trimEnd(siteUrl, "/");
        if (assetsPrefix) {
            sitePrefix = lodash_1.default.join([lodash_1.default.trimEnd(siteUrl, "/"), lodash_1.default.trim(assetsPrefix, "/")], "/");
        }
        const out = lodash_1.default.trimEnd(lodash_1.default.join([sitePrefix, lodash_1.default.trim(suffix, "/")], "/"), "/");
        return out;
    }
}
exports.PublishUtils = PublishUtils;
PublishUtils.getSiteUrl = (config) => {
    if (common_all_1.getStage() !== "dev") {
        const siteUrl = process.env["SITE_URL"] || config.site.siteUrl;
        return siteUrl;
    }
    else {
        return ("http://" +
            path_1.default.posix.join(`localhost:${process.env.ELEV_PORT || 8080}`));
    }
};
//# sourceMappingURL=utils.js.map