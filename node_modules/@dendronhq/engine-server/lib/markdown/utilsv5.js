"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MDUtilsV5 = exports.ProcFlavor = exports.ProcMode = void 0;
const common_all_1 = require("@dendronhq/common-all");
// @ts-ignore
const rehype_prism_1 = __importDefault(require("@mapbox/rehype-prism"));
// @ts-ignore
const remark_mermaid_1 = __importDefault(require("@dendronhq/remark-mermaid"));
const lodash_1 = __importDefault(require("lodash"));
const remark_math_1 = __importDefault(require("remark-math"));
const rehype_autolink_headings_1 = __importDefault(require("rehype-autolink-headings"));
// @ts-ignore
const rehype_katex_1 = __importDefault(require("rehype-katex"));
const rehype_raw_1 = __importDefault(require("rehype-raw"));
const rehype_slug_1 = __importDefault(require("rehype-slug"));
const rehype_stringify_1 = __importDefault(require("rehype-stringify"));
const remark_1 = __importDefault(require("remark"));
const remark_abbr_1 = __importDefault(require("remark-abbr"));
const remark_footnotes_1 = __importDefault(require("remark-footnotes"));
const remark_frontmatter_1 = __importDefault(require("remark-frontmatter"));
const remark_parse_1 = __importDefault(require("remark-parse"));
const remark_rehype_1 = __importDefault(require("remark-rehype"));
const blockAnchors_1 = require("./remark/blockAnchors");
const dendronPreview_1 = require("./remark/dendronPreview");
const dendronPub_1 = require("./remark/dendronPub");
const noteRefsV2_1 = require("./remark/noteRefsV2");
const wikiLinks_1 = require("./remark/wikiLinks");
const types_1 = require("./types");
const utils_1 = require("./utils");
const hashtag_1 = require("./remark/hashtag");
const userTags_1 = require("./remark/userTags");
const backlinks_1 = require("./remark/backlinks");
const remark_2 = require("./remark");
const extendedImage_1 = require("./remark/extendedImage");
/**
 * What mode a processor should run in
 */
var ProcMode;
(function (ProcMode) {
    /**
     * Expect no properties from {@link ProcDataFullV5} when running the processor
     */
    ProcMode["NO_DATA"] = "NO_DATA";
    /**
     * Expect all properties from {@link ProcDataFullV5} when running the processor
     */
    ProcMode["FULL"] = "all data";
    /**
     * Running processor in import mode. Notes don't exist. Used for import pods like {@link MarkdownPod}
     * where notes don't exist in the engine prior to import.
     */
    ProcMode["IMPORT"] = "IMPORT";
})(ProcMode = exports.ProcMode || (exports.ProcMode = {}));
/**
 * If processor should run in an alternative flavor
 */
var ProcFlavor;
(function (ProcFlavor) {
    /**
     * No special processing
     */
    ProcFlavor["REGULAR"] = "REGULAR";
    /**
     * Apply publishing rules
     */
    ProcFlavor["PUBLISHING"] = "PUBLISHING";
    /**
     * Apply preview rules
     */
    ProcFlavor["PREVIEW"] = "PREVIEW";
    /**
     * Apply hover preview rules (used for the preview when hovering over a link)
     */
    ProcFlavor["HOVER_PREVIEW"] = "HOVER_PREVIEW";
})(ProcFlavor = exports.ProcFlavor || (exports.ProcFlavor = {}));
function checkProps({ requiredProps, data, }) {
    const hasAllProps = lodash_1.default.map(requiredProps, (prop) => {
        // @ts-ignore
        return !lodash_1.default.isUndefined(data[prop]);
    });
    if (!lodash_1.default.every(hasAllProps)) {
        // @ts-ignore
        const missing = lodash_1.default.filter(requiredProps, (prop) => 
        // @ts-ignore
        lodash_1.default.isUndefined(data[prop]));
        return { valid: false, missing };
    }
    return { valid: true };
}
class MDUtilsV5 {
    static getProcOpts(proc) {
        const _data = proc.data("dendronProcOptsv5");
        return _data || {};
    }
    static getNoteByFname(proc, { fname }) {
        const { notes, vault, wsRoot } = this.getProcData(proc);
        // TODO: this is for backwards compatibility
        const { engine } = utils_1.MDUtilsV4.getEngineFromProc(proc);
        const note = common_all_1.NoteUtils.getNoteByFnameV5({
            fname,
            notes: notes || engine.notes,
            vault,
            wsRoot,
        });
        return note;
    }
    static getProcData(proc) {
        let _data = proc.data("dendronProcDatav5");
        // backwards compatibility
        _data = lodash_1.default.defaults(utils_1.MDUtilsV4.getDendronData(proc), _data);
        try {
            _data.noteRefLvl = utils_1.MDUtilsV4.getNoteRefLvl(proc);
        }
        catch {
            _data.noteRefLvl = 0;
        }
        return _data || {};
    }
    static setProcData(proc, opts) {
        var _a;
        const _data = proc.data("dendronProcDatav5");
        // TODO: for backwards compatibility
        utils_1.MDUtilsV4.setProcOpts(proc, opts);
        utils_1.MDUtilsV4.setDendronData(proc, opts);
        const notes = lodash_1.default.isUndefined(opts.notes) ? (_a = opts === null || opts === void 0 ? void 0 : opts.engine) === null || _a === void 0 ? void 0 : _a.notes : opts.notes;
        return proc.data("dendronProcDatav5", { ..._data, ...opts, notes });
    }
    static setProcOpts(proc, opts) {
        const _data = proc.data("dendronProcOptsv5");
        return proc.data("dendronProcOptsv5", { ..._data, ...opts });
    }
    static isV5Active(proc) {
        return !lodash_1.default.isUndefined(this.getProcOpts(proc).mode);
    }
    static shouldApplyPublishingRules(proc) {
        return (this.getProcData(proc).dest === types_1.DendronASTDest.HTML &&
            this.getProcOpts(proc).flavor === ProcFlavor.PUBLISHING);
    }
    /**
     * Used for processing a Dendron markdown note
     */
    static _procRemark(opts, data) {
        var _a, _b, _c, _d, _e, _f, _g;
        const errors = [];
        opts = lodash_1.default.defaults(opts, { flavor: ProcFlavor.REGULAR });
        let proc = remark_1.default()
            .use(remark_parse_1.default, { gfm: true })
            .use(remark_frontmatter_1.default, ["yaml"])
            .use(remark_abbr_1.default)
            .use({ settings: { listItemIndent: "1", fences: true, bullet: "-" } })
            .use(noteRefsV2_1.noteRefsV2)
            .use(wikiLinks_1.wikiLinks)
            .use(blockAnchors_1.blockAnchors)
            .use(hashtag_1.hashtags)
            .use(userTags_1.userTags)
            .use(extendedImage_1.extendedImage)
            .use(remark_footnotes_1.default)
            .data("errors", errors);
        // set options and do validation
        proc = this.setProcOpts(proc, opts);
        switch (opts.mode) {
            case ProcMode.FULL:
                {
                    if (lodash_1.default.isUndefined(data)) {
                        throw common_all_1.DendronError.createFromStatus({
                            status: common_all_1.ERROR_STATUS.INVALID_CONFIG,
                            message: `data is required when not using raw proc`,
                        });
                    }
                    const requiredProps = ["vault", "engine", "fname", "dest"];
                    const resp = checkProps({ requiredProps, data });
                    if (!resp.valid) {
                        throw common_all_1.DendronError.createFromStatus({
                            status: common_all_1.ERROR_STATUS.INVALID_CONFIG,
                            message: `missing required fields in data. ${resp.missing.join(" ,")} missing`,
                        });
                    }
                    if (!data.config) {
                        data.config = data.engine.config;
                    }
                    if (!data.wsRoot) {
                        data.wsRoot = data.engine.wsRoot;
                    }
                    // backwards compatibility, default to v4 values
                    data = lodash_1.default.defaults(utils_1.MDUtilsV4.getDendronData(proc), data);
                    this.setProcData(proc, data);
                    utils_1.MDUtilsV4.setEngine(proc, data.engine);
                    const isNoteRef = !lodash_1.default.isUndefined(data.noteRefLvl);
                    const shouldInsertTitle = isNoteRef ? false : (_a = data.config) === null || _a === void 0 ? void 0 : _a.useFMTitle;
                    // NOTE: order matters. this needs to appear before `dendronPub`
                    if (data.dest === types_1.DendronASTDest.HTML) {
                        proc = proc.use(backlinks_1.backlinks).use(remark_2.hierarchies);
                    }
                    // Add flavor specific plugins. These need to come before `dendronPub`
                    // to fix extended image URLs before they get converted to HTML
                    if (opts.flavor === ProcFlavor.PREVIEW) {
                        proc = proc.use(dendronPreview_1.dendronPreview);
                    }
                    if (opts.flavor === ProcFlavor.HOVER_PREVIEW) {
                        proc = proc.use(dendronPreview_1.dendronHoverPreview);
                    }
                    // add additional plugins
                    proc = proc.use(dendronPub_1.dendronPub, {
                        insertTitle: shouldInsertTitle,
                        transformNoPublish: opts.flavor === ProcFlavor.PUBLISHING ? true : false,
                    });
                    if ((_b = data.config) === null || _b === void 0 ? void 0 : _b.useKatex) {
                        proc = proc.use(remark_math_1.default);
                    }
                    if ((_c = data.config) === null || _c === void 0 ? void 0 : _c.mermaid) {
                        proc = proc.use(remark_mermaid_1.default, { simple: true });
                    }
                    // Add remaining flavor specific plugins
                    if (opts.flavor === ProcFlavor.PUBLISHING) {
                        const prefix = ((_d = data.config) === null || _d === void 0 ? void 0 : _d.site.assetsPrefix)
                            ? ((_e = data.config) === null || _e === void 0 ? void 0 : _e.site.assetsPrefix) + "/notes/"
                            : "/notes/";
                        proc = proc.use(dendronPub_1.dendronPub, {
                            wikiLinkOpts: {
                                prefix,
                            },
                        });
                    }
                }
                break;
            case ProcMode.IMPORT: {
                const requiredProps = ["vault", "engine", "dest"];
                const resp = checkProps({ requiredProps, data });
                if (!resp.valid) {
                    throw common_all_1.DendronError.createFromStatus({
                        status: common_all_1.ERROR_STATUS.INVALID_CONFIG,
                        message: `missing required fields in data. ${resp.missing.join(" ,")} missing`,
                    });
                }
                if (!data.config) {
                    data.config = data.engine.config;
                }
                if (!data.wsRoot) {
                    data.wsRoot = data.engine.wsRoot;
                }
                // backwards compatibility, default to v4 values
                data = lodash_1.default.defaults(utils_1.MDUtilsV4.getDendronData(proc), data);
                this.setProcData(proc, data);
                utils_1.MDUtilsV4.setEngine(proc, data.engine);
                // add additional plugins
                if ((_f = data.config) === null || _f === void 0 ? void 0 : _f.useKatex) {
                    proc = proc.use(remark_math_1.default);
                }
                if ((_g = data.config) === null || _g === void 0 ? void 0 : _g.mermaid) {
                    proc = proc.use(remark_mermaid_1.default, { simple: true });
                }
                break;
            }
            case ProcMode.NO_DATA:
                break;
            default:
                common_all_1.assertUnreachable();
        }
        return proc;
    }
    static _procRehype(opts, data) {
        var _a;
        const pRemarkParse = this.procRemarkParse(opts, {
            ...data,
            dest: types_1.DendronASTDest.HTML,
        });
        // add additional plugin for publishing
        let pRehype = pRemarkParse
            .use(remark_rehype_1.default, { allowDangerousHtml: true })
            .use(rehype_prism_1.default, { ignoreMissing: true })
            .use(rehype_raw_1.default)
            .use(rehype_slug_1.default);
        // apply plugins enabled by config
        if ((_a = data === null || data === void 0 ? void 0 : data.config) === null || _a === void 0 ? void 0 : _a.useKatex) {
            pRehype = pRehype.use(rehype_katex_1.default);
        }
        // apply publishing specific things
        if (this.shouldApplyPublishingRules(pRehype)) {
            pRehype = pRehype.use(rehype_autolink_headings_1.default, {
                properties: {
                    "aria-hidden": "true",
                    class: "anchor-heading",
                },
                content: {
                    type: "element",
                    tagName: "svg",
                    properties: {
                        "aria-hidden": "true",
                        viewBox: "0 0 16 16",
                    },
                    children: [
                        {
                            type: "element",
                            tagName: "use",
                            properties: {
                                "xlink:href": "#svg-link",
                            },
                        },
                    ],
                },
            });
        }
        return pRehype;
    }
    static procRemarkFull(data, opts) {
        return this._procRemark({
            mode: (opts === null || opts === void 0 ? void 0 : opts.mode) || ProcMode.FULL,
            flavor: (opts === null || opts === void 0 ? void 0 : opts.flavor) || ProcFlavor.REGULAR,
        }, data);
    }
    /**
     * Parse Dendron Markdown Note. No compiler is attached.
     * @param opts
     * @param data
     * @returns
     */
    static procRemarkParse(opts, data) {
        return this._procRemark({ ...opts, parseOnly: true }, data);
    }
    /**
     * Equivalent to running {@link procRemarkParse({mode: ProcMode.NO_DATA})}
     */
    static procRemarkParseNoData(opts, data) {
        return this._procRemark({ ...opts, parseOnly: true, mode: ProcMode.NO_DATA }, data);
    }
    /**
     * Equivalent to running {@link procRemarkParse({mode: ProcMode.FULL})}
     */
    static procRemarkParseFull(opts, data) {
        return this._procRemark({ ...opts, parseOnly: true, mode: ProcMode.FULL }, data);
    }
    static procRehypeParse(opts, data) {
        return this._procRemark({ ...opts, parseOnly: true }, { ...data, dest: types_1.DendronASTDest.HTML });
    }
    static procRehypeFull(data, opts) {
        const proc = this._procRehype({ mode: ProcMode.FULL, parseOnly: false, flavor: opts === null || opts === void 0 ? void 0 : opts.flavor }, data);
        return proc.use(rehype_stringify_1.default);
    }
}
exports.MDUtilsV5 = MDUtilsV5;
//# sourceMappingURL=utilsv5.js.map