"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitUtils = exports.simpleGit = void 0;
const common_all_1 = require("@dendronhq/common-all");
const execa_1 = __importDefault(require("execa"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const simple_git_1 = __importDefault(require("simple-git"));
exports.simpleGit = simple_git_1.default;
const url_1 = require("url");
const files_1 = require("./files");
const filesv2_1 = require("./filesv2");
const formatString = (opts) => {
    const { txt, note } = opts;
    lodash_1.default.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
    const noteHiearchy = note.fname.replace(/\./g, "/");
    return lodash_1.default.template(txt)({ noteHiearchy });
};
/**
 *  NOTICE: Lots of the Git code is obtained from https://github.com/KnisterPeter/vscode-github, licened under MIT
 */
/**
 * Utilities for working with git urls
 */
class GitUtils {
    static canShowGitLink(opts) {
        const { config, note } = opts;
        if (lodash_1.default.isBoolean((note.custom || {})[common_all_1.RESERVED_KEYS.GIT_NO_LINK]) &&
            note.custom[common_all_1.RESERVED_KEYS.GIT_NO_LINK]) {
            return false;
        }
        return lodash_1.default.every([
            config.site.gh_edit_link,
            config.site.gh_edit_link_text,
            config.site.gh_edit_repository,
            config.site.gh_edit_branch,
            config.site.gh_edit_view_mode,
        ]);
    }
    /**
     * Convert a github repo orul to access token format
     */
    static getGithubAccessTokenUrl(opts) {
        const { remotePath, accessToken } = opts;
        let repoPath;
        if (remotePath.startsWith("https://")) {
            repoPath = remotePath.split("/").slice(-2).join("/");
        }
        else {
            repoPath = opts.remotePath.split(":").slice(-1)[0];
        }
        return `https://${accessToken}:x-oauth-basic@github.com/${repoPath}`;
    }
    static git2Github(gitUrl) {
        // 'git@github.com:kevinslin/dendron-vault.git'
        // @ts-ignore
        const [_, userAndRepo] = gitUrl.split(":");
        const [user, repo] = userAndRepo.split("/");
        return `https://github.com/${user}/${path_1.default.basename(repo, ".git")}`;
    }
    static getGithubEditUrl(opts) {
        const { note, config, wsRoot } = opts;
        const vault = note.vault;
        const vaults = common_all_1.ConfigUtils.getVaults(config);
        const mvault = common_all_1.VaultUtils.matchVault({ wsRoot, vault, vaults });
        const vaultUrl = lodash_1.default.get(mvault, "remote.url", false);
        const gitRepoUrl = config.site.gh_edit_repository;
        // if we have a vault, we don't need to include the vault name as an offset
        if (mvault && vaultUrl) {
            return lodash_1.default.join([
                this.git2Github(vaultUrl),
                config.site.gh_edit_view_mode,
                config.site.gh_edit_branch,
                note.fname + ".md",
            ], "/");
        }
        let gitNotePath = lodash_1.default.join([path_1.default.basename(vault.fsPath), note.fname + ".md"], "/");
        if (lodash_1.default.has(note === null || note === void 0 ? void 0 : note.custom, common_all_1.RESERVED_KEYS.GIT_NOTE_PATH)) {
            gitNotePath = formatString({
                txt: note.custom[common_all_1.RESERVED_KEYS.GIT_NOTE_PATH],
                note,
            });
        }
        // this assumes we have a workspace url
        return lodash_1.default.join([
            gitRepoUrl,
            config.site.gh_edit_view_mode,
            config.site.gh_edit_branch,
            gitNotePath,
        ], "/");
    }
    static getOwnerAndRepoFromURL(url) {
        const [owner, repo] = url.split("/").slice(-2);
        return { owner, repo };
    }
    static getRepoNameFromURL(url) {
        return path_1.default.basename(url, ".git");
    }
    static getVaultFromRepo(opts) {
        const { repoPath, wsRoot } = opts;
        return {
            fsPath: path_1.default.relative(wsRoot, repoPath),
            remote: { type: "git", url: opts.repoUrl },
        };
    }
    static getVaultsFromRepo(opts) {
        const { repoPath, wsRoot, repoUrl } = opts;
        // is workspace root
        if (fs_extra_1.default.existsSync(path_1.default.join(repoPath, common_all_1.CONSTANTS.DENDRON_CONFIG_FILE))) {
            const config = files_1.readYAML(path_1.default.join(repoPath, common_all_1.CONSTANTS.DENDRON_CONFIG_FILE));
            const workspace = path_1.default.basename(repoPath);
            const vaultsConfig = common_all_1.ConfigUtils.getVaults(config);
            const vaults = vaultsConfig.map((ent) => {
                const vpath = filesv2_1.vault2Path({ vault: ent, wsRoot: repoPath });
                return {
                    ...ent,
                    workspace,
                    fsPath: path_1.default.relative(path_1.default.join(wsRoot, workspace), vpath),
                };
            });
            return {
                workspace: {
                    name: workspace,
                    vaults,
                    remote: {
                        type: "git",
                        url: repoUrl,
                    },
                },
                vaults,
            };
        }
        else {
            return {
                vaults: [
                    {
                        fsPath: path_1.default.relative(wsRoot, repoPath),
                        remote: { type: "git", url: opts.repoUrl },
                    },
                ],
            };
        }
    }
    static isRepo(src) {
        return fs_extra_1.default.existsSync(src) && fs_extra_1.default.existsSync(path_1.default.join(src, ".git"));
    }
    static async getGitRoot(uri) {
        try {
            const response = await this.execute("git rev-parse --show-toplevel", uri);
            return response.stdout.trim();
        }
        catch (err) {
            // Not in a git repository
            if (err.failed)
                return undefined;
            throw err;
        }
    }
    static async getGithubFileUrl(uri, file, line = 0, endLine = 0) {
        const hostname = await this.getGitHostname(uri);
        const [owner, repo] = await this.getGitProviderOwnerAndRepository(uri);
        const branch = await this.getCurrentBranch(uri);
        const currentFile = file.replace(/^\//, "").replace(/^\\/, "");
        return `https://${hostname}/${owner}/${repo}/blob/${branch}/${currentFile}#L${line + 1}:L${endLine + 1}`;
    }
    static async getGitHostname(uri) {
        return (await this.getGitProviderOwnerAndRepositoryFromGitConfig(uri))[1];
    }
    /**
     * Looks at URI for git repo
     * @param uri
     * @returns
     */
    static async getGitProviderOwnerAndRepositoryFromGitConfig(uri) {
        const remoteName = await this.getRemoteName(uri);
        try {
            const remote = (await this.execute(`git config --local --get remote.${remoteName}.url`, uri)).stdout.trim();
            if (!remote.length) {
                throw new Error("Git remote is empty!");
            }
            return this.parseGitUrl(remote);
        }
        catch (e) {
            const remotes = await this.getRemoteNames(uri);
            if (!remotes.includes(remoteName)) {
                throw new common_all_1.DendronError({
                    message: `Your configuration contains an invalid remoteName. You should probably use one of these:\n ${remotes.join("\n")}`,
                });
            }
            throw e;
        }
    }
    static async getRemoteName(uri) {
        const remoteName = await this.calculateRemoteName(uri);
        if (remoteName) {
            return remoteName;
        }
        // fallback to origin which is a sane default
        return "origin";
    }
    static async calculateRemoteName(uri) {
        const ref = (await this.execute(`git symbolic-ref -q HEAD`, uri)).stdout.trim();
        const upstreamName = (await this.execute(`git for-each-ref --format='%(upstream)' '${ref}'`, uri)).stdout.trim();
        const match = upstreamName.match(/refs\/remotes\/([^/]+)\/.*/);
        if (match) {
            return match[1];
        }
        return undefined;
    }
    static parseGitUrl(remote) {
        // git protocol remotes, may be git@github:username/repo.git
        // or git://github/user/repo.git, domain names are not case-sensetive
        if (remote.startsWith("git@") || remote.startsWith("git://")) {
            return this.parseGitProviderUrl(remote);
        }
        return this.getGitProviderOwnerAndRepositoryFromHttpUrl(remote);
    }
    static parseGitProviderUrl(remote) {
        const match = new RegExp("^git(?:@|://)([^:/]+)(?::|:/|/)([^/]+)/(.+?)(?:.git)?$", "i").exec(remote);
        if (!match) {
            throw new Error(`'${remote}' does not seem to be a valid git provider url.`);
        }
        return ["git:", ...match.slice(1, 4)];
    }
    static getGitProviderOwnerAndRepositoryFromHttpUrl(remote) {
        // it must be http or https based remote
        const { protocol = "https:", hostname, pathname } = url_1.parse(remote);
        if (!protocol) {
            throw Error("impossible");
        }
        // domain names are not case-sensetive
        if (!hostname || !pathname) {
            throw new Error("Not a Provider remote!");
        }
        const match = pathname.match(/\/(.*?)\/(.*?)(?:.git)?$/);
        if (!match) {
            throw new Error("Not a Provider remote!");
        }
        return [protocol, hostname, ...match.slice(1, 3)];
    }
    static async getRemoteNames(uri) {
        const remotes = (await this.execute(`git config --local --get-regexp "^remote.*.url"`, uri)).stdout.trim();
        return remotes
            .split("\n")
            .map((line) => new RegExp("^remote.([^.]+).url.*").exec(line))
            .map((match) => match && match[1])
            .filter((name) => Boolean(name));
    }
    static async getGitProviderOwnerAndRepository(uri) {
        return (await this.getGitProviderOwnerAndRepositoryFromGitConfig(uri)).slice(2, 4);
    }
    static async getCurrentBranch(uri) {
        const stdout = (await this.execute("git branch", uri)).stdout;
        const match = stdout.match(/^\* (.*)$/m);
        return match ? match[1] : undefined;
    }
    static async execute(cmd, uri) {
        const [git, ...args] = cmd.split(" ");
        return execa_1.default(git, args, { cwd: uri });
    }
}
exports.GitUtils = GitUtils;
//# sourceMappingURL=git.js.map