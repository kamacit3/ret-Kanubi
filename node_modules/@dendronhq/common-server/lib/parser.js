"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SchemaParserV2 = exports.ParserBaseV2 = void 0;
const common_all_1 = require("@dendronhq/common-all");
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const filesv2_1 = require("./filesv2");
const logger_1 = require("./logger");
let _LOGGER;
function getLogger() {
    if (!_LOGGER) {
        _LOGGER = logger_1.createLogger();
    }
    return _LOGGER;
}
class ParserBaseV2 {
    constructor(opts) {
        this.opts = opts;
    }
    get logger() {
        return this.opts.logger;
    }
}
exports.ParserBaseV2 = ParserBaseV2;
const DEFAULT_LOG_CTX = "parsingSchemas";
async function getSchemasFromImport(imports, opts) {
    const vpath = filesv2_1.vault2Path({ vault: opts.root, wsRoot: opts.wsRoot });
    let schemaModulesFromImport = [];
    await Promise.all(lodash_1.default.map(imports, async (ent) => {
        const fpath = path_1.default.join(vpath, ent + ".schema.yml");
        schemaModulesFromImport.push(await filesv2_1.file2Schema(fpath, opts.wsRoot));
    }));
    const schemaPropsFromImport = schemaModulesFromImport.flatMap((mod) => {
        const domain = mod.fname;
        return lodash_1.default.values(mod.schemas).map((ent) => {
            ent.data.pattern = ent.data.pattern || ent.id;
            ent.id = `${domain}.${ent.id}`;
            ent.fname = opts.fname;
            ent.parent = null;
            ent.children = ent.children.map((ent) => `${domain}.${ent}`);
            ent.vault = opts.root;
            return ent;
        });
    });
    getLogger().debug({ ctx: DEFAULT_LOG_CTX, schemaPropsFromImport });
    return schemaPropsFromImport;
}
class SchemaParserV2 extends ParserBaseV2 {
    static async parseRaw(schemaOpts, opts) {
        const version = lodash_1.default.isArray(schemaOpts) ? 0 : 1;
        if (version > 0) {
            return await SchemaParserV2.parseSchemaModuleOpts(schemaOpts, opts);
        }
        else {
            // TODO: legacy
            const schemaDict = {};
            schemaOpts.map((ent) => {
                const schema = common_all_1.SchemaUtils.create(ent);
                schemaDict[schema.id] = schema;
            });
            const maybeRoot = lodash_1.default.find(lodash_1.default.values(schemaDict), {
                parent: "root",
            });
            return {
                version: 0,
                root: maybeRoot,
                schemas: schemaDict,
                fname: opts.fname,
                vault: opts.root,
            };
        }
    }
    static noInlineChildren(ent) {
        return (!ent.children || ent.children.length === 0 || lodash_1.default.isString(ent.children[0]));
    }
    static getSchemasFromFile(schemas, vault) {
        const collector = [];
        schemas.forEach((ent) => {
            if (this.noInlineChildren(ent)) {
                // Means we are dealing with non-inline schema and can just collect
                // the parsed value.
                collector.push(common_all_1.SchemaUtils.create({ ...ent, vault }));
            }
            else {
                // When we are dealing with inline children we need to process/collect
                // the children bottom up from the inline tree and replace the children
                // object with collected/generated ids of the inline children.
                ent.children = this.processChildren(ent.children, collector, vault);
                // No all the entity children objects are collected and they have
                // been replaced with identifiers we can collect the root element itself.
                collector.push(common_all_1.SchemaUtils.create({ ...ent, vault }));
            }
        });
        getLogger().debug({ ctx: DEFAULT_LOG_CTX, schemaPropsFromFile: collector });
        return collector;
    }
    static processChildren(children, collector, vault) {
        if (!children) {
            return [];
        }
        return children.map((child) => {
            // To process the node we need all its children to already be processed
            // hence call process children recursively to process the graph from bottom up.
            child.children = this.processChildren(child.children, collector, vault);
            this.setIdIfMissing(child);
            collector.push(common_all_1.SchemaUtils.create({ ...child, vault }));
            return child.id;
        });
    }
    /**
     * Ids are optional for inline schemas hence if there isn't an id
     * we will generate the identifier. */
    static setIdIfMissing(ent) {
        if (!ent.id) {
            // When id is missing than we must have a pattern for the schema.
            if (!ent.pattern) {
                throw new common_all_1.DendronError({
                    message: `Pattern is missing in schema without id schema='${JSON.stringify(ent)}'`,
                    // Setting severity as minor since Dendron could still be functional even
                    // if some particular schema is malformed.
                    severity: common_all_1.ERROR_SEVERITY.MINOR,
                });
            }
            ent.id = common_all_1.genUUID();
        }
    }
    static async parseSchemaModuleOpts(schemaModuleProps, opts) {
        const { imports, schemas, version } = schemaModuleProps;
        const { fname, root } = opts;
        getLogger().info({ ctx: DEFAULT_LOG_CTX, fname, root, imports });
        const schemasAll = [
            ...(await getSchemasFromImport(imports, opts)),
            ...this.getSchemasFromFile(schemas, root),
        ];
        const schemasDict = {};
        schemasAll.forEach((ent) => {
            schemasDict[ent.id] = ent;
        });
        const addConnections = (parent) => {
            lodash_1.default.forEach(parent.children, (ch) => {
                const child = schemasDict[ch];
                if (child) {
                    common_all_1.DNodeUtils.addChild(parent, child);
                    addConnections(child);
                }
                else {
                    throw new common_all_1.DendronError({
                        status: common_all_1.ERROR_STATUS.MISSING_SCHEMA,
                        message: JSON.stringify({ parent, missingChild: ch }),
                    });
                }
            });
        };
        // add parent relationship
        const rootModule = common_all_1.SchemaUtils.getModuleRoot(schemaModuleProps);
        addConnections(rootModule);
        return {
            version,
            imports,
            root: rootModule,
            schemas: schemasDict,
            fname,
            vault: root,
        };
    }
}
exports.SchemaParserV2 = SchemaParserV2;
//# sourceMappingURL=parser.js.map