"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.tmp = exports.dot2Slash = exports.writeJSONWithComments = exports.vault2Path = exports.tmpDir = exports.readJSONWithCommentsSync = exports.readJSONWithComments = exports.assignJSONWithComment = exports.schemaModuleProps2File = exports.schemaModuleOpts2File = exports.note2File = exports.findUpTo = exports.goUpTo = exports.note2String = exports.file2NoteWithCache = exports.file2Note = exports.string2Note = exports.string2Schema = exports.genHash = exports.file2Schema = exports.createFileWatcher = void 0;
const common_all_1 = require("@dendronhq/common-all");
const comment_json_1 = require("comment-json");
const fs_extra_1 = __importDefault(require("fs-extra"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
// @ts-ignore
const tmp_1 = __importStar(require("tmp"));
exports.tmp = tmp_1.default;
const files_1 = require("./files");
const parser_1 = require("./parser");
const spark_md5_1 = __importDefault(require("spark-md5"));
async function createFileWatcher(opts) {
    const { numTries, fpath, onChange } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    let didCreate = false;
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            return setTimeout(() => {
                resolve(_createFileWatcher({
                    ...opts,
                    numTries: numTries - 1,
                    isCreate: true,
                }));
            }, 3000);
        }
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate });
    });
}
exports.createFileWatcher = createFileWatcher;
async function _createFileWatcher(opts) {
    const { numTries, fpath, onChange, onCreate } = lodash_1.default.defaults(opts, {
        numTries: 5,
    });
    if (numTries <= 0) {
        throw new common_all_1.DendronError({ message: "exceeded numTries" });
    }
    return new Promise(async (resolve, _reject) => {
        if (!fs_extra_1.default.existsSync(fpath)) {
            console.log({ fpath, msg: "not exist" });
            return setTimeout(() => {
                resolve(createFileWatcher({ ...opts, numTries: numTries - 1 }));
            }, 3000);
        }
        await onCreate({ fpath });
        const watcher = fs_extra_1.default.watch(fpath, () => {
            onChange({ fpath });
        });
        return resolve({ watcher, didCreate: true });
    });
}
async function file2Schema(fpath, wsRoot) {
    const root = { fsPath: path_1.default.dirname(fpath) };
    const fname = path_1.default.basename(fpath, ".schema.yml");
    const schemaOpts = js_yaml_1.default.safeLoad(await fs_extra_1.default.readFile(fpath, { encoding: "utf8" }), {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
    return await parser_1.SchemaParserV2.parseRaw(schemaOpts, { root, fname, wsRoot });
}
exports.file2Schema = file2Schema;
function genHash(contents) {
    return spark_md5_1.default.hash(contents); // OR raw hash (binary string)
}
exports.genHash = genHash;
async function string2Schema({ vault, content, fname, wsRoot, }) {
    const schemaOpts = js_yaml_1.default.safeLoad(content, {
        schema: js_yaml_1.default.JSON_SCHEMA,
    });
    return await parser_1.SchemaParserV2.parseRaw(schemaOpts, {
        root: vault,
        fname,
        wsRoot,
    });
}
exports.string2Schema = string2Schema;
/**
 *
 * @param calculateHash - when set, add `contentHash` property to the note
 *  Default: false
 * @returns
 */
function string2Note({ content, fname, vault, calculateHash, }) {
    const options = {
        engines: {
            yaml: {
                parse: (s) => js_yaml_1.default.safeLoad(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
                stringify: (s) => js_yaml_1.default.safeDump(s, { schema: js_yaml_1.default.JSON_SCHEMA }),
            },
        },
    };
    const { data, content: body } = gray_matter_1.default(content, options);
    const custom = common_all_1.DNodeUtils.getCustomProps(data);
    const contentHash = calculateHash ? genHash(content) : undefined;
    const note = common_all_1.DNodeUtils.create({
        ...data,
        custom,
        fname,
        body,
        type: "note",
        vault,
        contentHash,
    });
    return note;
}
exports.string2Note = string2Note;
function file2Note(fpath, vault, toLowercase) {
    const content = fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" });
    const { name } = path_1.default.parse(fpath);
    const fname = toLowercase ? name.toLowerCase() : name;
    return string2Note({ content, fname, vault });
}
exports.file2Note = file2Note;
function file2NoteWithCache({ fpath, vault, cache, toLowercase, }) {
    var _a;
    const content = fs_extra_1.default.readFileSync(fpath, { encoding: "utf8" });
    const { name } = path_1.default.parse(fpath);
    const sig = genHash(content);
    const matchHash = ((_a = cache.notes[name]) === null || _a === void 0 ? void 0 : _a.hash) === sig;
    const fname = toLowercase ? name.toLowerCase() : name;
    let note;
    // if hash matches, note hasn't changed
    if (matchHash) {
        // since we don't store the note body in the cache file, we need to re-parse the body
        let capture = content.match(/^---[\s\S]+?---/);
        if (capture) {
            let offset = capture[0].length;
            let body = content.slice(offset + 1);
            // vault can change without note changing so we need to add this
            // add `contentHash` to this signature because its not saved with note
            note = { ...cache.notes[name].data, body, vault, contentHash: sig };
            return { note, matchHash, noteHash: sig };
        }
    }
    note = string2Note({ content, fname, vault });
    note.contentHash = sig;
    return { note, matchHash, noteHash: sig };
}
exports.file2NoteWithCache = file2NoteWithCache;
/** Read the contents of a note from the filesystem.
 *
 * Warning! The note contents may be out of date compared to changes in the editor.
 * Consider using `NoteUtils.serialize` instead.
 */
function note2String(opts) {
    const notePath = common_all_1.NoteUtils.getFullPath(opts);
    return fs_extra_1.default.readFile(notePath, { encoding: "utf8" });
}
exports.note2String = note2String;
/**
 * Go to dirname that {fname} is contained in
 * @param maxLvl? - default: 10
 @deprecated use {@link findUpTo}
 */
function goUpTo(opts) {
    let { fname, base, maxLvl } = lodash_1.default.defaults(opts, { maxLvl: 10 });
    const lvls = [];
    while (maxLvl > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_extra_1.default.existsSync(tryPath)) {
            return path_1.default.dirname(tryPath);
        }
        maxLvl -= 1;
        lvls.push("..");
    }
    throw Error(`no root found from ${base}`);
}
exports.goUpTo = goUpTo;
/**
 * Go to dirname that {fname} is contained in
 * @param maxLvl - default: 10
 * @param returnDirPath - return path to directory, default: false
 */
function findUpTo(opts) {
    const { fname, base, maxLvl, returnDirPath } = lodash_1.default.defaults(opts, {
        maxLvl: 3,
        returnDirPath: false,
    });
    const lvls = [];
    let acc = 0;
    while (maxLvl - acc > 0) {
        const tryPath = path_1.default.join(base, ...lvls, fname);
        if (fs_extra_1.default.existsSync(tryPath)) {
            return returnDirPath ? path_1.default.dirname(tryPath) : tryPath;
        }
        acc += 1;
        lvls.push("..");
    }
    return undefined;
}
exports.findUpTo = findUpTo;
function note2File({ note, vault, wsRoot, opts, }) {
    const { fname } = note;
    const ext = ".md";
    const payload = common_all_1.NoteUtils.serialize(note, opts);
    const vpath = exports.vault2Path({ vault, wsRoot });
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), payload);
}
exports.note2File = note2File;
function schemaModuleOpts2File(schemaFile, vaultPath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vaultPath, fname + ext), common_all_1.SchemaUtils.serializeModuleOpts(schemaFile));
}
exports.schemaModuleOpts2File = schemaModuleOpts2File;
function schemaModuleProps2File(schemaMProps, vpath, fname) {
    const ext = ".schema.yml";
    return fs_extra_1.default.writeFile(path_1.default.join(vpath, fname + ext), common_all_1.SchemaUtils.serializeModuleProps(schemaMProps));
}
exports.schemaModuleProps2File = schemaModuleProps2File;
function assignJSONWithComment(jsonObj, dataToAdd) {
    return comment_json_1.assign({
        ...dataToAdd,
    }, jsonObj);
}
exports.assignJSONWithComment = assignJSONWithComment;
async function readJSONWithComments(fpath) {
    const content = await fs_extra_1.default.readFile(fpath);
    const obj = comment_json_1.parse(content.toString());
    return obj;
}
exports.readJSONWithComments = readJSONWithComments;
function readJSONWithCommentsSync(fpath) {
    const content = fs_extra_1.default.readFileSync(fpath);
    const obj = comment_json_1.parse(content.toString());
    return obj;
}
exports.readJSONWithCommentsSync = readJSONWithCommentsSync;
function tmpDir() {
    const dirPath = tmp_1.dirSync();
    return dirPath;
}
exports.tmpDir = tmpDir;
const vault2Path = ({ vault, wsRoot, }) => {
    return files_1.resolvePath(common_all_1.VaultUtils.getRelPath(vault), wsRoot);
};
exports.vault2Path = vault2Path;
function writeJSONWithComments(fpath, data) {
    const payload = comment_json_1.stringify(data, null, 4);
    return fs_extra_1.default.writeFileSync(fpath, payload);
}
exports.writeJSONWithComments = writeJSONWithComments;
/**
 * Turn . delimited file to / separated
 */
function dot2Slash(fname) {
    return fname.replace(/\./g, "/");
}
exports.dot2Slash = dot2Slash;
//# sourceMappingURL=filesv2.js.map